import {
  MerkleTree,
  convertQuantity,
  hashEntry
} from "./chunk-AEK3PQH7.js";
import "./chunk-43F4DZXD.js";
import {
  ZERO_ADDRESS,
  isNativeTokenAddress
} from "./chunk-YCZ3YGMG.js";
import "./chunk-PF7J76SD.js";
import {
  download
} from "./chunk-A5QRUZ7S.js";
import "./chunk-NCIUOEBK.js";
import "./chunk-6JZ5SMSC.js";
import "./chunk-QWRIO2XV.js";
import "./chunk-2OMZKD5Y.js";
import "./chunk-HAADYJEF.js";
import "./chunk-A2CDDISI.js";
import "./chunk-JZ3W4FG5.js";
import "./chunk-SS3OIJZU.js";
import "./chunk-T2RSOTGF.js";
import "./chunk-MW5FLPJ5.js";
import "./chunk-UG6X6BL6.js";
import "./chunk-4HC36SBT.js";
import "./chunk-HXWRQBIO.js";
import "./chunk-FLUAB4EX.js";
import "./chunk-L7Y3EIPZ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-HARK4W7T.js";
import "./chunk-5JRVV4XU.js";

// node_modules/thirdweb/dist/esm/utils/extensions/drops/fetch-proofs-for-claimers.js
async function fetchProofsForClaimer(options) {
  const { contract, merkleTreeUri, claimer } = options;
  const hashEntryFn = options.hashEntry || hashEntry;
  const response = await download({
    client: contract.client,
    uri: merkleTreeUri
  });
  const merkleInfo = await response.json();
  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();
  const uri = merkleInfo.baseUri.endsWith("/") ? merkleInfo.baseUri : `${merkleInfo.baseUri}/`;
  let shardData;
  try {
    const constructedShardUri = `${uri}${shardId}.json`;
    const shard = await download({
      client: contract.client,
      uri: constructedShardUri
    });
    shardData = await shard.json();
  } catch {
    return null;
  }
  const hashedEntries = await Promise.all(shardData.entries.map(async (entry2) => {
    return hashEntryFn({
      chain: contract.chain,
      client: contract.client,
      entry: entry2,
      tokenDecimals: options.tokenDecimals
    });
  }));
  const tree = new MerkleTree(hashedEntries);
  const entry = shardData.entries.find((i) => i.address.toLowerCase() === claimer.toLowerCase());
  if (!entry) {
    return null;
  }
  const proof = tree.getHexProof(await hashEntryFn({
    chain: contract.chain,
    client: contract.client,
    entry,
    tokenDecimals: options.tokenDecimals
  })).concat(shardData.proofs);
  const currencyAddress = entry.currencyAddress || ZERO_ADDRESS;
  const currencyDecimals = await (async () => {
    if (isNativeTokenAddress(currencyAddress) || currencyAddress === ZERO_ADDRESS) {
      return 18;
    }
    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([
      import("./contract-WTFYTEAQ.js"),
      import("./decimals-6RN5WQ57.js")
    ]);
    const currencyContract = getContract({
      address: currencyAddress,
      chain: contract.chain,
      client: contract.client
    });
    return await getDecimals({ contract: currencyContract });
  })();
  return {
    currency: currencyAddress,
    pricePerToken: convertQuantity({
      quantity: entry.price || "unlimited",
      tokenDecimals: currencyDecimals
    }),
    proof,
    quantityLimitPerWallet: convertQuantity({
      quantity: entry.maxClaimable || "unlimited",
      tokenDecimals: options.tokenDecimals
    })
  };
}
export {
  fetchProofsForClaimer
};
//# sourceMappingURL=fetch-proofs-for-claimers-54SXGSFQ.js.map
