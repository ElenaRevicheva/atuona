import {
  isZkSyncChain
} from "./chunk-YFG5RXKC.js";
import {
  encode
} from "./chunk-3JLKE5UZ.js";
import {
  estimateGas,
  getGasOverridesForTransaction
} from "./chunk-B7FDTVAN.js";
import {
  resolvePromisedValue
} from "./chunk-L4NN5UUQ.js";
import {
  getAddress
} from "./chunk-NCIUOEBK.js";
import {
  getRpcClient
} from "./chunk-67FUEQYA.js";

// node_modules/thirdweb/dist/esm/transaction/actions/to-serializable-transaction.js
async function toSerializableTransaction(options) {
  const isZkSync = await isZkSyncChain(options.transaction.chain);
  if (isZkSync) {
    const { getZkGasFees } = await import("./send-eip712-transaction-7V674N7M.js");
    const { gas: gas2, maxFeePerGas, maxPriorityFeePerGas } = await getZkGasFees({
      from: typeof options.from === "string" ? getAddress(options.from) : options.from !== void 0 ? getAddress(options.from.address) : void 0,
      transaction: options.transaction
    });
    options.transaction = {
      ...options.transaction,
      gas: gas2,
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const rpcRequest = getRpcClient(options.transaction);
  const chainId = options.transaction.chain.id;
  const from = options.from;
  let [data, nonce, gas, feeData, to, accessList, value, authorizationList, type] = await Promise.all([
    encode(options.transaction),
    (async () => {
      const resolvedNonce = await resolvePromisedValue(options.transaction.nonce);
      if (resolvedNonce !== void 0) {
        return resolvedNonce;
      }
      return from ? await import("./eth_getTransactionCount-S42T2U6B.js").then(({ eth_getTransactionCount }) => eth_getTransactionCount(rpcRequest, {
        address: typeof from === "string" ? getAddress(from) : getAddress(from.address),
        blockTag: "pending"
      })) : void 0;
    })(),
    // takes the same options as the sendTransaction function thankfully!
    estimateGas({
      ...options,
      from: options.from
    }),
    getGasOverridesForTransaction(options.transaction),
    resolvePromisedValue(options.transaction.to),
    resolvePromisedValue(options.transaction.accessList),
    resolvePromisedValue(options.transaction.value),
    resolvePromisedValue(options.transaction.authorizationList),
    resolvePromisedValue(options.transaction.type)
  ]);
  const extraGas = await resolvePromisedValue(options.transaction.extraGas);
  if (extraGas) {
    gas += extraGas;
  }
  return {
    accessList,
    authorizationList,
    chainId,
    data,
    gas,
    nonce,
    to,
    type,
    value,
    ...feeData
  };
}

export {
  toSerializableTransaction
};
//# sourceMappingURL=chunk-UB6XQGY2.js.map
