import {
  claimTo,
  encodeClaim,
  isClaimToSupported
} from "./chunk-Y5M72LLT.js";
import {
  getClaimParams
} from "./chunk-WTVUONKS.js";
import {
  isSetClaimConditionsSupported,
  setClaimConditions
} from "./chunk-K6T76IM6.js";
import {
  convertErc20Amount
} from "./chunk-PNWCWZHE.js";
import {
  isSetContractURISupported
} from "./chunk-4Q7XEJGD.js";
import {
  isSetClaimConditionsSupported as isSetClaimConditionsSupported2
} from "./chunk-3F3QZI6V.js";
import {
  setApprovalForAll
} from "./chunk-AL6UWPS5.js";
import "./chunk-PQGFIGUE.js";
import {
  getActiveClaimCondition,
  getActiveClaimConditionId,
  getClaimConditionById,
  isGetActiveClaimConditionIdSupported,
  isGetActiveClaimConditionSupported,
  isGetClaimConditionByIdSupported
} from "./chunk-YG2PFDN2.js";
import {
  MerkleTree,
  hashEntry
} from "./chunk-AEK3PQH7.js";
import {
  getApproved,
  isGetApprovedSupported
} from "./chunk-SEBECWWW.js";
import {
  isApprovedForAll
} from "./chunk-CNEQWGPT.js";
import {
  ownerOf
} from "./chunk-XFBEZEWF.js";
import {
  upload
} from "./chunk-OWYHLM4P.js";
import {
  balanceOf,
  getOwnedNFTs,
  getOwnedTokenIds,
  tokenOfOwnerByIndex,
  tokensOfOwner
} from "./chunk-D6Z44OO6.js";
import {
  isERC721
} from "./chunk-J3XTMBNV.js";
import {
  getNFT,
  isTokenByIndexSupported,
  isTokenURISupported,
  tokenURI
} from "./chunk-UHYE45BV.js";
import {
  fetchTokenMetadata
} from "./chunk-DOTNSPO6.js";
import "./chunk-GKXU35AR.js";
import {
  isContractURISupported
} from "./chunk-LDCAYGRP.js";
import "./chunk-K6K3E64G.js";
import "./chunk-3PSI24KF.js";
import "./chunk-43F4DZXD.js";
import {
  dateToSeconds,
  tenYearsFromNow
} from "./chunk-HEDJHTOZ.js";
import {
  once
} from "./chunk-NACC2RRT.js";
import {
  min,
  toBigInt
} from "./chunk-ZHJOSFUN.js";
import "./chunk-3TNRD42L.js";
import {
  getContractNFTs
} from "./chunk-D6PVV2F3.js";
import "./chunk-WWY7S4YD.js";
import {
  prepareEvent
} from "./chunk-OWCPC6AZ.js";
import "./chunk-VYHCYMLR.js";
import {
  prepareContractCall
} from "./chunk-CEXHI3CH.js";
import {
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS,
  isNativeTokenAddress
} from "./chunk-YCZ3YGMG.js";
import {
  maxUint256
} from "./chunk-PF7J76SD.js";
import {
  detectMethod
} from "./chunk-DGWZEIL6.js";
import {
  readContract
} from "./chunk-OEYP3ZA3.js";
import {
  encodeAbiParameters
} from "./chunk-NOCRRPHM.js";
import {
  extractErrorResult
} from "./chunk-B7FDTVAN.js";
import "./chunk-RZCLSFDG.js";
import "./chunk-BXEIBF7B.js";
import "./chunk-L4NN5UUQ.js";
import "./chunk-A5QRUZ7S.js";
import "./chunk-6JXWMKOB.js";
import {
  getAddress,
  keccak256
} from "./chunk-NCIUOEBK.js";
import "./chunk-6JZ5SMSC.js";
import "./chunk-QWRIO2XV.js";
import {
  encodePacked
} from "./chunk-2OMZKD5Y.js";
import "./chunk-FHM7BLOT.js";
import "./chunk-67FUEQYA.js";
import "./chunk-HAADYJEF.js";
import "./chunk-A2CDDISI.js";
import {
  randomBytesHex
} from "./chunk-JZ3W4FG5.js";
import {
  toHex
} from "./chunk-SS3OIJZU.js";
import "./chunk-T2RSOTGF.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  getBaseUriFromBatch,
  uploadOrExtractURIs
} from "./chunk-MW5FLPJ5.js";
import "./chunk-UG6X6BL6.js";
import {
  decodeAbiParameters,
  isHex,
  stringToHex
} from "./chunk-4HC36SBT.js";
import "./chunk-HXWRQBIO.js";
import "./chunk-FLUAB4EX.js";
import "./chunk-YEW47TY7.js";
import "./chunk-E7HBP2XZ.js";
import "./chunk-G24WGTAU.js";
import "./chunk-L7Y3EIPZ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-HARK4W7T.js";
import "./chunk-5JRVV4XU.js";

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IBurnableERC721/write/burn.js
var FN_SELECTOR = "0x42966c68";
var FN_INPUTS = [
  {
    name: "tokenId",
    type: "uint256"
  }
];
var FN_OUTPUTS = [];
function isBurnSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS]
  });
}
function burn(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.tokenId];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDelayedReveal/events/TokenURIRevealed.js
function tokenURIRevealedEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event TokenURIRevealed(uint256 indexed index, string revealedURI)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDrop/events/ClaimConditionsUpdated.js
function claimConditionsUpdatedEvent() {
  return prepareEvent({
    signature: "event ClaimConditionsUpdated((uint256 startTimestamp, uint256 maxClaimableSupply, uint256 supplyClaimed, uint256 quantityLimitPerWallet, bytes32 merkleRoot, uint256 pricePerToken, address currency, string metadata)[] claimConditions, bool resetEligibility)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDrop/events/TokensClaimed.js
function tokensClaimedEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event TokensClaimed(uint256 indexed claimConditionIndex, address indexed claimer, address indexed receiver, uint256 startTokenId, uint256 quantityClaimed)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/events/Approval.js
function approvalEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/events/ApprovalForAll.js
function approvalForAllEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event ApprovalForAll(address indexed owner, address indexed operator, bool approved)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/events/Transfer.js
function transferEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/read/startTokenId.js
var FN_SELECTOR2 = "0xe6798baa";
var FN_INPUTS2 = [];
var FN_OUTPUTS2 = [
  {
    type: "uint256"
  }
];
async function startTokenId(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/read/totalSupply.js
var FN_SELECTOR3 = "0x18160ddd";
var FN_INPUTS3 = [];
var FN_OUTPUTS3 = [
  {
    type: "uint256"
  }
];
function isTotalSupplySupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3]
  });
}
async function totalSupply(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/write/approve.js
var FN_SELECTOR4 = "0x095ea7b3";
var FN_INPUTS4 = [
  {
    name: "to",
    type: "address"
  },
  {
    name: "tokenId",
    type: "uint256"
  }
];
var FN_OUTPUTS4 = [];
function approve(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR4, FN_INPUTS4, FN_OUTPUTS4],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.to, resolvedOptions.tokenId];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/write/transferFrom.js
var FN_SELECTOR5 = "0x23b872dd";
var FN_INPUTS5 = [
  {
    name: "from",
    type: "address"
  },
  {
    name: "to",
    type: "address"
  },
  {
    name: "tokenId",
    type: "uint256"
  }
];
var FN_OUTPUTS5 = [];
function transferFrom(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR5, FN_INPUTS5, FN_OUTPUTS5],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [
        resolvedOptions.from,
        resolvedOptions.to,
        resolvedOptions.tokenId
      ];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721Enumerable/read/nextTokenIdToMint.js
var FN_SELECTOR6 = "0x3b1475a7";
var FN_INPUTS6 = [];
var FN_OUTPUTS6 = [
  {
    type: "uint256"
  }
];
function isNextTokenIdToMintSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR6, FN_INPUTS6, FN_OUTPUTS6]
  });
}
async function nextTokenIdToMint(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR6, FN_INPUTS6, FN_OUTPUTS6],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ILazyMint/events/TokensLazyMinted.js
function tokensLazyMintedEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event TokensLazyMinted(uint256 indexed startTokenId, uint256 endTokenId, string baseURI, bytes encryptedBaseURI)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/INFTMetadata/write/setTokenURI.js
var FN_SELECTOR7 = "0x162094c4";
var FN_INPUTS7 = [
  {
    name: "_tokenId",
    type: "uint256"
  },
  {
    name: "_uri",
    type: "string"
  }
];
var FN_OUTPUTS7 = [];
function isSetTokenURISupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR7, FN_INPUTS7, FN_OUTPUTS7]
  });
}
function setTokenURI(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR7, FN_INPUTS7, FN_OUTPUTS7],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.tokenId, resolvedOptions.uri];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ISharedMetadata/events/SharedMetadataUpdated.js
function sharedMetadataUpdatedEvent() {
  return prepareEvent({
    signature: "event SharedMetadataUpdated(string name, string description, string imageURI, string animationURI)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ISharedMetadata/read/sharedMetadata.js
var FN_SELECTOR8 = "0xb280f703";
var FN_INPUTS8 = [];
var FN_OUTPUTS8 = [
  {
    name: "name",
    type: "string"
  },
  {
    name: "description",
    type: "string"
  },
  {
    name: "imageURI",
    type: "string"
  },
  {
    name: "animationURI",
    type: "string"
  }
];
function isSharedMetadataSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR8, FN_INPUTS8, FN_OUTPUTS8]
  });
}
async function sharedMetadata(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR8, FN_INPUTS8, FN_OUTPUTS8],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ISignatureMintERC721/events/TokensMintedWithSignature.js
function tokensMintedWithSignatureEvent(filters = {}) {
  return prepareEvent({
    filters,
    signature: "event TokensMintedWithSignature(address indexed signer, address indexed mintedTo, uint256 indexed tokenIdMinted, (address to, address royaltyRecipient, uint256 royaltyBps, address primarySaleRecipient, string uri, uint256 price, address currency, uint128 validityStartTimestamp, uint128 validityEndTimestamp, bytes32 uid) mintpayload)"
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/DropERC721/read/verifyClaim.js
var FN_SELECTOR9 = "0x23a2902b";
var FN_INPUTS9 = [
  {
    name: "_conditionId",
    type: "uint256"
  },
  {
    name: "_claimer",
    type: "address"
  },
  {
    name: "_quantity",
    type: "uint256"
  },
  {
    name: "_currency",
    type: "address"
  },
  {
    name: "_pricePerToken",
    type: "uint256"
  },
  {
    components: [
      {
        name: "proof",
        type: "bytes32[]"
      },
      {
        name: "quantityLimitPerWallet",
        type: "uint256"
      },
      {
        name: "pricePerToken",
        type: "uint256"
      },
      {
        name: "currency",
        type: "address"
      }
    ],
    name: "_allowlistProof",
    type: "tuple"
  }
];
var FN_OUTPUTS9 = [
  {
    name: "isOverride",
    type: "bool"
  }
];
async function verifyClaim(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR9, FN_INPUTS9, FN_OUTPUTS9],
    params: [
      options.conditionId,
      options.claimer,
      options.quantity,
      options.currency,
      options.pricePerToken,
      options.allowlistProof
    ]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/drops/read/canClaim.js
async function canClaim(options) {
  const [conditionId, { quantity, currency, pricePerToken, allowlistProof }] = await Promise.all([
    getActiveClaimConditionId({
      contract: options.contract
    }),
    getClaimParams({
      contract: options.contract,
      from: options.from,
      quantity: options.quantity,
      to: options.claimer,
      type: "erc721"
    })
  ]);
  try {
    await verifyClaim({
      allowlistProof,
      claimer: options.claimer,
      conditionId,
      contract: options.contract,
      currency,
      pricePerToken,
      quantity
    });
    return {
      result: true
    };
  } catch (error) {
    return {
      reason: await extractErrorResult({ contract: options.contract, error }),
      result: false
    };
  }
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDrop/read/claimCondition.js
var FN_SELECTOR10 = "0xd637ed59";
var FN_INPUTS10 = [];
var FN_OUTPUTS10 = [
  {
    name: "currentStartId",
    type: "uint256"
  },
  {
    name: "count",
    type: "uint256"
  }
];
function isClaimConditionSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR10, FN_INPUTS10, FN_OUTPUTS10]
  });
}
async function claimCondition(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR10, FN_INPUTS10, FN_OUTPUTS10],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/drops/read/getClaimConditions.js
async function getClaimConditions(options) {
  try {
    const [startId, count] = await claimCondition(options);
    const conditionPromises = [];
    for (let i = startId; i < startId + count; i++) {
      conditionPromises.push(getClaimConditionById({
        ...options,
        conditionId: i
      }));
    }
    return Promise.all(conditionPromises);
  } catch {
    throw new Error("Claim condition not found");
  }
}
function isGetClaimConditionsSupported(availableSelectors) {
  return isClaimConditionSupported(availableSelectors) && isGetClaimConditionByIdSupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/extensions/common/__generated__/IMulticall/write/multicall.js
var FN_SELECTOR11 = "0xac9650d8";
var FN_INPUTS11 = [
  {
    name: "data",
    type: "bytes[]"
  }
];
var FN_OUTPUTS11 = [
  {
    name: "results",
    type: "bytes[]"
  }
];
function isMulticallSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR11, FN_INPUTS11, FN_OUTPUTS11]
  });
}
function multicall(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR11, FN_INPUTS11, FN_OUTPUTS11],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.data];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/drops/write/claimToBatch.js
function claimToBatch(options) {
  return multicall({
    asyncParams: () => getClaimToBatchParams(options),
    contract: options.contract,
    overrides: options.overrides
  });
}
async function getClaimToBatchParams(options) {
  var _a, _b;
  for (let i = 0; i < options.content.length; i++) {
    if (!((_a = options.content[i]) == null ? void 0 : _a.quantity)) {
      throw new Error(`Error: Item at index ${i} is missing claim quantity`);
    }
    if (!((_b = options.content[i]) == null ? void 0 : _b.to)) {
      throw new Error(`Error: Item at index ${i} is missing recipient address ("to")`);
    }
  }
  const content = optimizeClaimContent(options.content);
  const data = await Promise.all(content.map(async (item) => {
    const claimParams = await getClaimParams({
      contract: options.contract,
      from: options.from,
      quantity: item.quantity,
      to: item.to,
      type: "erc721"
    });
    return encodeClaim({
      allowlistProof: claimParams.allowlistProof,
      currency: claimParams.currency,
      data: claimParams.data,
      overrides: claimParams.overrides,
      pricePerToken: claimParams.pricePerToken,
      quantity: claimParams.quantity,
      receiver: claimParams.receiver
    });
  }));
  return { data };
}
function optimizeClaimContent(content) {
  const results = [];
  content.forEach((item, index) => {
    const previousItem = results.at(-1);
    if (index > 0 && previousItem && item.to.toLowerCase() === previousItem.to.toLowerCase()) {
      results[results.length - 1] = {
        quantity: item.quantity + previousItem.quantity,
        to: item.to
      };
    } else {
      results.push(item);
    }
  });
  return results;
}

// node_modules/thirdweb/dist/esm/extensions/erc721/drops/write/resetClaimEligibility.js
function resetClaimEligibility(options) {
  return setClaimConditions({
    asyncParams: async () => {
      const existingConditions = await getClaimConditions(options);
      return {
        // type is necessary because of viem hex shenanigans (strict vs non-strict `0x` prefix string)
        phases: existingConditions,
        resetClaimEligibility: true
      };
    },
    contract: options.contract
  });
}
function isResetClaimEligibilitySupported(availableSelectors) {
  return isGetClaimConditionsSupported(availableSelectors) && isSetClaimConditionsSupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/utils/extensions/drops/process-override-list.js
async function processOverrideList(options) {
  const hashEntryFn = options.hashEntry || hashEntry;
  const shardNybbles = options.shardNybbles || 2;
  const shards = {};
  for (const snapshotEntry of options.overrides) {
    const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
    if (shards[shard] === void 0) {
      shards[shard] = [];
    }
    shards[shard].push(snapshotEntry);
  }
  const subTrees = await Promise.all(Object.entries(shards).map(async ([shard, entries]) => [
    shard,
    new MerkleTree(await Promise.all(entries.map(async (entry) => {
      return hashEntryFn({
        chain: options.chain,
        client: options.client,
        entry,
        tokenDecimals: options.tokenDecimals
      });
    }))).getHexRoot()
  ]));
  const roots = Object.fromEntries(subTrees);
  const tree = new MerkleTree(Object.values(roots));
  const shardsToUpload = [];
  for (const [shardId, entries] of Object.entries(shards)) {
    const data = {
      entries,
      // biome-ignore lint/style/noNonNullAssertion: we know this is in bounds
      proofs: tree.getHexProof(roots[shardId])
    };
    shardsToUpload.push({
      data: stringify(data),
      name: `${shardId}.json`
    });
  }
  let uris = await upload({
    client: options.client,
    files: shardsToUpload
  });
  if (!Array.isArray(uris)) {
    uris = [uris];
  }
  if (uris.length === 0) {
    throw new Error("No URIs returned from uploading merkle tree shards");
  }
  const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
  const originalEntriesUri = await upload({
    client: options.client,
    files: [stringify(options.overrides)]
  });
  const shardedMerkleInfo = {
    baseUri,
    isShardedMerkleTree: true,
    merkleRoot: tree.getHexRoot(),
    originalEntriesUri,
    shardNybbles,
    tokenDecimals: options.tokenDecimals
  };
  const finalUri = await upload({
    client: options.client,
    files: [shardedMerkleInfo]
  });
  return {
    shardedMerkleInfo,
    uri: finalUri
  };
}

// node_modules/thirdweb/dist/esm/utils/extensions/drops/get-multicall-set-claim-claim-conditon-transactions.js
async function getMulticallSetClaimConditionTransactions(options) {
  const merkleInfos = {};
  const phases = await Promise.all(options.phases.map(async (phase) => {
    var _a;
    let merkleRoot = phase.merkleRootHash || toHex("", { size: 32 });
    if (phase.overrideList) {
      const { shardedMerkleInfo, uri } = await processOverrideList({
        chain: options.contract.chain,
        client: options.contract.client,
        overrides: phase.overrideList,
        tokenDecimals: options.tokenDecimals
      });
      merkleInfos[shardedMerkleInfo.merkleRoot] = uri;
      merkleRoot = shardedMerkleInfo.merkleRoot;
    }
    let metadata = "";
    if (phase.metadata && typeof phase.metadata === "string") {
      metadata = phase.metadata;
    } else if (phase.metadata && typeof phase.metadata === "object") {
      metadata = await upload({
        client: options.contract.client,
        files: [phase.metadata]
      });
    }
    return {
      currency: phase.currencyAddress || NATIVE_TOKEN_ADDRESS,
      maxClaimableSupply: phase.maxClaimableSupply ?? maxUint256,
      merkleRoot,
      metadata,
      pricePerToken: await convertErc20Amount({
        amount: ((_a = phase.price) == null ? void 0 : _a.toString()) ?? "0",
        chain: options.contract.chain,
        client: options.contract.client,
        erc20Address: phase.currencyAddress || NATIVE_TOKEN_ADDRESS
      }),
      quantityLimitPerWallet: phase.maxClaimablePerWallet ?? maxUint256,
      startTimestamp: dateToSeconds(phase.startTime ?? /* @__PURE__ */ new Date(0)),
      supplyClaimed: 0n
    };
  }));
  const encodedTransactions = [];
  if (Object.keys(merkleInfos).length > 0) {
    const [{ getContractMetadata }, { encodeSetContractURI }] = await Promise.all([
      import("./getContractMetadata-LVPY4ICI.js"),
      import("./setContractURI-U2SVU6RE.js")
    ]);
    const metadata = await getContractMetadata({
      contract: options.contract
    });
    for (const key of Object.keys(metadata.merkle || {})) {
      merkleInfos[key] = metadata.merkle[key];
    }
    const mergedMetadata = {
      ...metadata,
      merkle: merkleInfos
    };
    const uri = await upload({
      client: options.contract.client,
      files: [mergedMetadata]
    });
    const encodedSetContractURI = encodeSetContractURI({
      uri
    });
    encodedTransactions.push(encodedSetContractURI);
  }
  const sortedPhases = phases.sort((a, b) => Number(a.startTimestamp - b.startTimestamp));
  let encodedSetClaimConditions;
  if (options.tokenId !== void 0) {
    if (options.singlePhase) {
      const { encodeSetClaimConditions } = await import("./setClaimConditions-HCWZF23U.js");
      const phase = sortedPhases[0];
      if (!phase) {
        throw new Error("No phase provided");
      }
      encodedSetClaimConditions = encodeSetClaimConditions({
        phase,
        resetClaimEligibility: options.resetClaimEligibility || false,
        tokenId: options.tokenId
      });
    } else {
      const { encodeSetClaimConditions } = await import("./setClaimConditions-LYRP2LL2.js");
      encodedSetClaimConditions = encodeSetClaimConditions({
        phases: sortedPhases,
        resetClaimEligibility: options.resetClaimEligibility || false,
        tokenId: options.tokenId
      });
    }
  } else {
    if (options.singlePhase) {
      const { encodeSetClaimConditions } = await import("./setClaimConditions-CHPXDFFV.js");
      const phase = sortedPhases[0];
      if (!phase) {
        throw new Error("No phase provided");
      }
      encodedSetClaimConditions = encodeSetClaimConditions({
        phase,
        resetClaimEligibility: options.resetClaimEligibility || false
      });
    } else {
      const { encodeSetClaimConditions } = await import("./setClaimConditions-2YZQFUTS.js");
      encodedSetClaimConditions = encodeSetClaimConditions({
        phases: sortedPhases,
        resetClaimEligibility: options.resetClaimEligibility || false
      });
    }
  }
  encodedTransactions.push(encodedSetClaimConditions);
  return encodedTransactions;
}

// node_modules/thirdweb/dist/esm/extensions/erc721/drops/write/setClaimConditions.js
function setClaimConditions2(options) {
  return multicall({
    asyncParams: async () => {
      return {
        data: await getMulticallSetClaimConditionTransactions({
          contract: options.contract,
          phases: options.phases,
          resetClaimEligibility: options.resetClaimEligibility,
          singlePhase: options.singlePhaseDrop,
          tokenDecimals: 0
        })
      };
    },
    contract: options.contract
  });
}
function isSetClaimConditionsSupported3(availableSelectors) {
  return isMulticallSupported(availableSelectors) && // needed for setting contract metadata
  isContractURISupported(availableSelectors) && isSetContractURISupported(availableSelectors) && // needs to actually be able to set the claim Conditions
  (isSetClaimConditionsSupported(availableSelectors) || isSetClaimConditionsSupported2(availableSelectors));
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/DropERC721/write/updateBatchBaseURI.js
var FN_SELECTOR12 = "0xde903ddd";
var FN_INPUTS12 = [
  {
    name: "_index",
    type: "uint256"
  },
  {
    name: "_uri",
    type: "string"
  }
];
var FN_OUTPUTS12 = [];
function isUpdateBatchBaseURISupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR12, FN_INPUTS12, FN_OUTPUTS12]
  });
}
function updateBatchBaseURI(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR12, FN_INPUTS12, FN_OUTPUTS12],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.index, resolvedOptions.uri];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IBatchMintMetadata/read/getBaseURICount.js
var FN_SELECTOR13 = "0x63b45e2d";
var FN_INPUTS13 = [];
var FN_OUTPUTS13 = [
  {
    type: "uint256"
  }
];
function isGetBaseURICountSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR13, FN_INPUTS13, FN_OUTPUTS13]
  });
}
async function getBaseURICount(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR13, FN_INPUTS13, FN_OUTPUTS13],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IBatchMintMetadata/read/getBatchIdAtIndex.js
var FN_SELECTOR14 = "0x2419f51b";
var FN_INPUTS14 = [
  {
    name: "_index",
    type: "uint256"
  }
];
var FN_OUTPUTS14 = [
  {
    type: "uint256"
  }
];
function isGetBatchIdAtIndexSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR14, FN_INPUTS14, FN_OUTPUTS14]
  });
}
async function getBatchIdAtIndex(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR14, FN_INPUTS14, FN_OUTPUTS14],
    params: [options.index]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/drops/write/updateMetadata.js
async function getUpdateMetadataParams(options) {
  const { contract, targetTokenId, newMetadata } = options;
  const batchCount = await getBaseURICount(options);
  if (batchCount === 0n) {
    throw new Error("No base URI set. Please set a base URI before updating metadata");
  }
  let startTokenId2 = 0n;
  let endTokenId = 0n;
  let batchIndex = 0n;
  for (let i = 0n; i < batchCount; i += 1n) {
    batchIndex = i;
    endTokenId = await getBatchIdAtIndex({
      contract,
      index: batchIndex
    });
    if (endTokenId > targetTokenId) {
      break;
    }
    startTokenId2 = endTokenId;
  }
  const range = Array.from({ length: Number(endTokenId - startTokenId2) }, (_, k) => BigInt(k) + startTokenId2);
  const BATCH_SIZE = 50;
  const currentMetadatas = [];
  for (let i = 0; i < range.length; i += BATCH_SIZE) {
    const chunk = range.slice(i, i + BATCH_SIZE);
    const chunkResults = await Promise.all(chunk.map((id) => getNFT({
      contract,
      includeOwner: false,
      tokenId: id,
      useIndexer: false
    })));
    currentMetadatas.push(...chunkResults);
    if (i + BATCH_SIZE < range.length) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    if (currentMetadatas.some((item) => item === void 0 || !item.tokenURI)) {
      throw new Error(`Failed to load all ${range.length} items from batchIndex: ${batchIndex}`);
    }
  }
  const newMetadatas = [];
  for (let i = 0; i < currentMetadatas.length; i++) {
    const { id, metadata } = currentMetadatas[i];
    if (targetTokenId === id) {
      newMetadatas.push(newMetadata);
    } else {
      newMetadatas.push(metadata);
    }
  }
  const { uploadOrExtractURIs: uploadOrExtractURIs2 } = await import("./ipfs-TDH3X3HX.js");
  const batchOfUris = await uploadOrExtractURIs2(newMetadatas, contract.client, Number(startTokenId2));
  if (!batchOfUris || !batchOfUris.length || !batchOfUris[0]) {
    throw new Error("Failed to upload batch of new metadatas");
  }
  const baseUri = batchOfUris[0].substring(0, batchOfUris[0].lastIndexOf("/"));
  const uri = `${baseUri}/`;
  return { index: batchIndex, uri };
}
function updateMetadata(options) {
  const { contract } = options;
  return updateBatchBaseURI({
    asyncParams: async () => getUpdateMetadataParams(options),
    contract
  });
}
function isUpdateMetadataSupported(availableSelectors) {
  return isGetBaseURICountSupported(availableSelectors) && isUpdateBatchBaseURISupported(availableSelectors) && isGetBatchIdAtIndexSupported(availableSelectors) && isTokenURISupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDelayedReveal/read/encryptedData.js
var FN_SELECTOR15 = "0xa05112fc";
var FN_INPUTS15 = [
  {
    name: "index",
    type: "uint256"
  }
];
var FN_OUTPUTS15 = [
  {
    type: "bytes"
  }
];
function isEncryptedDataSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR15, FN_INPUTS15, FN_OUTPUTS15]
  });
}
async function encryptedData(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR15, FN_INPUTS15, FN_OUTPUTS15],
    params: [options.index]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDrop/read/baseURIIndices.js
var FN_SELECTOR16 = "0xd860483f";
var FN_INPUTS16 = [
  {
    name: "index",
    type: "uint256"
  }
];
var FN_OUTPUTS16 = [
  {
    type: "uint256"
  }
];
function isBaseURIIndicesSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR16, FN_INPUTS16, FN_OUTPUTS16]
  });
}
async function baseURIIndices(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR16, FN_INPUTS16, FN_OUTPUTS16],
    params: [options.index]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/lazyMinting/read/getBatchesToReveal.js
async function getBatchesToReveal(options) {
  const count = await getBaseURICount({
    contract: options.contract
  });
  if (count === 0n) {
    return [];
  }
  const countRangeArray = Array.from(Array(Number(count)).keys());
  const uriIndices = await Promise.all(countRangeArray.map(async (batchId) => {
    const promiseAll = await Promise.allSettled([
      getBatchIdAtIndex({
        contract: options.contract,
        index: BigInt(batchId)
      }),
      baseURIIndices({
        contract: options.contract,
        index: BigInt(batchId)
      })
    ]);
    const result = promiseAll.find((result2) => result2.status === "fulfilled");
    if (!result) {
      throw new Error("Contract does not have `getBatchIdAtIndex` or `baseURIIndices`, which are required for `getBatchesToReveal`");
    }
    return result.value;
  }));
  const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
  const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(async (i) => {
    const uri = await tokenURI({
      contract: options.contract,
      tokenId: BigInt(i)
    });
    return await fetchTokenMetadata({
      client: options.contract.client,
      tokenId: BigInt(i),
      tokenUri: uri
    }).catch(() => void 0);
  }));
  const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map((i) => encryptedData({
    contract: options.contract,
    index: BigInt(i)
  })));
  const encryptedBaseUris = encryptedUriData.map((data) => {
    const hexDataLength = (data.length - 2) / 2;
    if (hexDataLength > 0) {
      return decodeAbiParameters([
        { name: "baseUri", type: "bytes" },
        { name: "provenanceHash", type: "bytes32" }
      ], data)[0];
    }
    return data;
  });
  return tokenMetadatas.map((metadata, i) => ({
    batchId: BigInt(i),
    batchUri: encryptedBaseUris[i],
    placeholderMetadata: metadata
  })).filter((_, index) => {
    var _a;
    return (((_a = encryptedBaseUris[index]) == null ? void 0 : _a.length) || 0) > 0;
  });
}
function isGetBatchesToRevealSupported(availableSelectors) {
  return [
    isGetBaseURICountSupported(availableSelectors),
    isGetBatchIdAtIndexSupported(availableSelectors),
    isEncryptedDataSupported(availableSelectors),
    isBaseURIIndicesSupported(availableSelectors),
    isTokenURISupported(availableSelectors)
  ].every(Boolean);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDelayedReveal/read/encryptDecrypt.js
var FN_SELECTOR17 = "0xe7150322";
var FN_INPUTS17 = [
  {
    name: "data",
    type: "bytes"
  },
  {
    name: "key",
    type: "bytes"
  }
];
var FN_OUTPUTS17 = [
  {
    name: "result",
    type: "bytes"
  }
];
function isEncryptDecryptSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR17, FN_INPUTS17, FN_OUTPUTS17]
  });
}
async function encryptDecrypt(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR17, FN_INPUTS17, FN_OUTPUTS17],
    params: [options.data, options.key]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ILazyMint/write/lazyMint.js
var FN_SELECTOR18 = "0xd37c353b";
var FN_INPUTS18 = [
  {
    name: "amount",
    type: "uint256"
  },
  {
    name: "baseURIForTokens",
    type: "string"
  },
  {
    name: "extraData",
    type: "bytes"
  }
];
var FN_OUTPUTS18 = [
  {
    name: "batchId",
    type: "uint256"
  }
];
function isLazyMintSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR18, FN_INPUTS18, FN_OUTPUTS18]
  });
}
function lazyMint(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR18, FN_INPUTS18, FN_OUTPUTS18],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [
        resolvedOptions.amount,
        resolvedOptions.baseURIForTokens,
        resolvedOptions.extraData
      ];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/lazyMinting/helpers/hashDelayedRevealBatch.js
var hashDelayedRevealPassword = async (batchTokenIndex, password, contract) => {
  const chainId = BigInt(contract.chain.id);
  const contractAddress = contract.address;
  return keccak256(encodePacked(["string", "uint256", "uint256", "address"], [password, chainId, batchTokenIndex, getAddress(contractAddress)]));
};

// node_modules/thirdweb/dist/esm/extensions/erc721/lazyMinting/write/createDelayedRevealBatch.js
function createDelayedRevealBatch(options) {
  if (!options.password) {
    throw new Error("Password is required");
  }
  return lazyMint({
    asyncParams: async () => {
      const [placeholderUris, startFileNumber] = await Promise.all([
        upload({
          client: options.contract.client,
          files: Array(options.metadata.length).fill(options.placeholderMetadata)
        }),
        nextTokenIdToMint({
          contract: options.contract
        })
      ]);
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const uris = await upload({
        client: options.contract.client,
        files: options.metadata,
        // IMPORTANT: File number has to be calculated properly otherwise the whole batch will break
        // e.g: If you are uploading a second batch, the file name should never start from `0`
        rewriteFileNames: {
          fileStartNumber: Number(startFileNumber)
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await getBaseURICount({
        contract: options.contract
      });
      const hashedPassword = await hashDelayedRevealPassword(baseUriId, options.password, options.contract);
      const encryptedBaseURI = await encryptDecrypt({
        contract: options.contract,
        data: toHex(baseUri),
        key: hashedPassword
      });
      const chainId = BigInt(options.contract.chain.id);
      const provenanceHash = keccak256(encodePacked(["bytes", "bytes", "uint256"], [toHex(baseUri), hashedPassword, chainId]));
      const data = encodeAbiParameters([
        { name: "baseUri", type: "bytes" },
        { name: "provenanceHash", type: "bytes32" }
      ], [encryptedBaseURI, provenanceHash]);
      return {
        amount: BigInt(options.metadata.length),
        baseURIForTokens: placeholderUri.slice(-1) === "/" ? placeholderUri : `${placeholderUri}/`,
        extraData: data
      };
    },
    contract: options.contract
  });
}
function isCreateDelayedRevealBatchSupported(availableSelectors) {
  return [
    isGetBaseURICountSupported(availableSelectors),
    isEncryptDecryptSupported(availableSelectors),
    isLazyMintSupported(availableSelectors)
  ].every(Boolean);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDelayedReveal/write/reveal.js
var FN_SELECTOR19 = "0xce805642";
var FN_INPUTS19 = [
  {
    name: "identifier",
    type: "uint256"
  },
  {
    name: "key",
    type: "bytes"
  }
];
var FN_OUTPUTS19 = [
  {
    name: "revealedURI",
    type: "string"
  }
];
function isRevealSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR19, FN_INPUTS19, FN_OUTPUTS19]
  });
}
function reveal(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR19, FN_INPUTS19, FN_OUTPUTS19],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.identifier, resolvedOptions.key];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/lazyMinting/write/reveal.js
function reveal2(options) {
  if (!options.password) {
    throw new Error("Password is required");
  }
  return reveal({
    asyncParams: async () => {
      const key = await hashDelayedRevealPassword(options.batchId, options.password, options.contract);
      return {
        identifier: options.batchId,
        key
      };
    },
    contract: options.contract
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/getAllOwners.js
var DEFAULT_QUERY_ALL_COUNT = 100n;
async function getAllOwners(options) {
  const [startTokenId_, maxSupply] = await Promise.allSettled([
    startTokenId(options),
    nextTokenIdToMint(options),
    totalSupply(options)
  ]).then(([_startTokenId, _next, _total]) => {
    const startTokenId__ = _startTokenId.status === "fulfilled" ? _startTokenId.value : 0n;
    let maxSupply_;
    if (_next.status === "fulfilled") {
      maxSupply_ = _next.value - startTokenId__;
    } else if (_total.status === "fulfilled") {
      maxSupply_ = _total.value;
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
    return [startTokenId__, maxSupply_];
  });
  const start = BigInt(options.start ?? 0) + startTokenId_;
  const count = BigInt(options.count ?? DEFAULT_QUERY_ALL_COUNT);
  const maxId = min(maxSupply + startTokenId_, start + count);
  const promises = [];
  for (let i = start; i < maxId; i++) {
    promises.push(ownerOf({ contract: options.contract, tokenId: i }).catch(() => ZERO_ADDRESS).then((owner) => ({
      owner,
      tokenId: i
    })));
  }
  return await Promise.all(promises);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/getNFTs.js
var DEFAULT_QUERY_ALL_COUNT2 = 100n;
async function getNFTs(options) {
  const { useIndexer = true } = options;
  if (useIndexer) {
    try {
      return await getNFTsFromInsight(options);
    } catch {
      return await getNFTsFromRPC(options);
    }
  }
  return await getNFTsFromRPC(options);
}
function isGetNFTsSupported(availableSelectors) {
  return isTokenURISupported(availableSelectors) && (isTotalSupplySupported(availableSelectors) || isNextTokenIdToMintSupported(availableSelectors));
}
async function getNFTsFromInsight(options) {
  const { contract, start, count = Number(DEFAULT_QUERY_ALL_COUNT2) } = options;
  const [result, supplyInfo] = await Promise.all([
    getContractNFTs({
      chains: [contract.chain],
      client: contract.client,
      contractAddress: contract.address,
      includeOwners: options.includeOwners ?? false,
      queryOptions: {
        limit: count,
        page: start ? Math.floor(start / count) : void 0
      }
    }),
    getSupplyInfo(options).catch(() => ({
      maxSupply: 0,
      startTokenId: 0
    }))
  ]);
  const currentOffset = start ?? 0;
  const expectedResultLength = Math.min(count, Math.max(0, Number(supplyInfo.maxSupply) - Number(supplyInfo.startTokenId) - currentOffset));
  if (result.length < expectedResultLength) {
    try {
      return await getNFTsFromRPC(options);
    } catch {
      return result;
    }
  }
  return result;
}
async function getNFTsFromRPC(options) {
  const { startTokenId: startTokenId2, maxSupply } = await getSupplyInfo(options);
  const start = BigInt(options.start ?? 0) + startTokenId2;
  const count = BigInt(options.count ?? DEFAULT_QUERY_ALL_COUNT2);
  const maxId = min(maxSupply, start + count);
  const promises = [];
  for (let i = start; i < maxId; i++) {
    promises.push(getNFT({
      ...options,
      includeOwner: options.includeOwners ?? false,
      tokenId: i,
      useIndexer: false
    }));
  }
  return await Promise.all(promises);
}
async function getSupplyInfo(options) {
  const [startTokenId_, maxSupply] = await Promise.allSettled([
    startTokenId(options),
    nextTokenIdToMint(options),
    totalSupply(options)
  ]).then(([_startTokenId, _next, _total]) => {
    const startTokenId__ = _startTokenId.status === "fulfilled" ? _startTokenId.value : 0n;
    let maxSupply_;
    if (_next.status === "fulfilled") {
      maxSupply_ = _next.value - startTokenId__;
    } else if (_total.status === "fulfilled") {
      maxSupply_ = _total.value;
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
    return [startTokenId__, maxSupply_];
  });
  return {
    maxSupply,
    startTokenId: startTokenId_
  };
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IDrop/read/nextTokenIdToClaim.js
var FN_SELECTOR20 = "0xacd083f8";
var FN_INPUTS20 = [];
var FN_OUTPUTS20 = [
  {
    type: "uint256"
  }
];
async function nextTokenIdToClaim(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR20, FN_INPUTS20, FN_OUTPUTS20],
    params: []
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/getTotalClaimedSupply.js
async function getTotalClaimedSupply(options) {
  const [startTokenId_, nextTokenIdToClaim_] = await Promise.all([
    startTokenId(options).catch(() => 0n),
    nextTokenIdToClaim(options)
  ]);
  return nextTokenIdToClaim_ - startTokenId_;
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/getTotalUnclaimedSupply.js
async function getTotalUnclaimedSupply(options) {
  const [startTokenId_, nextTokenIdToMint_, totalClaimedSupply_] = await Promise.all([
    startTokenId(options).catch(() => 0n),
    nextTokenIdToMint(options),
    getTotalClaimedSupply(options)
  ]);
  return nextTokenIdToMint_ - startTokenId_ - totalClaimedSupply_;
}

// node_modules/thirdweb/dist/esm/extensions/erc721/write/lazyMint.js
function lazyMint2(options) {
  return lazyMint({
    asyncParams: async () => {
      const startFileNumber = await nextTokenIdToMint({
        contract: options.contract
      });
      const batchOfUris = await uploadOrExtractURIs(
        options.nfts,
        options.contract.client,
        // TODO: this is potentially unsafe since it *may* be bigger than what Number can represent, however the likelyhood is very low (fine, for now)
        Number(startFileNumber)
      );
      const baseUri = getBaseUriFromBatch(batchOfUris);
      return {
        amount: BigInt(batchOfUris.length),
        baseURIForTokens: baseUri.endsWith("/") ? baseUri : `${baseUri}/`,
        extraData: "0x"
      };
    },
    contract: options.contract
  });
}
function isLazyMintSupported2(availableSelectors) {
  return isLazyMintSupported(availableSelectors) && // required because we use it in the lazyMint function
  isNextTokenIdToMintSupported(availableSelectors);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IMintableERC721/write/mintTo.js
var FN_SELECTOR21 = "0x0075a317";
var FN_INPUTS21 = [
  {
    name: "to",
    type: "address"
  },
  {
    name: "uri",
    type: "string"
  }
];
var FN_OUTPUTS21 = [
  {
    type: "uint256"
  }
];
function isMintToSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR21, FN_INPUTS21, FN_OUTPUTS21]
  });
}
function mintTo(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR21, FN_INPUTS21, FN_OUTPUTS21],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.to, resolvedOptions.uri];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/write/mintTo.js
function mintTo2(options) {
  return mintTo({
    asyncParams: async () => {
      let tokenUri;
      if (typeof options.nft === "string") {
        tokenUri = options.nft;
      } else {
        const { upload: upload2 } = await import("./upload-L7WUMND4.js");
        tokenUri = await upload2({
          client: options.contract.client,
          files: [options.nft]
        });
      }
      return {
        overrides: options.overrides,
        to: options.to,
        uri: tokenUri
      };
    },
    contract: options.contract
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ISharedMetadata/write/setSharedMetadata.js
var FN_SELECTOR22 = "0xa7d27d9d";
var FN_INPUTS22 = [
  {
    components: [
      {
        name: "name",
        type: "string"
      },
      {
        name: "description",
        type: "string"
      },
      {
        name: "imageURI",
        type: "string"
      },
      {
        name: "animationURI",
        type: "string"
      }
    ],
    name: "_metadata",
    type: "tuple"
  }
];
var FN_OUTPUTS22 = [];
function isSetSharedMetadataSupported(availableSelectors) {
  return detectMethod({
    availableSelectors,
    method: [FN_SELECTOR22, FN_INPUTS22, FN_OUTPUTS22]
  });
}
function setSharedMetadata(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR22, FN_INPUTS22, FN_OUTPUTS22],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.metadata];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/write/setSharedMetadata.js
function setSharedMetadata2(options) {
  return setSharedMetadata({
    asyncParams: async () => {
      if (!options.nft.name) {
        throw new Error("NFT name is required");
      }
      const batch = [
        // image URI resolution
        (async () => {
          if (!options.nft.image) {
            return "";
          }
          if (typeof options.nft.image === "string") {
            return options.nft.image;
          }
          const { upload: upload2 } = await import("./upload-L7WUMND4.js");
          return await upload2({
            client: options.contract.client,
            files: [options.nft.image]
          });
        })(),
        // animation URI resolution
        (async () => {
          if (!options.nft.animation_url) {
            return "";
          }
          if (typeof options.nft.animation_url === "string") {
            return options.nft.animation_url;
          }
          const { upload: upload2 } = await import("./upload-L7WUMND4.js");
          return await upload2({
            client: options.contract.client,
            files: [options.nft.animation_url]
          });
        })()
      ];
      const [imageURI, animationURI] = await Promise.all(batch);
      return {
        metadata: {
          animationURI: animationURI ?? "",
          description: sanitizeJSONString(options.nft.description) ?? "",
          imageURI: imageURI ?? "",
          name: options.nft.name
        }
      };
    },
    contract: options.contract
  });
}
function sanitizeJSONString(val) {
  if (!val) {
    return val;
  }
  const sanitized = JSON.stringify(val);
  return sanitized.slice(1, sanitized.length - 1);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ISignatureMintERC721/write/mintWithSignature.js
var FN_SELECTOR23 = "0x2c4510f8";
var FN_INPUTS23 = [
  {
    components: [
      {
        name: "to",
        type: "address"
      },
      {
        name: "royaltyRecipient",
        type: "address"
      },
      {
        name: "royaltyBps",
        type: "uint256"
      },
      {
        name: "primarySaleRecipient",
        type: "address"
      },
      {
        name: "uri",
        type: "string"
      },
      {
        name: "price",
        type: "uint256"
      },
      {
        name: "currency",
        type: "address"
      },
      {
        name: "validityStartTimestamp",
        type: "uint128"
      },
      {
        name: "validityEndTimestamp",
        type: "uint128"
      },
      {
        name: "uid",
        type: "bytes32"
      }
    ],
    name: "payload",
    type: "tuple"
  },
  {
    name: "signature",
    type: "bytes"
  }
];
var FN_OUTPUTS23 = [
  {
    name: "tokenIdMinted",
    type: "uint256"
  }
];
function mintWithSignature(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR23, FN_INPUTS23, FN_OUTPUTS23],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.payload, resolvedOptions.signature];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/ISignatureMintERC721_v2/write/mintWithSignature.js
var FN_SELECTOR24 = "0x439c7be5";
var FN_INPUTS24 = [
  {
    components: [
      {
        name: "to",
        type: "address"
      },
      {
        name: "royaltyRecipient",
        type: "address"
      },
      {
        name: "royaltyBps",
        type: "uint256"
      },
      {
        name: "primarySaleRecipient",
        type: "address"
      },
      {
        name: "uri",
        type: "string"
      },
      {
        name: "quantity",
        type: "uint256"
      },
      {
        name: "pricePerToken",
        type: "uint256"
      },
      {
        name: "currency",
        type: "address"
      },
      {
        name: "validityStartTimestamp",
        type: "uint128"
      },
      {
        name: "validityEndTimestamp",
        type: "uint128"
      },
      {
        name: "uid",
        type: "bytes32"
      }
    ],
    name: "payload",
    type: "tuple"
  },
  {
    name: "signature",
    type: "bytes"
  }
];
var FN_OUTPUTS24 = [
  {
    name: "signer",
    type: "address"
  }
];
function mintWithSignature2(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    authorizationList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.authorizationList;
    },
    contract: options.contract,
    erc20Value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.erc20Value;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    method: [FN_SELECTOR24, FN_INPUTS24, FN_OUTPUTS24],
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.payload, resolvedOptions.signature];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    }
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/write/sigMint.js
function mintWithSignature3(options) {
  const { payload } = options;
  if ("quantity" in payload) {
    return mintWithSignatureV2(options);
  }
  return mintWithSignatureV1(options);
}
function mintWithSignatureV1(options) {
  const value = isNativeTokenAddress(options.payload.currency) ? options.payload.price : 0n;
  return mintWithSignature({
    ...options,
    overrides: {
      value
    }
  });
}
function mintWithSignatureV2(options) {
  const value = isNativeTokenAddress(options.payload.currency) ? options.payload.pricePerToken * options.payload.quantity : 0n;
  return mintWithSignature2({
    ...options,
    overrides: {
      value
    }
  });
}
async function generateMintSignature(options) {
  var _a, _b;
  const { mintRequest, account, contract, contractType } = options;
  const currency = mintRequest.currency || NATIVE_TOKEN_ADDRESS;
  const [price, uri, uid] = await Promise.all([
    // price per token in wei
    (async () => {
      if ("priceInWei" in mintRequest && mintRequest.priceInWei) {
        return mintRequest.priceInWei;
      }
      if ("price" in mintRequest && mintRequest.price) {
        const { convertErc20Amount: convertErc20Amount2 } = await import("./convert-erc20-amount-B44PPDCI.js");
        return await convertErc20Amount2({
          amount: mintRequest.price,
          chain: contract.chain,
          client: contract.client,
          erc20Address: currency
        });
      }
      return 0n;
    })(),
    // uri
    (async () => {
      if ("metadata" in mintRequest) {
        if (typeof mintRequest.metadata === "object") {
          const { upload: upload2 } = await import("./upload-L7WUMND4.js");
          return await upload2({
            client: options.contract.client,
            files: [mintRequest.metadata]
          });
        }
        return mintRequest.metadata;
      }
      return "";
    })(),
    // uid computation
    (() => {
      if (mintRequest.uid) {
        return isHex(mintRequest.uid) ? mintRequest.uid : stringToHex(mintRequest.uid, { size: 32 });
      }
      return randomBytesHex();
    })()
  ]);
  const startTime = mintRequest.validityStartTimestamp || /* @__PURE__ */ new Date(0);
  const endTime = mintRequest.validityEndTimestamp || tenYearsFromNow();
  let saleRecipient;
  if (((_a = mintRequest.primarySaleRecipient) == null ? void 0 : _a.length) === 0 || !mintRequest.primarySaleRecipient) {
    const { primarySaleRecipient } = await import("./primarySaleRecipient-44KKUETM.js");
    saleRecipient = await primarySaleRecipient({
      contract
    });
  } else {
    saleRecipient = mintRequest.primarySaleRecipient;
  }
  let royaltyRecipient;
  if (((_b = mintRequest.royaltyRecipient) == null ? void 0 : _b.length) === 0 || !mintRequest.royaltyRecipient) {
    const { getDefaultRoyaltyInfo } = await import("./getDefaultRoyaltyInfo-KOJTS3OZ.js");
    const royaltyInfo = await getDefaultRoyaltyInfo({
      contract
    });
    royaltyRecipient = royaltyInfo[0];
  } else {
    royaltyRecipient = mintRequest.royaltyRecipient;
  }
  if (contractType === "LoyaltyCard") {
    return signPayloadV2({
      account,
      contract,
      currency,
      endTime,
      mintRequest,
      price,
      primarySaleRecipient: saleRecipient,
      royaltyRecipient,
      startTime,
      uid,
      uri
    });
  }
  return signPayloadV1({
    account,
    contract,
    currency,
    endTime,
    mintRequest,
    price,
    primarySaleRecipient: saleRecipient,
    royaltyRecipient,
    startTime,
    uid,
    uri
  });
}
async function signPayloadV1({ mintRequest, account, contract, uri, currency, uid, price, royaltyRecipient, primarySaleRecipient, startTime, endTime }) {
  const payload = {
    currency,
    price,
    primarySaleRecipient,
    royaltyBps: toBigInt(mintRequest.royaltyBps || 0),
    royaltyRecipient,
    to: mintRequest.to,
    uid,
    uri,
    validityEndTimestamp: dateToSeconds(endTime),
    validityStartTimestamp: dateToSeconds(startTime)
  };
  const signature = await account.signTypedData({
    domain: {
      chainId: contract.chain.id,
      name: "TokenERC721",
      verifyingContract: contract.address,
      version: "1"
    },
    message: payload,
    primaryType: "MintRequest",
    types: {
      MintRequest: MintRequest721
    }
  });
  return { payload, signature };
}
async function signPayloadV2({ mintRequest, account, contract, uri, currency, uid, price, royaltyRecipient, primarySaleRecipient, startTime, endTime }) {
  const payload = {
    currency,
    pricePerToken: price,
    primarySaleRecipient,
    quantity: toBigInt(1),
    // always 1 for 721 NFTs
    royaltyBps: toBigInt(mintRequest.royaltyBps || 0),
    royaltyRecipient,
    to: mintRequest.to,
    uid,
    uri,
    validityEndTimestamp: dateToSeconds(endTime),
    validityStartTimestamp: dateToSeconds(startTime)
  };
  const signature = await account.signTypedData({
    domain: {
      chainId: contract.chain.id,
      name: "SignatureMintERC721",
      verifyingContract: contract.address,
      version: "1"
    },
    message: payload,
    primaryType: "MintRequest",
    types: {
      MintRequest: MintRequest721_V2
    }
  });
  return { payload, signature };
}
var MintRequest721 = [
  { name: "to", type: "address" },
  { name: "royaltyRecipient", type: "address" },
  { name: "royaltyBps", type: "uint256" },
  { name: "primarySaleRecipient", type: "address" },
  { name: "uri", type: "string" },
  { name: "price", type: "uint256" },
  { name: "currency", type: "address" },
  { name: "validityStartTimestamp", type: "uint128" },
  { name: "validityEndTimestamp", type: "uint128" },
  { name: "uid", type: "bytes32" }
];
var MintRequest721_V2 = [
  { name: "to", type: "address" },
  { name: "royaltyRecipient", type: "address" },
  { name: "royaltyBps", type: "uint256" },
  { name: "primarySaleRecipient", type: "address" },
  { name: "uri", type: "string" },
  { name: "quantity", type: "uint256" },
  { name: "pricePerToken", type: "uint256" },
  { name: "currency", type: "address" },
  { name: "validityStartTimestamp", type: "uint128" },
  { name: "validityEndTimestamp", type: "uint128" },
  { name: "uid", type: "bytes32" }
];

// node_modules/thirdweb/dist/esm/extensions/erc721/write/updateTokenURI.js
function updateTokenURI(options) {
  const { contract } = options;
  return setTokenURI({
    asyncParams: async () => getUpdateTokenParams(options),
    contract
  });
}
async function getUpdateTokenParams(options) {
  const { tokenId, newMetadata } = options;
  const batch = [
    // image URI resolution
    (async () => {
      if (!newMetadata.image) {
        return "";
      }
      if (typeof newMetadata.image === "string") {
        return newMetadata.image;
      }
      return await upload({
        client: options.contract.client,
        files: [newMetadata.image]
      });
    })(),
    // animation URI resolution
    (async () => {
      if (!newMetadata.animation_url) {
        return "";
      }
      if (typeof newMetadata.animation_url === "string") {
        return newMetadata.animation_url;
      }
      return await upload({
        client: options.contract.client,
        files: [newMetadata.animation_url]
      });
    })()
  ];
  const [imageURI, animationURI] = await Promise.all(batch);
  if (newMetadata.image && imageURI) {
    newMetadata.image = imageURI;
  }
  if (newMetadata.animation_url && animationURI) {
    newMetadata.animation_url = animationURI;
  }
  const uri = await upload({
    client: options.contract.client,
    files: [newMetadata]
  });
  return { tokenId, uri };
}
export {
  approvalEvent,
  approvalForAllEvent,
  approve,
  balanceOf,
  burn,
  canClaim,
  claimConditionsUpdatedEvent,
  claimTo,
  claimToBatch,
  createDelayedRevealBatch,
  generateMintSignature,
  getActiveClaimCondition,
  getActiveClaimConditionId,
  getAllOwners,
  getApproved,
  getBatchesToReveal,
  getClaimConditionById,
  getClaimConditions,
  getNFT,
  getNFTs,
  getOwnedNFTs,
  getOwnedTokenIds,
  getTotalClaimedSupply,
  getTotalUnclaimedSupply,
  isApprovedForAll,
  isBurnSupported,
  isClaimToSupported,
  isCreateDelayedRevealBatchSupported,
  isERC721,
  isGetActiveClaimConditionIdSupported,
  isGetActiveClaimConditionSupported,
  isGetApprovedSupported,
  isGetBatchesToRevealSupported,
  isGetClaimConditionByIdSupported,
  isGetClaimConditionsSupported,
  isTokenURISupported as isGetNFTSupported,
  isGetNFTsSupported,
  isLazyMintSupported2 as isLazyMintSupported,
  isMintToSupported,
  isNextTokenIdToMintSupported,
  isResetClaimEligibilitySupported,
  isRevealSupported,
  isSetClaimConditionsSupported3 as isSetClaimConditionsSupported,
  isSetSharedMetadataSupported,
  isSharedMetadataSupported,
  isTokenByIndexSupported,
  isTotalSupplySupported,
  isUpdateMetadataSupported,
  isSetTokenURISupported as isUpdateTokenURISupported,
  lazyMint2 as lazyMint,
  mintTo2 as mintTo,
  mintWithSignature3 as mintWithSignature,
  nextTokenIdToMint,
  ownerOf,
  resetClaimEligibility,
  reveal2 as reveal,
  setApprovalForAll,
  setClaimConditions2 as setClaimConditions,
  setSharedMetadata2 as setSharedMetadata,
  setTokenURI,
  sharedMetadata,
  sharedMetadataUpdatedEvent,
  startTokenId,
  tokenOfOwnerByIndex,
  tokenURI,
  tokenURIRevealedEvent,
  tokensClaimedEvent,
  tokensLazyMintedEvent,
  tokensMintedWithSignatureEvent,
  tokensOfOwner,
  totalSupply,
  transferEvent,
  transferFrom,
  updateMetadata,
  updateTokenURI
};
//# sourceMappingURL=thirdweb_extensions_erc721.js.map
