{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc721/__generated__/IBurnableERC721/write/burn.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDelayedReveal/events/TokenURIRevealed.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/events/ClaimConditionsUpdated.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/events/TokensClaimed.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/events/Approval.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/events/ApprovalForAll.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/events/Transfer.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/read/startTokenId.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/read/totalSupply.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/write/approve.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721A/write/transferFrom.ts", "../../thirdweb/src/extensions/erc721/__generated__/IERC721Enumerable/read/nextTokenIdToMint.ts", "../../thirdweb/src/extensions/erc721/__generated__/ILazyMint/events/TokensLazyMinted.ts", "../../thirdweb/src/extensions/erc721/__generated__/INFTMetadata/write/setTokenURI.ts", "../../thirdweb/src/extensions/erc721/__generated__/ISharedMetadata/events/SharedMetadataUpdated.ts", "../../thirdweb/src/extensions/erc721/__generated__/ISharedMetadata/read/sharedMetadata.ts", "../../thirdweb/src/extensions/erc721/__generated__/ISignatureMintERC721/events/TokensMintedWithSignature.ts", "../../thirdweb/src/extensions/erc721/__generated__/DropERC721/read/verifyClaim.ts", "../../thirdweb/src/extensions/erc721/drops/read/canClaim.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/read/claimCondition.ts", "../../thirdweb/src/extensions/erc721/drops/read/getClaimConditions.ts", "../../thirdweb/src/extensions/common/__generated__/IMulticall/write/multicall.ts", "../../thirdweb/src/extensions/erc721/drops/write/claimToBatch.ts", "../../thirdweb/src/extensions/erc721/drops/write/resetClaimEligibility.ts", "../../thirdweb/src/utils/extensions/drops/process-override-list.ts", "../../thirdweb/src/utils/extensions/drops/get-multicall-set-claim-claim-conditon-transactions.ts", "../../thirdweb/src/extensions/erc721/drops/write/setClaimConditions.ts", "../../thirdweb/src/extensions/erc721/__generated__/DropERC721/write/updateBatchBaseURI.ts", "../../thirdweb/src/extensions/erc721/__generated__/IBatchMintMetadata/read/getBaseURICount.ts", "../../thirdweb/src/extensions/erc721/__generated__/IBatchMintMetadata/read/getBatchIdAtIndex.ts", "../../thirdweb/src/extensions/erc721/drops/write/updateMetadata.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDelayedReveal/read/encryptedData.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/read/baseURIIndices.ts", "../../thirdweb/src/extensions/erc721/lazyMinting/read/getBatchesToReveal.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDelayedReveal/read/encryptDecrypt.ts", "../../thirdweb/src/extensions/erc721/__generated__/ILazyMint/write/lazyMint.ts", "../../thirdweb/src/extensions/erc721/lazyMinting/helpers/hashDelayedRevealBatch.ts", "../../thirdweb/src/extensions/erc721/lazyMinting/write/createDelayedRevealBatch.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDelayedReveal/write/reveal.ts", "../../thirdweb/src/extensions/erc721/lazyMinting/write/reveal.ts", "../../thirdweb/src/extensions/erc721/read/getAllOwners.ts", "../../thirdweb/src/extensions/erc721/read/getNFTs.ts", "../../thirdweb/src/extensions/erc721/__generated__/IDrop/read/nextTokenIdToClaim.ts", "../../thirdweb/src/extensions/erc721/read/getTotalClaimedSupply.ts", "../../thirdweb/src/extensions/erc721/read/getTotalUnclaimedSupply.ts", "../../thirdweb/src/extensions/erc721/write/lazyMint.ts", "../../thirdweb/src/extensions/erc721/__generated__/IMintableERC721/write/mintTo.ts", "../../thirdweb/src/extensions/erc721/write/mintTo.ts", "../../thirdweb/src/extensions/erc721/__generated__/ISharedMetadata/write/setSharedMetadata.ts", "../../thirdweb/src/extensions/erc721/write/setSharedMetadata.ts", "../../thirdweb/src/extensions/erc721/__generated__/ISignatureMintERC721/write/mintWithSignature.ts", "../../thirdweb/src/extensions/erc721/__generated__/ISignatureMintERC721_v2/write/mintWithSignature.ts", "../../thirdweb/src/extensions/erc721/write/sigMint.ts", "../../thirdweb/src/extensions/erc721/write/updateTokenURI.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"burn\" function.\n */\nexport type BurnParams = WithOverrides<{\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"tokenId\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x42966c68\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"tokenId\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `burn` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `burn` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isBurnSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isBurnSupported([\"0x...\"]);\n * ```\n */\nexport function isBurnSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"burn\" function.\n * @param options - The options for the burn function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeBurnParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeBurnParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeBurnParams(options: BurnParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"burn\" function into a Hex string with its parameters.\n * @param options - The options for the burn function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeBurn } from \"thirdweb/extensions/erc721\";\n * const result = encodeBurn({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeBurn(options: BurnParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeBurnParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"burn\" function on the contract.\n * @param options - The options for the \"burn\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { burn } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = burn({\n *  contract,\n *  tokenId: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function burn(\n  options: BaseTransactionOptions<\n    | BurnParams\n    | {\n        asyncParams: () => Promise<BurnParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.tokenId] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"TokenURIRevealed\" event.\n */\nexport type TokenURIRevealedEventFilters = Partial<{\n  index: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"index\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the TokenURIRevealed event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { tokenURIRevealedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  tokenURIRevealedEvent({\n *  index: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function tokenURIRevealedEvent(\n  filters: TokenURIRevealedEventFilters = {},\n) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event TokenURIRevealed(uint256 indexed index, string revealedURI)\",\n  });\n}\n", "import { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Creates an event object for the ClaimConditionsUpdated event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { claimConditionsUpdatedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  claimConditionsUpdatedEvent()\n * ],\n * });\n * ```\n */\nexport function claimConditionsUpdatedEvent() {\n  return prepareEvent({\n    signature:\n      \"event ClaimConditionsUpdated((uint256 startTimestamp, uint256 maxClaimableSupply, uint256 supplyClaimed, uint256 quantityLimitPerWallet, bytes32 merkleRoot, uint256 pricePerToken, address currency, string metadata)[] claimConditions, bool resetEligibility)\",\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"TokensClaimed\" event.\n */\nexport type TokensClaimedEventFilters = Partial<{\n  claimConditionIndex: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"claimConditionIndex\";\n    indexed: true;\n  }>;\n  claimer: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"claimer\";\n    indexed: true;\n  }>;\n  receiver: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"receiver\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the TokensClaimed event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { tokensClaimedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  tokensClaimedEvent({\n *  claimConditionIndex: ...,\n *  claimer: ...,\n *  receiver: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function tokensClaimedEvent(filters: TokensClaimedEventFilters = {}) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event TokensClaimed(uint256 indexed claimConditionIndex, address indexed claimer, address indexed receiver, uint256 startTokenId, uint256 quantityClaimed)\",\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"Approval\" event.\n */\nexport type ApprovalEventFilters = Partial<{\n  owner: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"owner\";\n    indexed: true;\n  }>;\n  approved: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"approved\";\n    indexed: true;\n  }>;\n  tokenId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"tokenId\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the Approval event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { approvalEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  approvalEvent({\n *  owner: ...,\n *  approved: ...,\n *  tokenId: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function approvalEvent(filters: ApprovalEventFilters = {}) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)\",\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"ApprovalForAll\" event.\n */\nexport type ApprovalForAllEventFilters = Partial<{\n  owner: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"owner\";\n    indexed: true;\n  }>;\n  operator: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"operator\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the ApprovalForAll event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { approvalForAllEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  approvalForAllEvent({\n *  owner: ...,\n *  operator: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function approvalForAllEvent(filters: ApprovalForAllEventFilters = {}) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event ApprovalForAll(address indexed owner, address indexed operator, bool approved)\",\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"Transfer\" event.\n */\nexport type TransferEventFilters = Partial<{\n  from: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"from\";\n    indexed: true;\n  }>;\n  to: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"to\";\n    indexed: true;\n  }>;\n  tokenId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"tokenId\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the Transfer event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { transferEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  transferEvent({\n *  from: ...,\n *  to: ...,\n *  tokenId: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function transferEvent(filters: TransferEventFilters = {}) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)\",\n  });\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0xe6798baa\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `startTokenId` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `startTokenId` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isStartTokenIdSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isStartTokenIdSupported([\"0x...\"]);\n * ```\n */\nexport function isStartTokenIdSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the startTokenId function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeStartTokenIdResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeStartTokenIdResultResult(\"...\");\n * ```\n */\nexport function decodeStartTokenIdResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"startTokenId\" function on the contract.\n * @param options - The options for the startTokenId function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { startTokenId } from \"thirdweb/extensions/erc721\";\n *\n * const result = await startTokenId({\n *  contract,\n * });\n *\n * ```\n */\nexport async function startTokenId(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0x18160ddd\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `totalSupply` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `totalSupply` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isTotalSupplySupported } from \"thirdweb/extensions/erc721\";\n * const supported = isTotalSupplySupported([\"0x...\"]);\n * ```\n */\nexport function isTotalSupplySupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the totalSupply function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeTotalSupplyResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeTotalSupplyResultResult(\"...\");\n * ```\n */\nexport function decodeTotalSupplyResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"totalSupply\" function on the contract.\n * @param options - The options for the totalSupply function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { totalSupply } from \"thirdweb/extensions/erc721\";\n *\n * const result = await totalSupply({\n *  contract,\n * });\n *\n * ```\n */\nexport async function totalSupply(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"approve\" function.\n */\nexport type ApproveParams = WithOverrides<{\n  to: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"to\" }>;\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"tokenId\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x095ea7b3\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"to\",\n    type: \"address\",\n  },\n  {\n    name: \"tokenId\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `approve` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `approve` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isApproveSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isApproveSupported([\"0x...\"]);\n * ```\n */\nexport function isApproveSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"approve\" function.\n * @param options - The options for the approve function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeApproveParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeApproveParams({\n *  to: ...,\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeApproveParams(options: ApproveParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.to, options.tokenId]);\n}\n\n/**\n * Encodes the \"approve\" function into a Hex string with its parameters.\n * @param options - The options for the approve function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeApprove } from \"thirdweb/extensions/erc721\";\n * const result = encodeApprove({\n *  to: ...,\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeApprove(options: ApproveParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeApproveParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"approve\" function on the contract.\n * @param options - The options for the \"approve\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { approve } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = approve({\n *  contract,\n *  to: ...,\n *  tokenId: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function approve(\n  options: BaseTransactionOptions<\n    | ApproveParams\n    | {\n        asyncParams: () => Promise<ApproveParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.to, resolvedOptions.tokenId] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"transferFrom\" function.\n */\nexport type TransferFromParams = WithOverrides<{\n  from: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"from\" }>;\n  to: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"to\" }>;\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"tokenId\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x23b872dd\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"from\",\n    type: \"address\",\n  },\n  {\n    name: \"to\",\n    type: \"address\",\n  },\n  {\n    name: \"tokenId\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `transferFrom` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `transferFrom` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isTransferFromSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isTransferFromSupported([\"0x...\"]);\n * ```\n */\nexport function isTransferFromSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"transferFrom\" function.\n * @param options - The options for the transferFrom function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeTransferFromParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeTransferFromParams({\n *  from: ...,\n *  to: ...,\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeTransferFromParams(options: TransferFromParams) {\n  return encodeAbiParameters(FN_INPUTS, [\n    options.from,\n    options.to,\n    options.tokenId,\n  ]);\n}\n\n/**\n * Encodes the \"transferFrom\" function into a Hex string with its parameters.\n * @param options - The options for the transferFrom function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeTransferFrom } from \"thirdweb/extensions/erc721\";\n * const result = encodeTransferFrom({\n *  from: ...,\n *  to: ...,\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeTransferFrom(options: TransferFromParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeTransferFromParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"transferFrom\" function on the contract.\n * @param options - The options for the \"transferFrom\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { transferFrom } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = transferFrom({\n *  contract,\n *  from: ...,\n *  to: ...,\n *  tokenId: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function transferFrom(\n  options: BaseTransactionOptions<\n    | TransferFromParams\n    | {\n        asyncParams: () => Promise<TransferFromParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [\n        resolvedOptions.from,\n        resolvedOptions.to,\n        resolvedOptions.tokenId,\n      ] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0x3b1475a7\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `nextTokenIdToMint` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `nextTokenIdToMint` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isNextTokenIdToMintSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isNextTokenIdToMintSupported([\"0x...\"]);\n * ```\n */\nexport function isNextTokenIdToMintSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the nextTokenIdToMint function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeNextTokenIdToMintResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeNextTokenIdToMintResultResult(\"...\");\n * ```\n */\nexport function decodeNextTokenIdToMintResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"nextTokenIdToMint\" function on the contract.\n * @param options - The options for the nextTokenIdToMint function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { nextTokenIdToMint } from \"thirdweb/extensions/erc721\";\n *\n * const result = await nextTokenIdToMint({\n *  contract,\n * });\n *\n * ```\n */\nexport async function nextTokenIdToMint(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"TokensLazyMinted\" event.\n */\nexport type TokensLazyMintedEventFilters = Partial<{\n  startTokenId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"startTokenId\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the TokensLazyMinted event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { tokensLazyMintedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  tokensLazyMintedEvent({\n *  startTokenId: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function tokensLazyMintedEvent(\n  filters: TokensLazyMintedEventFilters = {},\n) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event TokensLazyMinted(uint256 indexed startTokenId, uint256 endTokenId, string baseURI, bytes encryptedBaseURI)\",\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"setTokenURI\" function.\n */\nexport type SetTokenURIParams = WithOverrides<{\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_tokenId\" }>;\n  uri: AbiParameterToPrimitiveType<{ type: \"string\"; name: \"_uri\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x162094c4\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"_tokenId\",\n    type: \"uint256\",\n  },\n  {\n    name: \"_uri\",\n    type: \"string\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `setTokenURI` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `setTokenURI` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isSetTokenURISupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isSetTokenURISupported([\"0x...\"]);\n * ```\n */\nexport function isSetTokenURISupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"setTokenURI\" function.\n * @param options - The options for the setTokenURI function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeSetTokenURIParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeSetTokenURIParams({\n *  tokenId: ...,\n *  uri: ...,\n * });\n * ```\n */\nexport function encodeSetTokenURIParams(options: SetTokenURIParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId, options.uri]);\n}\n\n/**\n * Encodes the \"setTokenURI\" function into a Hex string with its parameters.\n * @param options - The options for the setTokenURI function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeSetTokenURI } from \"thirdweb/extensions/erc721\";\n * const result = encodeSetTokenURI({\n *  tokenId: ...,\n *  uri: ...,\n * });\n * ```\n */\nexport function encodeSetTokenURI(options: SetTokenURIParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeSetTokenURIParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"setTokenURI\" function on the contract.\n * @param options - The options for the \"setTokenURI\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { setTokenURI } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = setTokenURI({\n *  contract,\n *  tokenId: ...,\n *  uri: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function setTokenURI(\n  options: BaseTransactionOptions<\n    | SetTokenURIParams\n    | {\n        asyncParams: () => Promise<SetTokenURIParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.tokenId, resolvedOptions.uri] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Creates an event object for the SharedMetadataUpdated event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { sharedMetadataUpdatedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  sharedMetadataUpdatedEvent()\n * ],\n * });\n * ```\n */\nexport function sharedMetadataUpdatedEvent() {\n  return prepareEvent({\n    signature:\n      \"event SharedMetadataUpdated(string name, string description, string imageURI, string animationURI)\",\n  });\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0xb280f703\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"name\",\n    type: \"string\",\n  },\n  {\n    name: \"description\",\n    type: \"string\",\n  },\n  {\n    name: \"imageURI\",\n    type: \"string\",\n  },\n  {\n    name: \"animationURI\",\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `sharedMetadata` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `sharedMetadata` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isSharedMetadataSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isSharedMetadataSupported([\"0x...\"]);\n * ```\n */\nexport function isSharedMetadataSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the sharedMetadata function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeSharedMetadataResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeSharedMetadataResultResult(\"...\");\n * ```\n */\nexport function decodeSharedMetadataResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"sharedMetadata\" function on the contract.\n * @param options - The options for the sharedMetadata function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { sharedMetadata } from \"thirdweb/extensions/erc721\";\n *\n * const result = await sharedMetadata({\n *  contract,\n * });\n *\n * ```\n */\nexport async function sharedMetadata(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareEvent } from \"../../../../../event/prepare-event.js\";\n\n/**\n * Represents the filters for the \"TokensMintedWithSignature\" event.\n */\nexport type TokensMintedWithSignatureEventFilters = Partial<{\n  signer: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"signer\";\n    indexed: true;\n  }>;\n  mintedTo: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"mintedTo\";\n    indexed: true;\n  }>;\n  tokenIdMinted: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"tokenIdMinted\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the TokensMintedWithSignature event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { tokensMintedWithSignatureEvent } from \"thirdweb/extensions/erc721\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  tokensMintedWithSignatureEvent({\n *  signer: ...,\n *  mintedTo: ...,\n *  tokenIdMinted: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function tokensMintedWithSignatureEvent(\n  filters: TokensMintedWithSignatureEventFilters = {},\n) {\n  return prepareEvent({\n    filters,\n    signature:\n      \"event TokensMintedWithSignature(address indexed signer, address indexed mintedTo, uint256 indexed tokenIdMinted, (address to, address royaltyRecipient, uint256 royaltyBps, address primarySaleRecipient, string uri, uint256 price, address currency, uint128 validityStartTimestamp, uint128 validityEndTimestamp, bytes32 uid) mintpayload)\",\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"verifyClaim\" function.\n */\nexport type VerifyClaimParams = {\n  conditionId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"_conditionId\";\n  }>;\n  claimer: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"_claimer\" }>;\n  quantity: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_quantity\" }>;\n  currency: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"_currency\" }>;\n  pricePerToken: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"_pricePerToken\";\n  }>;\n  allowlistProof: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"_allowlistProof\";\n    components: [\n      { type: \"bytes32[]\"; name: \"proof\" },\n      { type: \"uint256\"; name: \"quantityLimitPerWallet\" },\n      { type: \"uint256\"; name: \"pricePerToken\" },\n      { type: \"address\"; name: \"currency\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x23a2902b\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"_conditionId\",\n    type: \"uint256\",\n  },\n  {\n    name: \"_claimer\",\n    type: \"address\",\n  },\n  {\n    name: \"_quantity\",\n    type: \"uint256\",\n  },\n  {\n    name: \"_currency\",\n    type: \"address\",\n  },\n  {\n    name: \"_pricePerToken\",\n    type: \"uint256\",\n  },\n  {\n    components: [\n      {\n        name: \"proof\",\n        type: \"bytes32[]\",\n      },\n      {\n        name: \"quantityLimitPerWallet\",\n        type: \"uint256\",\n      },\n      {\n        name: \"pricePerToken\",\n        type: \"uint256\",\n      },\n      {\n        name: \"currency\",\n        type: \"address\",\n      },\n    ],\n    name: \"_allowlistProof\",\n    type: \"tuple\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"isOverride\",\n    type: \"bool\",\n  },\n] as const;\n\n/**\n * Checks if the `verifyClaim` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `verifyClaim` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isVerifyClaimSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isVerifyClaimSupported([\"0x...\"]);\n * ```\n */\nexport function isVerifyClaimSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"verifyClaim\" function.\n * @param options - The options for the verifyClaim function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeVerifyClaimParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeVerifyClaimParams({\n *  conditionId: ...,\n *  claimer: ...,\n *  quantity: ...,\n *  currency: ...,\n *  pricePerToken: ...,\n *  allowlistProof: ...,\n * });\n * ```\n */\nexport function encodeVerifyClaimParams(options: VerifyClaimParams) {\n  return encodeAbiParameters(FN_INPUTS, [\n    options.conditionId,\n    options.claimer,\n    options.quantity,\n    options.currency,\n    options.pricePerToken,\n    options.allowlistProof,\n  ]);\n}\n\n/**\n * Encodes the \"verifyClaim\" function into a Hex string with its parameters.\n * @param options - The options for the verifyClaim function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeVerifyClaim } from \"thirdweb/extensions/erc721\";\n * const result = encodeVerifyClaim({\n *  conditionId: ...,\n *  claimer: ...,\n *  quantity: ...,\n *  currency: ...,\n *  pricePerToken: ...,\n *  allowlistProof: ...,\n * });\n * ```\n */\nexport function encodeVerifyClaim(options: VerifyClaimParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeVerifyClaimParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the verifyClaim function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeVerifyClaimResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeVerifyClaimResultResult(\"...\");\n * ```\n */\nexport function decodeVerifyClaimResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"verifyClaim\" function on the contract.\n * @param options - The options for the verifyClaim function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { verifyClaim } from \"thirdweb/extensions/erc721\";\n *\n * const result = await verifyClaim({\n *  contract,\n *  conditionId: ...,\n *  claimer: ...,\n *  quantity: ...,\n *  currency: ...,\n *  pricePerToken: ...,\n *  allowlistProof: ...,\n * });\n *\n * ```\n */\nexport async function verifyClaim(\n  options: BaseTransactionOptions<VerifyClaimParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [\n      options.conditionId,\n      options.claimer,\n      options.quantity,\n      options.currency,\n      options.pricePerToken,\n      options.allowlistProof,\n    ],\n  });\n}\n", "import { extractErrorResult } from \"../../../../transaction/extract-error.js\";\nimport type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport { getClaimParams } from \"../../../../utils/extensions/drops/get-claim-params.js\";\nimport { verifyClaim } from \"../../__generated__/DropERC721/read/verifyClaim.js\";\nimport { getActiveClaimConditionId } from \"../../__generated__/IDrop/read/getActiveClaimConditionId.js\";\n\nexport type CanClaimParams = {\n  claimer: string;\n  quantity: bigint;\n  from?: string;\n};\n\nexport type CanClaimResult = {\n  result: boolean;\n  reason?: string;\n};\n\n/**\n * Check if a user can claim a drop.\n *\n * This method is only available on the `DropERC721` contract.\n *\n * @param options - The options for the transaction.\n * @returns Whether the user can claim the drop.\n *\n * @example\n * ```ts\n * const claimResult = await canClaim({\n *   contract: contract,\n *   claimer: \"0x1234567890123456789012345678901234567890\",\n *   quantity: \"1\",\n * });\n * ```\n *\n * @extension ERC721\n */\nexport async function canClaim(\n  options: BaseTransactionOptions<CanClaimParams>,\n): Promise<CanClaimResult> {\n  const [conditionId, { quantity, currency, pricePerToken, allowlistProof }] =\n    await Promise.all([\n      getActiveClaimConditionId({\n        contract: options.contract,\n      }),\n      getClaimParams({\n        contract: options.contract,\n        from: options.from,\n        quantity: options.quantity,\n        to: options.claimer,\n        type: \"erc721\",\n      }),\n    ]);\n  try {\n    await verifyClaim({\n      allowlistProof,\n      claimer: options.claimer,\n      conditionId,\n      contract: options.contract,\n      currency,\n      pricePerToken,\n      quantity,\n    });\n    return {\n      result: true,\n    };\n  } catch (error) {\n    return {\n      reason: await extractErrorResult({ contract: options.contract, error }),\n      result: false,\n    };\n  }\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0xd637ed59\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"currentStartId\",\n    type: \"uint256\",\n  },\n  {\n    name: \"count\",\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `claimCondition` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `claimCondition` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isClaimConditionSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isClaimConditionSupported([\"0x...\"]);\n * ```\n */\nexport function isClaimConditionSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the claimCondition function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeClaimConditionResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeClaimConditionResultResult(\"...\");\n * ```\n */\nexport function decodeClaimConditionResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result);\n}\n\n/**\n * Calls the \"claimCondition\" function on the contract.\n * @param options - The options for the claimCondition function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { claimCondition } from \"thirdweb/extensions/erc721\";\n *\n * const result = await claimCondition({\n *  contract,\n * });\n *\n * ```\n */\nexport async function claimCondition(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport type { ClaimCondition } from \"../../../../utils/extensions/drops/types.js\";\nimport * as MultiPhase from \"../../__generated__/IDrop/read/claimCondition.js\";\nimport * as MultiById from \"../../__generated__/IDrop/read/getClaimConditionById.js\";\n\n/**\n * Retrieves all claim conditions.\n *\n * This method is only available on the `DropERC721` contract.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves to all claim conditions.\n * @throws An error if the claim conditions are unsupported by the contract.\n * @extension ERC721\n * @example\n * ```ts\n * import { getClaimConditions } from \"thirdweb/extensions/erc721\";\n * const conditions = await getClaimConditions({ contract });\n * ```\n */\nexport async function getClaimConditions(\n  options: BaseTransactionOptions,\n): Promise<ClaimCondition[]> {\n  try {\n    const [startId, count] = await MultiPhase.claimCondition(options);\n\n    const conditionPromises: Array<\n      ReturnType<typeof MultiById.getClaimConditionById>\n    > = [];\n    for (let i = startId; i < startId + count; i++) {\n      conditionPromises.push(\n        MultiById.getClaimConditionById({\n          ...options,\n          conditionId: i,\n        }),\n      );\n    }\n    return Promise.all(conditionPromises);\n  } catch {\n    throw new Error(\"Claim condition not found\");\n  }\n}\n\n/**\n * Checks if the `getClaimConditions` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getClaimConditions` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetClaimConditionsSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isGetClaimConditionsSupported([\"0x...\"]);\n * ```\n */\nexport function isGetClaimConditionsSupported(availableSelectors: string[]) {\n  // if multi phase is supported, return true\n  return (\n    MultiPhase.isClaimConditionSupported(availableSelectors) &&\n    MultiById.isGetClaimConditionByIdSupported(availableSelectors)\n  );\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"multicall\" function.\n */\nexport type MulticallParams = WithOverrides<{\n  data: AbiParameterToPrimitiveType<{ type: \"bytes[]\"; name: \"data\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0xac9650d8\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"data\",\n    type: \"bytes[]\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"results\",\n    type: \"bytes[]\",\n  },\n] as const;\n\n/**\n * Checks if the `multicall` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `multicall` method is supported.\n * @extension COMMON\n * @example\n * ```ts\n * import { isMulticallSupported } from \"thirdweb/extensions/common\";\n *\n * const supported = isMulticallSupported([\"0x...\"]);\n * ```\n */\nexport function isMulticallSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"multicall\" function.\n * @param options - The options for the multicall function.\n * @returns The encoded ABI parameters.\n * @extension COMMON\n * @example\n * ```ts\n * import { encodeMulticallParams } from \"thirdweb/extensions/common\";\n * const result = encodeMulticallParams({\n *  data: ...,\n * });\n * ```\n */\nexport function encodeMulticallParams(options: MulticallParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.data]);\n}\n\n/**\n * Encodes the \"multicall\" function into a Hex string with its parameters.\n * @param options - The options for the multicall function.\n * @returns The encoded hexadecimal string.\n * @extension COMMON\n * @example\n * ```ts\n * import { encodeMulticall } from \"thirdweb/extensions/common\";\n * const result = encodeMulticall({\n *  data: ...,\n * });\n * ```\n */\nexport function encodeMulticall(options: MulticallParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeMulticallParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"multicall\" function on the contract.\n * @param options - The options for the \"multicall\" function.\n * @returns A prepared transaction object.\n * @extension COMMON\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { multicall } from \"thirdweb/extensions/common\";\n *\n * const transaction = multicall({\n *  contract,\n *  data: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function multicall(\n  options: BaseTransactionOptions<\n    | MulticallParams\n    | {\n        asyncParams: () => Promise<MulticallParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.data] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { Address } from \"abitype\";\nimport { multicall } from \"../../../../extensions/common/__generated__/IMulticall/write/multicall.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../transaction/types.js\";\nimport { getClaimParams } from \"../../../../utils/extensions/drops/get-claim-params.js\";\nimport { encodeClaim } from \"../../__generated__/IDrop/write/claim.js\";\n\n/**\n * @extension ERC721\n */\nexport type ClaimToBatchParams = WithOverrides<{\n  content: Array<{\n    to: Address;\n    quantity: bigint;\n  }>;\n  from?: Address;\n}>;\n\n/**\n * This extension batches multiple `claimTo` extensions into one single multicall.\n * Keep in mind that there is a limit of how many NFTs you can claim per transaction.\n * This limit varies depends on the network that you are transacting on.\n * This method is only available on the `DropERC721` contract.\n *\n * You are recommended to experiment with the number to figure out the best number for your chain of choice.\n * @extension ERC721\n * @param options the transaction options\n * @returns A promise that resolves to the transaction result.\n *\n * @example\n * ```ts\n * import { claimToBatch } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = claimToBatch({\n *   contract: nftDropContract,\n *   from: claimer.address, // address of the one calling this transaction\n *   content: [\n *     { to: \"0x...1\", quantity: 1n },\n *     { to: \"0x...2\", quantity: 12n },\n *     { to: \"0x...3\", quantity: 2n },\n *   ],\n * });\n * ```\n */\nexport function claimToBatch(\n  options: BaseTransactionOptions<ClaimToBatchParams>,\n) {\n  return multicall({\n    asyncParams: () => getClaimToBatchParams(options),\n    contract: options.contract,\n    overrides: options.overrides,\n  });\n}\n\n/**\n * @internal\n */\nasync function getClaimToBatchParams(\n  options: BaseTransactionOptions<ClaimToBatchParams>,\n) {\n  for (let i = 0; i < options.content.length; i++) {\n    if (!options.content[i]?.quantity) {\n      throw new Error(`Error: Item at index ${i} is missing claim quantity`);\n    }\n    if (!options.content[i]?.to) {\n      throw new Error(\n        `Error: Item at index ${i} is missing recipient address (\"to\")`,\n      );\n    }\n  }\n  const content = optimizeClaimContent(options.content);\n  const data = await Promise.all(\n    content.map(async (item) => {\n      const claimParams = await getClaimParams({\n        contract: options.contract,\n        from: options.from,\n        quantity: item.quantity,\n        to: item.to,\n        type: \"erc721\",\n      });\n\n      return encodeClaim({\n        allowlistProof: claimParams.allowlistProof,\n        currency: claimParams.currency,\n        data: claimParams.data,\n        overrides: claimParams.overrides,\n        pricePerToken: claimParams.pricePerToken,\n        quantity: claimParams.quantity,\n        receiver: claimParams.receiver,\n      });\n    }),\n  );\n\n  return { data };\n}\n\n/**\n * Optimization\n * For identical addresses that stays next to each other in the array,\n * we can combine them into one transaction _without altering the claiming order_\n *\n * For example, this structure:\n * [\n *   {\n *     to: \"0xabc\",\n *     quantity: 1n,\n *   },\n *   {\n *     to: \"0xabc\",\n *     quantity: 13n,\n *   },\n * ];\n *\n * ...can be combined in one tx (without altering the claiming order)\n * {\n *   to: \"0xabc\",\n *   quantity: 14n,\n * }\n *\n * @internal\n */\nexport function optimizeClaimContent(\n  content: Array<{ to: Address; quantity: bigint }>,\n): Array<{ to: Address; quantity: bigint }> {\n  const results: Array<{ to: Address; quantity: bigint }> = [];\n  content.forEach((item, index) => {\n    const previousItem = results.at(-1);\n    if (\n      index > 0 &&\n      previousItem &&\n      item.to.toLowerCase() === previousItem.to.toLowerCase()\n    ) {\n      results[results.length - 1] = {\n        quantity: item.quantity + previousItem.quantity,\n        to: item.to,\n      };\n    } else {\n      results.push(item);\n    }\n  });\n  return results;\n}\n", "import type { Hex } from \"viem\";\nimport type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport type { ClaimCondition } from \"../../../../utils/extensions/drops/types.js\";\nimport {\n  isSetClaimConditionsSupported,\n  setClaimConditions,\n} from \"../../__generated__/IDrop/write/setClaimConditions.js\";\nimport {\n  getClaimConditions,\n  isGetClaimConditionsSupported,\n} from \"../read/getClaimConditions.js\";\n\n/**\n * Reset the claim eligibility for all users.\n * This method is only available on the `DropERC721` contract.\n * @param options\n * @returns the prepared transaction\n * @extension ERC721\n * @example\n * ```ts\n * import { resetClaimEligibility } from \"thirdweb/extensions/erc721\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = resetClaimEligibility({\n *  contract,\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function resetClaimEligibility(options: BaseTransactionOptions) {\n  // download existing conditions\n  return setClaimConditions({\n    asyncParams: async () => {\n      // get existing conditions\n      const existingConditions = await getClaimConditions(options);\n\n      // then simply return the exact same ones, but with the resetClaimEligibility flag set to true\n      return {\n        // type is necessary because of viem hex shenanigans (strict vs non-strict `0x` prefix string)\n        phases: existingConditions as Array<\n          ClaimCondition & {\n            currency: Hex;\n            merkleRoot: Hex;\n          }\n        >,\n        resetClaimEligibility: true,\n      };\n    },\n    contract: options.contract,\n  });\n}\n\n/**\n * Checks if the `resetClaimEligibility` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `resetClaimEligibility` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isResetClaimEligibilitySupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isResetClaimEligibilitySupported([\"0x...\"]);\n * ```\n */\nexport function isResetClaimEligibilitySupported(availableSelectors: string[]) {\n  return (\n    isGetClaimConditionsSupported(availableSelectors) &&\n    isSetClaimConditionsSupported(availableSelectors)\n  );\n}\n", "import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { upload } from \"../../../storage/upload.js\";\nimport type { Hex } from \"../../encoding/hex.js\";\nimport { stringify } from \"../../json.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nimport type {\n  OverrideEntry,\n  ShardData,\n  ShardedMerkleTreeInfo,\n} from \"./types.js\";\n\nexport async function processOverrideList(options: {\n  client: ThirdwebClient;\n  chain: Chain;\n  overrides: OverrideEntry[];\n  tokenDecimals: number;\n  shardNybbles?: number;\n  hashEntry?: (options: {\n    entry: OverrideEntry;\n    chain: Chain;\n    client: ThirdwebClient;\n    tokenDecimals: number;\n  }) => Promise<Hex>;\n}) {\n  const hashEntryFn = options.hashEntry || hashEntry;\n  const shardNybbles = options.shardNybbles || 2;\n  // 2. shard them into a map where the key is the first n digits of the address\n  const shards: Record<string, OverrideEntry[]> = {};\n  for (const snapshotEntry of options.overrides) {\n    const shard = snapshotEntry.address\n      .slice(2, 2 + shardNybbles)\n      .toLowerCase();\n    if (shards[shard] === undefined) {\n      shards[shard] = [];\n    }\n    // biome-ignore lint/style/noNonNullAssertion: we know it's defined\n    shards[shard]!.push(snapshotEntry);\n  }\n  // 3. create the merkle subtrees for each shard\n  const subTrees = await Promise.all(\n    Object.entries(shards).map(async ([shard, entries]) => [\n      shard,\n      new MerkleTree(\n        await Promise.all(\n          entries.map(async (entry) => {\n            return hashEntryFn({\n              chain: options.chain,\n              client: options.client,\n              entry,\n              tokenDecimals: options.tokenDecimals,\n            });\n          }),\n        ),\n      ).getHexRoot(),\n    ]),\n  );\n  // 4. create the master merkle tree from all the subtrees\n  const roots: Record<string, Hex> = Object.fromEntries(subTrees);\n  const tree = new MerkleTree(Object.values(roots));\n  // 5. upload all the shards with filename <shardId>.json to easily retrieve\n  const shardsToUpload = [];\n  for (const [shardId, entries] of Object.entries(shards)) {\n    const data: ShardData = {\n      entries,\n      // biome-ignore lint/style/noNonNullAssertion: we know this is in bounds\n      proofs: tree.getHexProof(roots[shardId]!),\n    };\n    shardsToUpload.push({\n      data: stringify(data),\n      name: `${shardId}.json`,\n    });\n  }\n  let uris = await upload({\n    client: options.client,\n    files: shardsToUpload,\n  });\n  // in the case of just 1 shard -> upload returns a string, not an array\n  if (!Array.isArray(uris)) {\n    uris = [uris];\n  }\n  if (uris.length === 0) {\n    throw new Error(\"No URIs returned from uploading merkle tree shards\");\n  }\n  // biome-ignore lint/style/noNonNullAssertion: throws above if no URIs\n  const baseUri = uris[0]!.slice(0, uris[0]!.lastIndexOf(\"/\"));\n  // 6. Also upload the original entries for retrieving all entries\n  const originalEntriesUri = await upload({\n    client: options.client,\n    files: [stringify(options.overrides)],\n  });\n  // 7. assemble the final sharded merkle tree info\n  const shardedMerkleInfo: ShardedMerkleTreeInfo = {\n    baseUri,\n    isShardedMerkleTree: true,\n    merkleRoot: tree.getHexRoot(),\n    originalEntriesUri,\n    shardNybbles,\n    tokenDecimals: options.tokenDecimals,\n  };\n  // 8. upload the final sharded merkle tree info\n  const finalUri = await upload({\n    client: options.client,\n    files: [shardedMerkleInfo],\n  });\n  return {\n    shardedMerkleInfo,\n    uri: finalUri,\n  };\n}\n", "import { maxUint256 } from \"ox/Solidity\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport type { SetClaimConditionsParams as GeneratedParams } from \"../../../extensions/erc1155/__generated__/IDrop1155/write/setClaimConditions.js\";\nimport { upload } from \"../../../storage/upload.js\";\nimport { dateToSeconds } from \"../../date.js\";\nimport { type Hex, toHex } from \"../../encoding/hex.js\";\nimport { convertErc20Amount } from \"../convert-erc20-amount.js\";\nimport { processOverrideList } from \"./process-override-list.js\";\nimport type { ClaimConditionsInput } from \"./types.js\";\n\nexport async function getMulticallSetClaimConditionTransactions(options: {\n  phases: ClaimConditionsInput[];\n  contract: ThirdwebContract;\n  tokenDecimals: number;\n  tokenId?: bigint;\n  resetClaimEligibility?: boolean;\n  singlePhase?: boolean;\n}): Promise<Hex[]> {\n  const merkleInfos: Record<string, string> = {};\n  const phases = await Promise.all(\n    options.phases.map(async (phase) => {\n      // allowlist\n      let merkleRoot: string = phase.merkleRootHash || toHex(\"\", { size: 32 });\n      if (phase.overrideList) {\n        const { shardedMerkleInfo, uri } = await processOverrideList({\n          chain: options.contract.chain,\n          client: options.contract.client,\n          overrides: phase.overrideList,\n          tokenDecimals: options.tokenDecimals,\n        });\n        merkleInfos[shardedMerkleInfo.merkleRoot] = uri;\n        merkleRoot = shardedMerkleInfo.merkleRoot;\n      }\n      // metadata\n      let metadata = \"\";\n      if (phase.metadata && typeof phase.metadata === \"string\") {\n        metadata = phase.metadata;\n      } else if (phase.metadata && typeof phase.metadata === \"object\") {\n        metadata = await upload({\n          client: options.contract.client,\n          files: [phase.metadata],\n        });\n      }\n      return {\n        currency: phase.currencyAddress || NATIVE_TOKEN_ADDRESS,\n        maxClaimableSupply: phase.maxClaimableSupply ?? maxUint256,\n        merkleRoot,\n        metadata,\n        pricePerToken: await convertErc20Amount({\n          amount: phase.price?.toString() ?? \"0\",\n          chain: options.contract.chain,\n          client: options.contract.client,\n          erc20Address: phase.currencyAddress || NATIVE_TOKEN_ADDRESS,\n        }),\n        quantityLimitPerWallet: phase.maxClaimablePerWallet ?? maxUint256,\n        startTimestamp: dateToSeconds(phase.startTime ?? new Date(0)),\n        supplyClaimed: 0n,\n      } as GeneratedParams[\"phases\"][number];\n    }),\n  );\n  const encodedTransactions: Hex[] = [];\n  // if we have new merkle roots, we need to upload them to the contract metadata\n  if (Object.keys(merkleInfos).length > 0) {\n    const [{ getContractMetadata }, { encodeSetContractURI }] =\n      await Promise.all([\n        import(\"../../../extensions/common/read/getContractMetadata.js\"),\n        import(\n          \"../../../extensions/common/__generated__/IContractMetadata/write/setContractURI.js\"\n        ),\n      ]);\n    const metadata = await getContractMetadata({\n      contract: options.contract,\n    });\n    // keep the old merkle roots from other tokenIds\n    for (const key of Object.keys(metadata.merkle || {})) {\n      merkleInfos[key] = metadata.merkle[key];\n    }\n    const mergedMetadata = {\n      ...metadata,\n      merkle: merkleInfos,\n    };\n    const uri = await upload({\n      client: options.contract.client,\n      files: [mergedMetadata],\n    });\n    const encodedSetContractURI = encodeSetContractURI({\n      uri,\n    });\n    encodedTransactions.push(encodedSetContractURI);\n  }\n  const sortedPhases = phases.sort((a, b) =>\n    Number(a.startTimestamp - b.startTimestamp),\n  );\n  let encodedSetClaimConditions: Hex;\n  if (options.tokenId !== undefined) {\n    // 1155\n    if (options.singlePhase) {\n      const { encodeSetClaimConditions } = await import(\n        \"../../../extensions/erc1155/__generated__/IDropSinglePhase1155/write/setClaimConditions.js\"\n      );\n      const phase = sortedPhases[0];\n      if (!phase) {\n        throw new Error(\"No phase provided\");\n      }\n      encodedSetClaimConditions = encodeSetClaimConditions({\n        phase,\n        resetClaimEligibility: options.resetClaimEligibility || false,\n        tokenId: options.tokenId,\n      });\n    } else {\n      const { encodeSetClaimConditions } = await import(\n        \"../../../extensions/erc1155/__generated__/IDrop1155/write/setClaimConditions.js\"\n      );\n      encodedSetClaimConditions = encodeSetClaimConditions({\n        phases: sortedPhases,\n        resetClaimEligibility: options.resetClaimEligibility || false,\n        tokenId: options.tokenId,\n      });\n    }\n  } else {\n    // erc721 or erc20\n    if (options.singlePhase) {\n      const { encodeSetClaimConditions } = await import(\n        \"../../../extensions/erc721/__generated__/IDropSinglePhase/write/setClaimConditions.js\"\n      );\n      const phase = sortedPhases[0];\n      if (!phase) {\n        throw new Error(\"No phase provided\");\n      }\n      encodedSetClaimConditions = encodeSetClaimConditions({\n        phase,\n        resetClaimEligibility: options.resetClaimEligibility || false,\n      });\n    } else {\n      const { encodeSetClaimConditions } = await import(\n        \"../../../extensions/erc721/__generated__/IDrop/write/setClaimConditions.js\"\n      );\n      encodedSetClaimConditions = encodeSetClaimConditions({\n        phases: sortedPhases,\n        resetClaimEligibility: options.resetClaimEligibility || false,\n      });\n    }\n  }\n  encodedTransactions.push(encodedSetClaimConditions);\n  return encodedTransactions;\n}\n", "import type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport { getMulticallSetClaimConditionTransactions } from \"../../../../utils/extensions/drops/get-multicall-set-claim-claim-conditon-transactions.js\";\nimport type { ClaimConditionsInput } from \"../../../../utils/extensions/drops/types.js\";\nimport { isSetContractURISupported } from \"../../../common/__generated__/IContractMetadata/write/setContractURI.js\";\nimport {\n  isMulticallSupported,\n  multicall,\n} from \"../../../common/__generated__/IMulticall/write/multicall.js\";\nimport { isGetContractMetadataSupported } from \"../../../common/read/getContractMetadata.js\";\nimport { isSetClaimConditionsSupported as isSetClaimConditionsSupportedGenerated } from \"../../__generated__/IDrop/write/setClaimConditions.js\";\nimport { isSetClaimConditionsSupported as isSetClaimConditionsSupportedGeneratedSinglePhase } from \"../../__generated__/IDropSinglePhase/write/setClaimConditions.js\";\n\n/**\n * @extension ERC721\n */\nexport type SetClaimConditionsParams = {\n  phases: ClaimConditionsInput[];\n  resetClaimEligibility?: boolean;\n  singlePhaseDrop?: boolean;\n};\n\n/**\n * Set the claim conditions for a ERC721 drop\n * This method is only available on the `DropERC721` contract.\n * @param options\n * @returns the prepared transaction\n * @extension ERC721\n * @example\n * ```ts\n * import { setClaimConditions } from \"thirdweb/extensions/erc721\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = setClaimConditions({\n *  contract,\n *  phases: [\n *    {\n *      maxClaimableSupply: 100n,\n *      maxClaimablePerWallet: 1n,\n *      currencyAddress: \"0x...\",\n *      price: 0.1,\n *      startTime: new Date(),\n *    },\n *   ],\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function setClaimConditions(\n  options: BaseTransactionOptions<SetClaimConditionsParams>,\n) {\n  return multicall({\n    asyncParams: async () => {\n      return {\n        data: await getMulticallSetClaimConditionTransactions({\n          contract: options.contract,\n          phases: options.phases,\n          resetClaimEligibility: options.resetClaimEligibility,\n          singlePhase: options.singlePhaseDrop,\n          tokenDecimals: 0,\n        }),\n      };\n    },\n    contract: options.contract,\n  });\n}\n\n/**\n * Checks if the `setClaimConditions` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `setClaimConditions` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isSetClaimConditionsSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isSetClaimConditionsSupported([\"0x...\"]);\n * ```\n */\nexport function isSetClaimConditionsSupported(availableSelectors: string[]) {\n  return (\n    isMulticallSupported(availableSelectors) &&\n    // needed for setting contract metadata\n    isGetContractMetadataSupported(availableSelectors) &&\n    isSetContractURISupported(availableSelectors) &&\n    // needs to actually be able to set the claim Conditions\n    (isSetClaimConditionsSupportedGenerated(availableSelectors) ||\n      isSetClaimConditionsSupportedGeneratedSinglePhase(availableSelectors))\n  );\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"updateBatchBaseURI\" function.\n */\nexport type UpdateBatchBaseURIParams = WithOverrides<{\n  index: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_index\" }>;\n  uri: AbiParameterToPrimitiveType<{ type: \"string\"; name: \"_uri\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0xde903ddd\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"_index\",\n    type: \"uint256\",\n  },\n  {\n    name: \"_uri\",\n    type: \"string\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `updateBatchBaseURI` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `updateBatchBaseURI` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isUpdateBatchBaseURISupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isUpdateBatchBaseURISupported([\"0x...\"]);\n * ```\n */\nexport function isUpdateBatchBaseURISupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"updateBatchBaseURI\" function.\n * @param options - The options for the updateBatchBaseURI function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeUpdateBatchBaseURIParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeUpdateBatchBaseURIParams({\n *  index: ...,\n *  uri: ...,\n * });\n * ```\n */\nexport function encodeUpdateBatchBaseURIParams(\n  options: UpdateBatchBaseURIParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.index, options.uri]);\n}\n\n/**\n * Encodes the \"updateBatchBaseURI\" function into a Hex string with its parameters.\n * @param options - The options for the updateBatchBaseURI function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeUpdateBatchBaseURI } from \"thirdweb/extensions/erc721\";\n * const result = encodeUpdateBatchBaseURI({\n *  index: ...,\n *  uri: ...,\n * });\n * ```\n */\nexport function encodeUpdateBatchBaseURI(options: UpdateBatchBaseURIParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeUpdateBatchBaseURIParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"updateBatchBaseURI\" function on the contract.\n * @param options - The options for the \"updateBatchBaseURI\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { updateBatchBaseURI } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = updateBatchBaseURI({\n *  contract,\n *  index: ...,\n *  uri: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function updateBatchBaseURI(\n  options: BaseTransactionOptions<\n    | UpdateBatchBaseURIParams\n    | {\n        asyncParams: () => Promise<UpdateBatchBaseURIParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.index, resolvedOptions.uri] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0x63b45e2d\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `getBaseURICount` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getBaseURICount` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetBaseURICountSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isGetBaseURICountSupported([\"0x...\"]);\n * ```\n */\nexport function isGetBaseURICountSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the getBaseURICount function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeGetBaseURICountResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeGetBaseURICountResultResult(\"...\");\n * ```\n */\nexport function decodeGetBaseURICountResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getBaseURICount\" function on the contract.\n * @param options - The options for the getBaseURICount function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { getBaseURICount } from \"thirdweb/extensions/erc721\";\n *\n * const result = await getBaseURICount({\n *  contract,\n * });\n *\n * ```\n */\nexport async function getBaseURICount(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"getBatchIdAtIndex\" function.\n */\nexport type GetBatchIdAtIndexParams = {\n  index: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_index\" }>;\n};\n\nexport const FN_SELECTOR = \"0x2419f51b\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"_index\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `getBatchIdAtIndex` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getBatchIdAtIndex` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetBatchIdAtIndexSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isGetBatchIdAtIndexSupported([\"0x...\"]);\n * ```\n */\nexport function isGetBatchIdAtIndexSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getBatchIdAtIndex\" function.\n * @param options - The options for the getBatchIdAtIndex function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeGetBatchIdAtIndexParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeGetBatchIdAtIndexParams({\n *  index: ...,\n * });\n * ```\n */\nexport function encodeGetBatchIdAtIndexParams(\n  options: GetBatchIdAtIndexParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.index]);\n}\n\n/**\n * Encodes the \"getBatchIdAtIndex\" function into a Hex string with its parameters.\n * @param options - The options for the getBatchIdAtIndex function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeGetBatchIdAtIndex } from \"thirdweb/extensions/erc721\";\n * const result = encodeGetBatchIdAtIndex({\n *  index: ...,\n * });\n * ```\n */\nexport function encodeGetBatchIdAtIndex(options: GetBatchIdAtIndexParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetBatchIdAtIndexParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getBatchIdAtIndex function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeGetBatchIdAtIndexResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeGetBatchIdAtIndexResultResult(\"...\");\n * ```\n */\nexport function decodeGetBatchIdAtIndexResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getBatchIdAtIndex\" function on the contract.\n * @param options - The options for the getBatchIdAtIndex function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { getBatchIdAtIndex } from \"thirdweb/extensions/erc721\";\n *\n * const result = await getBatchIdAtIndex({\n *  contract,\n *  index: ...,\n * });\n *\n * ```\n */\nexport async function getBatchIdAtIndex(\n  options: BaseTransactionOptions<GetBatchIdAtIndexParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.index],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport type { NFT, NFTInput } from \"../../../../utils/nft/parseNft.js\";\nimport * as BatchBaseURI from \"../../__generated__/DropERC721/write/updateBatchBaseURI.js\";\nimport * as BaseURICount from \"../../__generated__/IBatchMintMetadata/read/getBaseURICount.js\";\nimport * as BatchAtIndex from \"../../__generated__/IBatchMintMetadata/read/getBatchIdAtIndex.js\";\nimport * as GetNFT from \"../../read/getNFT.js\";\n\n/**\n * @extension ERC721\n */\nexport type UpdateMetadataParams = {\n  targetTokenId: bigint;\n  newMetadata: NFTInput;\n};\n\n/**\n * @internal\n */\nasync function getUpdateMetadataParams(\n  options: BaseTransactionOptions<UpdateMetadataParams>,\n): Promise<BatchBaseURI.UpdateBatchBaseURIParams> {\n  const { contract, targetTokenId, newMetadata } = options;\n  const batchCount = await BaseURICount.getBaseURICount(options);\n  if (batchCount === 0n) {\n    throw new Error(\n      \"No base URI set. Please set a base URI before updating metadata\",\n    );\n  }\n\n  // Look for the batchId & determine the start + end tokenId of the batch\n  let startTokenId = 0n;\n  let endTokenId = 0n;\n  let batchIndex = 0n;\n  for (let i = 0n; i < batchCount; i += 1n) {\n    batchIndex = i;\n    endTokenId = await BatchAtIndex.getBatchIdAtIndex({\n      contract,\n      index: batchIndex,\n    });\n    if (endTokenId > targetTokenId) {\n      break;\n    }\n    startTokenId = endTokenId;\n  }\n\n  const range = Array.from(\n    { length: Number(endTokenId - startTokenId) },\n    (_, k) => BigInt(k) + startTokenId,\n  );\n\n  const BATCH_SIZE = 50;\n  const currentMetadatas = [];\n  for (let i = 0; i < range.length; i += BATCH_SIZE) {\n    const chunk = range.slice(i, i + BATCH_SIZE);\n    const chunkResults = await Promise.all(\n      chunk.map((id) =>\n        GetNFT.getNFT({\n          contract,\n          includeOwner: false,\n          tokenId: id,\n          useIndexer: false,\n        }),\n      ),\n    );\n    currentMetadatas.push(...chunkResults);\n    if (i + BATCH_SIZE < range.length) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n    // Abort if any of the items failed to load\n    if (currentMetadatas.some((item) => item === undefined || !item.tokenURI)) {\n      throw new Error(\n        `Failed to load all ${range.length} items from batchIndex: ${batchIndex}`,\n      );\n    }\n  }\n\n  const newMetadatas: NFTInput[] = [];\n  for (let i = 0; i < currentMetadatas.length; i++) {\n    const { id, metadata } = currentMetadatas[i] as NFT;\n    if (targetTokenId === id) {\n      newMetadatas.push(newMetadata);\n    } else {\n      newMetadatas.push(metadata);\n    }\n  }\n\n  const { uploadOrExtractURIs } = await import(\"../../../../utils/ipfs.js\");\n  const batchOfUris = await uploadOrExtractURIs(\n    newMetadatas,\n    contract.client,\n    Number(startTokenId),\n  );\n\n  if (!batchOfUris || !batchOfUris.length || !batchOfUris[0]) {\n    throw new Error(\"Failed to upload batch of new metadatas\");\n  }\n\n  const baseUri = batchOfUris[0].substring(0, batchOfUris[0].lastIndexOf(\"/\"));\n\n  // IMPORTANT: The new ipfs URI must have the trailing slash at the end\n  // this is required by the Drop contract\n  const uri = `${baseUri}/`;\n\n  return { index: batchIndex, uri };\n}\n\n/**\n * Update the metadata of the single token in an NFT Drop (DropERC721) collection\n * For NFT Collection, please use `setTokenURI`\n * @param options\n * @returns the prepared transaction\n * @extension ERC721\n * @example\n * ```ts\n * import { updateMetadata } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = updateMetadata({\n *  contract,\n *  targetTokenId: 0n,\n *  client: thirdwebClient,\n *  newMetadata: {\n *    name: \"this is the new nft name\",\n *    description: \"...\",\n *    image: \"new image uri\"\n *    // ...\n *  }\n * });\n * ```\n */\nexport function updateMetadata(\n  options: BaseTransactionOptions<UpdateMetadataParams>,\n) {\n  const { contract } = options;\n  return BatchBaseURI.updateBatchBaseURI({\n    asyncParams: async () => getUpdateMetadataParams(options),\n    contract,\n  });\n}\n\n/**\n * Checks if the `updateMetadata` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `updateMetadata` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isUpdateMetadataSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isUpdateMetadataSupported([\"0x...\"]);\n * ```\n */\nexport function isUpdateMetadataSupported(availableSelectors: string[]) {\n  return (\n    BaseURICount.isGetBaseURICountSupported(availableSelectors) &&\n    BatchBaseURI.isUpdateBatchBaseURISupported(availableSelectors) &&\n    BatchAtIndex.isGetBatchIdAtIndexSupported(availableSelectors) &&\n    GetNFT.isGetNFTSupported(availableSelectors)\n  );\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"encryptedData\" function.\n */\nexport type EncryptedDataParams = {\n  index: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"index\" }>;\n};\n\nexport const FN_SELECTOR = \"0xa05112fc\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"index\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes\",\n  },\n] as const;\n\n/**\n * Checks if the `encryptedData` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `encryptedData` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isEncryptedDataSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isEncryptedDataSupported([\"0x...\"]);\n * ```\n */\nexport function isEncryptedDataSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"encryptedData\" function.\n * @param options - The options for the encryptedData function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeEncryptedDataParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeEncryptedDataParams({\n *  index: ...,\n * });\n * ```\n */\nexport function encodeEncryptedDataParams(options: EncryptedDataParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.index]);\n}\n\n/**\n * Encodes the \"encryptedData\" function into a Hex string with its parameters.\n * @param options - The options for the encryptedData function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeEncryptedData } from \"thirdweb/extensions/erc721\";\n * const result = encodeEncryptedData({\n *  index: ...,\n * });\n * ```\n */\nexport function encodeEncryptedData(options: EncryptedDataParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeEncryptedDataParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the encryptedData function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeEncryptedDataResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeEncryptedDataResultResult(\"...\");\n * ```\n */\nexport function decodeEncryptedDataResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"encryptedData\" function on the contract.\n * @param options - The options for the encryptedData function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { encryptedData } from \"thirdweb/extensions/erc721\";\n *\n * const result = await encryptedData({\n *  contract,\n *  index: ...,\n * });\n *\n * ```\n */\nexport async function encryptedData(\n  options: BaseTransactionOptions<EncryptedDataParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.index],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"baseURIIndices\" function.\n */\nexport type BaseURIIndicesParams = {\n  index: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"index\" }>;\n};\n\nexport const FN_SELECTOR = \"0xd860483f\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"index\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `baseURIIndices` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `baseURIIndices` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isBaseURIIndicesSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isBaseURIIndicesSupported([\"0x...\"]);\n * ```\n */\nexport function isBaseURIIndicesSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"baseURIIndices\" function.\n * @param options - The options for the baseURIIndices function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeBaseURIIndicesParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeBaseURIIndicesParams({\n *  index: ...,\n * });\n * ```\n */\nexport function encodeBaseURIIndicesParams(options: BaseURIIndicesParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.index]);\n}\n\n/**\n * Encodes the \"baseURIIndices\" function into a Hex string with its parameters.\n * @param options - The options for the baseURIIndices function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeBaseURIIndices } from \"thirdweb/extensions/erc721\";\n * const result = encodeBaseURIIndices({\n *  index: ...,\n * });\n * ```\n */\nexport function encodeBaseURIIndices(options: BaseURIIndicesParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeBaseURIIndicesParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the baseURIIndices function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeBaseURIIndicesResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeBaseURIIndicesResultResult(\"...\");\n * ```\n */\nexport function decodeBaseURIIndicesResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"baseURIIndices\" function on the contract.\n * @param options - The options for the baseURIIndices function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { baseURIIndices } from \"thirdweb/extensions/erc721\";\n *\n * const result = await baseURIIndices({\n *  contract,\n *  index: ...,\n * });\n *\n * ```\n */\nexport async function baseURIIndices(\n  options: BaseTransactionOptions<BaseURIIndicesParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.index],\n  });\n}\n", "import { decodeAbiParameters } from \"viem/utils\";\nimport type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { fetchTokenMetadata } from \"../../../../utils/nft/fetchTokenMetadata.js\";\nimport type { NFTMetadata } from \"../../../../utils/nft/parseNft.js\";\nimport * as GetBaseURICount from \"../../__generated__/IBatchMintMetadata/read/getBaseURICount.js\";\nimport * as GetBatchIdAtIndex from \"../../__generated__/IBatchMintMetadata/read/getBatchIdAtIndex.js\";\nimport * as EncryptedData from \"../../__generated__/IDelayedReveal/read/encryptedData.js\";\nimport * as BaseURIIndicies from \"../../__generated__/IDrop/read/baseURIIndices.js\";\nimport * as TokenURI from \"../../__generated__/IERC721A/read/tokenURI.js\";\n\n/**\n * @extension ERC721\n */\nexport interface BatchToReveal {\n  batchId: bigint;\n  batchUri: string;\n  placeholderMetadata: NFTMetadata | undefined;\n}\n\n/**\n * Retrieves the batches available to reveal in an NFT contract.\n *\n * @param options {BaseTransactionOptions} - The transaction options.\n * @param options.contract {@link ThirdwebContract} - The NFT contract instance.\n * @returns A promise resolving to an array of unrevealed batches.\n *\n *  Use the `batchId` and corresponding password for each batch to reveal it with `reveal`. {@see reveal}\n * @extension ERC721\n * @example\n * ```ts\n * import { getBatchesToReveal } from \"thirdweb/extensions/erc721\";\n *\n * const batches = await getBatchesToReveal({ contract: contract });\n *\n * const { transactionHash } = await sendTransaction({ transaction, account });\n * ```\n */\nexport async function getBatchesToReveal(\n  options: BaseTransactionOptions,\n): Promise<BatchToReveal[]> {\n  const count = await GetBaseURICount.getBaseURICount({\n    contract: options.contract,\n  });\n  if (count === 0n) {\n    return [];\n  }\n\n  const countRangeArray = Array.from(Array(Number(count)).keys());\n  const uriIndices = await Promise.all(\n    countRangeArray.map(async (batchId) => {\n      const promiseAll = await Promise.allSettled([\n        GetBatchIdAtIndex.getBatchIdAtIndex({\n          contract: options.contract,\n          index: BigInt(batchId),\n        }),\n        BaseURIIndicies.baseURIIndices({\n          contract: options.contract,\n          index: BigInt(batchId),\n        }),\n      ]);\n      const result = promiseAll.find((result) => result.status === \"fulfilled\");\n      if (!result) {\n        throw new Error(\n          \"Contract does not have `getBatchIdAtIndex` or `baseURIIndices`, which are required for `getBatchesToReveal`\",\n        );\n      }\n      return result.value;\n    }),\n  );\n\n  // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n  const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n  const tokenMetadatas = await Promise.all(\n    Array.from([0, ...uriIndicesWithZeroStart]).map(async (i) => {\n      const uri = await TokenURI.tokenURI({\n        contract: options.contract,\n        tokenId: BigInt(i),\n      });\n      return await fetchTokenMetadata({\n        client: options.contract.client,\n        tokenId: BigInt(i),\n        tokenUri: uri,\n      }).catch(() => undefined);\n    }),\n  );\n\n  const encryptedUriData = await Promise.all(\n    Array.from([...uriIndices]).map((i) =>\n      EncryptedData.encryptedData({\n        contract: options.contract,\n        index: BigInt(i),\n      }),\n    ),\n  );\n\n  const encryptedBaseUris = encryptedUriData.map((data) => {\n    const hexDataLength = (data.length - 2) / 2;\n    if (hexDataLength > 0) {\n      return decodeAbiParameters(\n        [\n          { name: \"baseUri\", type: \"bytes\" },\n          { name: \"provenanceHash\", type: \"bytes32\" },\n        ],\n        data,\n      )[0];\n    }\n\n    return data;\n  });\n\n  return tokenMetadatas\n    .map((metadata, i) => ({\n      batchId: BigInt(i),\n      batchUri: encryptedBaseUris[i] as Hex,\n      placeholderMetadata: metadata,\n    }))\n    .filter((_, index) => (encryptedBaseUris[index]?.length || 0) > 0);\n}\n\n/**\n * Checks if the `getBatchesToReveal` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getBatchesToReveal` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetBatchesToRevealSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isGetBatchesToRevealSupported([\"0x...\"]);\n * ```\n */\nexport function isGetBatchesToRevealSupported(availableSelectors: string[]) {\n  return [\n    GetBaseURICount.isGetBaseURICountSupported(availableSelectors),\n    GetBatchIdAtIndex.isGetBatchIdAtIndexSupported(availableSelectors),\n    EncryptedData.isEncryptedDataSupported(availableSelectors),\n    BaseURIIndicies.isBaseURIIndicesSupported(availableSelectors),\n    TokenURI.isTokenURISupported(availableSelectors),\n  ].every(Boolean);\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"encryptDecrypt\" function.\n */\nexport type EncryptDecryptParams = {\n  data: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"data\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0xe7150322\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"data\",\n    type: \"bytes\",\n  },\n  {\n    name: \"key\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"result\",\n    type: \"bytes\",\n  },\n] as const;\n\n/**\n * Checks if the `encryptDecrypt` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `encryptDecrypt` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isEncryptDecryptSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isEncryptDecryptSupported([\"0x...\"]);\n * ```\n */\nexport function isEncryptDecryptSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"encryptDecrypt\" function.\n * @param options - The options for the encryptDecrypt function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeEncryptDecryptParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeEncryptDecryptParams({\n *  data: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeEncryptDecryptParams(options: EncryptDecryptParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.data, options.key]);\n}\n\n/**\n * Encodes the \"encryptDecrypt\" function into a Hex string with its parameters.\n * @param options - The options for the encryptDecrypt function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeEncryptDecrypt } from \"thirdweb/extensions/erc721\";\n * const result = encodeEncryptDecrypt({\n *  data: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeEncryptDecrypt(options: EncryptDecryptParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeEncryptDecryptParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the encryptDecrypt function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeEncryptDecryptResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeEncryptDecryptResultResult(\"...\");\n * ```\n */\nexport function decodeEncryptDecryptResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"encryptDecrypt\" function on the contract.\n * @param options - The options for the encryptDecrypt function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { encryptDecrypt } from \"thirdweb/extensions/erc721\";\n *\n * const result = await encryptDecrypt({\n *  contract,\n *  data: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function encryptDecrypt(\n  options: BaseTransactionOptions<EncryptDecryptParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.data, options.key],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"lazyMint\" function.\n */\nexport type LazyMintParams = WithOverrides<{\n  amount: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"amount\" }>;\n  baseURIForTokens: AbiParameterToPrimitiveType<{\n    type: \"string\";\n    name: \"baseURIForTokens\";\n  }>;\n  extraData: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"extraData\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0xd37c353b\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"amount\",\n    type: \"uint256\",\n  },\n  {\n    name: \"baseURIForTokens\",\n    type: \"string\",\n  },\n  {\n    name: \"extraData\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"batchId\",\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `lazyMint` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `lazyMint` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isLazyMintSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isLazyMintSupported([\"0x...\"]);\n * ```\n */\nexport function isLazyMintSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"lazyMint\" function.\n * @param options - The options for the lazyMint function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeLazyMintParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeLazyMintParams({\n *  amount: ...,\n *  baseURIForTokens: ...,\n *  extraData: ...,\n * });\n * ```\n */\nexport function encodeLazyMintParams(options: LazyMintParams) {\n  return encodeAbiParameters(FN_INPUTS, [\n    options.amount,\n    options.baseURIForTokens,\n    options.extraData,\n  ]);\n}\n\n/**\n * Encodes the \"lazyMint\" function into a Hex string with its parameters.\n * @param options - The options for the lazyMint function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeLazyMint } from \"thirdweb/extensions/erc721\";\n * const result = encodeLazyMint({\n *  amount: ...,\n *  baseURIForTokens: ...,\n *  extraData: ...,\n * });\n * ```\n */\nexport function encodeLazyMint(options: LazyMintParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeLazyMintParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"lazyMint\" function on the contract.\n * @param options - The options for the \"lazyMint\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { lazyMint } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = lazyMint({\n *  contract,\n *  amount: ...,\n *  baseURIForTokens: ...,\n *  extraData: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function lazyMint(\n  options: BaseTransactionOptions<\n    | LazyMintParams\n    | {\n        asyncParams: () => Promise<LazyMintParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [\n        resolvedOptions.amount,\n        resolvedOptions.baseURIForTokens,\n        resolvedOptions.extraData,\n      ] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import { encodePacked } from \"viem/utils\";\nimport type { ThirdwebContract } from \"../../../../contract/contract.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { keccak256 } from \"../../../../utils/hashing/keccak256.js\";\n\n/**\n * @internal\n */\nexport const hashDelayedRevealPassword = async (\n  batchTokenIndex: bigint,\n  password: string,\n  contract: ThirdwebContract,\n) => {\n  const chainId = BigInt(contract.chain.id);\n  const contractAddress = contract.address;\n  return keccak256(\n    encodePacked(\n      [\"string\", \"uint256\", \"uint256\", \"address\"],\n      [password, chainId, batchTokenIndex, getAddress(contractAddress)],\n    ),\n  );\n};\n", "import { encodePacked } from \"viem/utils\";\nimport { upload } from \"../../../../storage/upload.js\";\nimport type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../utils/abi/encodeAbiParameters.js\";\nimport { toHex } from \"../../../../utils/encoding/hex.js\";\nimport { keccak256 } from \"../../../../utils/hashing/keccak256.js\";\nimport { getBaseUriFromBatch } from \"../../../../utils/ipfs.js\";\nimport type { NFTInput } from \"../../../../utils/nft/parseNft.js\";\nimport {\n  getBaseURICount,\n  isGetBaseURICountSupported,\n} from \"../../__generated__/IBatchMintMetadata/read/getBaseURICount.js\";\nimport {\n  encryptDecrypt,\n  isEncryptDecryptSupported,\n} from \"../../__generated__/IDelayedReveal/read/encryptDecrypt.js\";\nimport { nextTokenIdToMint } from \"../../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js\";\nimport {\n  lazyMint as generatedLazyMint,\n  isLazyMintSupported,\n} from \"../../__generated__/ILazyMint/write/lazyMint.js\";\nimport { hashDelayedRevealPassword } from \"../helpers/hashDelayedRevealBatch.js\";\n\n/**\n * @extension ERC721\n */\nexport type CreateDelayedRevealBatchParams = {\n  placeholderMetadata: NFTInput;\n  metadata: NFTInput[];\n  password: string;\n};\n\n/**\n * Creates a batch of encrypted NFTs that can be revealed at a later time.\n * This method is only available on the `DropERC721` contract.\n *\n * @param options {CreateDelayedRevealBatchParams} - The delayed reveal options.\n * @param options.placeholderMetadata {@link NFTInput} - The placeholder metadata for the batch.\n * @param options.metadata {@link NFTInput} - An array of NFT metadata to be revealed at a later time.\n * @param options.password {string} - The password for the reveal.\n * @param options.contract {@link ThirdwebContract} - The NFT contract instance.\n *\n * @returns The prepared transaction to send.\n *\n * @extension ERC721\n * @example\n * ```ts\n * import { createDelayedRevealBatch } from \"thirdweb/extensions/erc721\";\n *\n * const placeholderNFT = {\n *   name: \"Hidden NFT\",\n *   description: \"Will be revealed next week!\"\n * };\n *\n * const realNFTs = [{\n *   name: \"Common NFT #1\",\n *   description: \"Common NFT, one of many.\",\n *   image: ipfs://...,\n * }, {\n *   name: \"Super Rare NFT #2\",\n *   description: \"You got a Super Rare NFT!\",\n *   image: ipfs://...,\n * }];\n *\n * const transaction = createDelayedRevealBatch({\n *  contract,\n *  placeholderMetadata: placeholderNFT,\n *  metadata: realNFTs,\n *  password: \"password123\",\n * });\n *\n * const { transactionHash } = await sendTransaction({ transaction, account });\n * ```\n */\nexport function createDelayedRevealBatch(\n  options: BaseTransactionOptions<CreateDelayedRevealBatchParams>,\n) {\n  if (!options.password) {\n    throw new Error(\"Password is required\");\n  }\n\n  return generatedLazyMint({\n    asyncParams: async () => {\n      const [placeholderUris, startFileNumber] = await Promise.all([\n        upload({\n          client: options.contract.client,\n          files: Array(options.metadata.length).fill(\n            options.placeholderMetadata,\n          ),\n        }),\n        nextTokenIdToMint({\n          contract: options.contract,\n        }),\n      ]);\n      const placeholderUri = getBaseUriFromBatch(placeholderUris);\n\n      const uris = await upload({\n        client: options.contract.client,\n        files: options.metadata,\n        // IMPORTANT: File number has to be calculated properly otherwise the whole batch will break\n        // e.g: If you are uploading a second batch, the file name should never start from `0`\n        rewriteFileNames: {\n          fileStartNumber: Number(startFileNumber),\n        },\n      });\n\n      const baseUri = getBaseUriFromBatch(uris);\n      const baseUriId = await getBaseURICount({\n        contract: options.contract,\n      });\n\n      const hashedPassword = await hashDelayedRevealPassword(\n        baseUriId,\n        options.password,\n        options.contract,\n      );\n      const encryptedBaseURI = await encryptDecrypt({\n        contract: options.contract,\n        data: toHex(baseUri),\n        key: hashedPassword,\n      });\n\n      const chainId = BigInt(options.contract.chain.id);\n      const provenanceHash = keccak256(\n        encodePacked(\n          [\"bytes\", \"bytes\", \"uint256\"],\n          [toHex(baseUri), hashedPassword, chainId],\n        ),\n      );\n      const data = encodeAbiParameters(\n        [\n          { name: \"baseUri\", type: \"bytes\" },\n          { name: \"provenanceHash\", type: \"bytes32\" },\n        ],\n        [encryptedBaseURI, provenanceHash],\n      );\n\n      return {\n        amount: BigInt(options.metadata.length),\n        baseURIForTokens:\n          placeholderUri.slice(-1) === \"/\"\n            ? placeholderUri\n            : `${placeholderUri}/`,\n        extraData: data,\n      } as const;\n    },\n    contract: options.contract,\n  });\n}\n\n/**\n * Checks if the `createDelayedRevealBatch` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `createDelayedRevealBatch` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isCreateDelayedRevealBatchSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isCreateDelayedRevealBatchSupported([\"0x...\"]);\n * ```\n */\nexport function isCreateDelayedRevealBatchSupported(\n  availableSelectors: string[],\n) {\n  return [\n    isGetBaseURICountSupported(availableSelectors),\n    isEncryptDecryptSupported(availableSelectors),\n    isLazyMintSupported(availableSelectors),\n  ].every(Boolean);\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"reveal\" function.\n */\nexport type RevealParams = WithOverrides<{\n  identifier: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"identifier\";\n  }>;\n  key: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"key\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0xce805642\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"identifier\",\n    type: \"uint256\",\n  },\n  {\n    name: \"key\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"revealedURI\",\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `reveal` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `reveal` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isRevealSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isRevealSupported([\"0x...\"]);\n * ```\n */\nexport function isRevealSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"reveal\" function.\n * @param options - The options for the reveal function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeRevealParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeRevealParams({\n *  identifier: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeRevealParams(options: RevealParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.identifier, options.key]);\n}\n\n/**\n * Encodes the \"reveal\" function into a Hex string with its parameters.\n * @param options - The options for the reveal function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeReveal } from \"thirdweb/extensions/erc721\";\n * const result = encodeReveal({\n *  identifier: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeReveal(options: RevealParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeRevealParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"reveal\" function on the contract.\n * @param options - The options for the \"reveal\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { reveal } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = reveal({\n *  contract,\n *  identifier: ...,\n *  key: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function reveal(\n  options: BaseTransactionOptions<\n    | RevealParams\n    | {\n        asyncParams: () => Promise<RevealParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.identifier, resolvedOptions.key] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport { reveal as generatedReveal } from \"../../__generated__/IDelayedReveal/write/reveal.js\";\nimport { hashDelayedRevealPassword } from \"../helpers/hashDelayedRevealBatch.js\";\n\nexport { isRevealSupported } from \"../../__generated__/IDelayedReveal/write/reveal.js\";\n\n/**\n * @extension ERC721\n */\nexport type RevealParams = {\n  batchId: bigint;\n  password: string;\n};\n\n/**\n * Reveals a previously lazy minted batch of NFTs.\n * This method is only available on the `DropERC721` contract.\n * @param options {RevealParams} - The reveal parameters.\n * @param options.batchId {number} - The ID of the batch to reveal. Get this by calling `getBatchesToReveal`. {@see getBatchesToReveal}\n * @param options.password {string} - The password for the reveal, set when the batch was created. {@see createDelayedRevealBatch}\n * @param options.contract {@link ThirdwebContract} - The NFT contract instance.\n *\n * @returns The prepared transaction to send.\n *\n * @extension ERC721\n * @example\n * ```ts\n * import { reveal } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = await reveal({ contract: contract, batchId: 0, password: \"password\" });\n *\n * const { transactionHash } = await sendTransaction({ transaction, account });\n * ```\n */\nexport function reveal(options: BaseTransactionOptions<RevealParams>) {\n  if (!options.password) {\n    throw new Error(\"Password is required\");\n  }\n\n  return generatedReveal({\n    asyncParams: async () => {\n      const key = await hashDelayedRevealPassword(\n        options.batchId,\n        options.password,\n        options.contract,\n      );\n      return {\n        identifier: options.batchId,\n        key,\n      };\n    },\n    contract: options.contract,\n  });\n}\n", "import { ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { min } from \"../../../utils/bigint.js\";\nimport { ownerOf } from \"../__generated__/IERC721A/read/ownerOf.js\";\nimport { startTokenId } from \"../__generated__/IERC721A/read/startTokenId.js\";\nimport { totalSupply } from \"../__generated__/IERC721A/read/totalSupply.js\";\nimport { nextTokenIdToMint } from \"../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js\";\n\nconst DEFAULT_QUERY_ALL_COUNT = 100n;\n\n/**\n * Parameters for retrieving NFTs.\n * @extension ERC721\n */\nexport type GetAllOwnersParams = {\n  /**\n   * Which tokenId to start at.\n   * @default 0\n   */\n  start?: number;\n  /**\n   * The number of NFTs to retrieve.\n   * @default 100\n   */\n  count?: number;\n};\n\n/**\n * Retrieves the owners of all ERC721 tokens within a specified range.\n * @param options - The options for retrieving the owners.\n * @returns A promise that resolves to an array of objects containing the token ID and owner address.\n * @throws An error if the contract does not have either `nextTokenIdToMint` or `totalSupply` function available.\n * @extension ERC721\n * @example\n * ```ts\n * import { getAllOwners } from \"thirdweb/extensions/erc721\";\n * const owners = await getAllOwners({\n *  contract,\n *  start: 0,\n *  count: 10,\n * });\n * ```\n */\nexport async function getAllOwners(\n  options: BaseTransactionOptions<GetAllOwnersParams>,\n): Promise<{ tokenId: bigint; owner: string }[]> {\n  const [startTokenId_, maxSupply] = await Promise.allSettled([\n    startTokenId(options),\n    nextTokenIdToMint(options),\n    totalSupply(options),\n  ]).then(([_startTokenId, _next, _total]) => {\n    // default to 0 if startTokenId is not available\n    const startTokenId__ =\n      _startTokenId.status === \"fulfilled\" ? _startTokenId.value : 0n;\n    let maxSupply_: bigint;\n    // prioritize nextTokenIdToMint\n    if (_next.status === \"fulfilled\") {\n      // because we always default the startTokenId to 0 we can safely just always subtract here\n      maxSupply_ = _next.value - startTokenId__;\n    }\n    // otherwise use totalSupply\n    else if (_total.status === \"fulfilled\") {\n      maxSupply_ = _total.value;\n    } else {\n      throw new Error(\n        \"Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint\",\n      );\n    }\n    return [startTokenId__, maxSupply_] as const;\n  });\n  const start = BigInt(options.start ?? 0) + startTokenId_;\n  const count = BigInt(options.count ?? DEFAULT_QUERY_ALL_COUNT);\n\n  const maxId = min(maxSupply + startTokenId_, start + count);\n\n  const promises: Promise<{ tokenId: bigint; owner: string }>[] = [];\n\n  for (let i = start; i < maxId; i++) {\n    promises.push(\n      ownerOf({ contract: options.contract, tokenId: i })\n        .catch(() => ZERO_ADDRESS)\n        .then((owner) => ({\n          owner,\n          tokenId: i,\n        })),\n    );\n  }\n\n  return await Promise.all(promises);\n}\n", "import { getContractNFTs } from \"../../../insight/index.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { min } from \"../../../utils/bigint.js\";\nimport type { NFT } from \"../../../utils/nft/parseNft.js\";\nimport { startTokenId } from \"../__generated__/IERC721A/read/startTokenId.js\";\nimport {\n  isTotalSupplySupported,\n  totalSupply,\n} from \"../__generated__/IERC721A/read/totalSupply.js\";\nimport {\n  isNextTokenIdToMintSupported,\n  nextTokenIdToMint,\n} from \"../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js\";\nimport { getNFT, isGetNFTSupported } from \"./getNFT.js\";\n\nconst DEFAULT_QUERY_ALL_COUNT = 100n;\n\n/**\n * Parameters for retrieving NFTs.\n * @extension ERC721\n */\nexport type GetNFTsParams = {\n  /**\n   * Which tokenId to start at.\n   * @default 0\n   */\n  start?: number;\n  /**\n   * The number of NFTs to retrieve.\n   * @default 100\n   */\n  count?: number;\n  /**\n   * Whether to include the owner of each NFT.\n   * @default false\n   */\n  includeOwners?: boolean;\n  /**\n   * Whether to check and fetch tokenID by index, in case of non-sequential IDs.\n   *\n   * It should be set to true if it's an ERC721Enumerable contract, and has `tokenByIndex` function.\n   * In this case, the provided tokenId will be considered as token-index and actual tokenId will be fetched from the contract.\n   */\n  tokenByIndex?: boolean;\n  /**\n   * Whether to use the insight API to fetch the NFTs.\n   * @default true\n   */\n  useIndexer?: boolean;\n};\n\n/**\n * Retrieves an array of NFTs (\"ERC721\") based on the provided options.\n * @param options - The options for retrieving the NFTs.\n * @returns A promise that resolves to an array of NFTs.\n * @throws An error if the contract requires either `nextTokenIdToMint` or `totalSupply` function to determine the next token ID to mint.\n * @extension ERC721\n * @example\n * ```ts\n * import { getNFTs } from \"thirdweb/extensions/erc721\";\n * const nfts = await getNFTs({\n *  contract,\n *  start: 0,\n *  count: 10,\n * });\n * ```\n */\nexport async function getNFTs(\n  options: BaseTransactionOptions<GetNFTsParams>,\n): Promise<NFT[]> {\n  const { useIndexer = true } = options;\n  if (useIndexer) {\n    try {\n      return await getNFTsFromInsight(options);\n    } catch {\n      return await getNFTsFromRPC(options);\n    }\n  }\n  return await getNFTsFromRPC(options);\n}\n\n/**\n * Checks if the `getNFTs` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getNFTs` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isGetNFTsSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isGetNFTsSupported([\"0x...\"]);\n * ```\n */\nexport function isGetNFTsSupported(availableSelectors: string[]) {\n  return (\n    isGetNFTSupported(availableSelectors) &&\n    (isTotalSupplySupported(availableSelectors) ||\n      isNextTokenIdToMintSupported(availableSelectors))\n  );\n}\n\nasync function getNFTsFromInsight(\n  options: BaseTransactionOptions<GetNFTsParams>,\n): Promise<NFT[]> {\n  const { contract, start, count = Number(DEFAULT_QUERY_ALL_COUNT) } = options;\n\n  const [result, supplyInfo] = await Promise.all([\n    getContractNFTs({\n      chains: [contract.chain],\n      client: contract.client,\n      contractAddress: contract.address,\n      includeOwners: options.includeOwners ?? false,\n      queryOptions: {\n        limit: count,\n        page: start ? Math.floor(start / count) : undefined,\n      },\n    }),\n    getSupplyInfo(options).catch(() => ({\n      maxSupply: 0,\n      startTokenId: 0,\n    })),\n  ]);\n\n  const currentOffset = start ?? 0;\n  const expectedResultLength = Math.min(\n    count,\n    Math.max(\n      0,\n      Number(supplyInfo.maxSupply) -\n        Number(supplyInfo.startTokenId) -\n        currentOffset,\n    ),\n  );\n  if (result.length < expectedResultLength) {\n    try {\n      // fresh contracts might be delayed in indexing, so we fallback to RPC\n      // must use await here\n      return await getNFTsFromRPC(options);\n    } catch {\n      // if RPC fails, we return the result from insight\n      return result;\n    }\n  }\n\n  return result;\n}\n\nasync function getNFTsFromRPC(\n  options: BaseTransactionOptions<GetNFTsParams>,\n): Promise<NFT[]> {\n  const { startTokenId, maxSupply } = await getSupplyInfo(options);\n  const start = BigInt(options.start ?? 0) + startTokenId;\n  const count = BigInt(options.count ?? DEFAULT_QUERY_ALL_COUNT);\n  const maxId = min(maxSupply, start + count);\n  const promises: ReturnType<typeof getNFT>[] = [];\n\n  for (let i = start; i < maxId; i++) {\n    promises.push(\n      getNFT({\n        ...options,\n        includeOwner: options.includeOwners ?? false,\n        tokenId: i,\n        useIndexer: false,\n      }),\n    );\n  }\n\n  return await Promise.all(promises);\n}\n\nasync function getSupplyInfo(options: BaseTransactionOptions<GetNFTsParams>) {\n  const [startTokenId_, maxSupply] = await Promise.allSettled([\n    startTokenId(options),\n    nextTokenIdToMint(options),\n    totalSupply(options),\n  ]).then(([_startTokenId, _next, _total]) => {\n    // default to 0 if startTokenId is not available\n    const startTokenId__ =\n      _startTokenId.status === \"fulfilled\" ? _startTokenId.value : 0n;\n    let maxSupply_: bigint;\n    // prioritize nextTokenIdToMint\n    if (_next.status === \"fulfilled\") {\n      // because we always default the startTokenId to 0 we can safely just always subtract here\n      maxSupply_ = _next.value - startTokenId__;\n    }\n    // otherwise use totalSupply\n    else if (_total.status === \"fulfilled\") {\n      maxSupply_ = _total.value;\n    } else {\n      throw new Error(\n        \"Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint\",\n      );\n    }\n    return [startTokenId__, maxSupply_] as const;\n  });\n\n  return {\n    maxSupply,\n    startTokenId: startTokenId_,\n  };\n}\n", "import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0xacd083f8\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `nextTokenIdToClaim` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `nextTokenIdToClaim` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isNextTokenIdToClaimSupported } from \"thirdweb/extensions/erc721\";\n * const supported = isNextTokenIdToClaimSupported([\"0x...\"]);\n * ```\n */\nexport function isNextTokenIdToClaimSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the nextTokenIdToClaim function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeNextTokenIdToClaimResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeNextTokenIdToClaimResultResult(\"...\");\n * ```\n */\nexport function decodeNextTokenIdToClaimResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"nextTokenIdToClaim\" function on the contract.\n * @param options - The options for the nextTokenIdToClaim function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { nextTokenIdToClaim } from \"thirdweb/extensions/erc721\";\n *\n * const result = await nextTokenIdToClaim({\n *  contract,\n * });\n *\n * ```\n */\nexport async function nextTokenIdToClaim(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { nextTokenIdToClaim } from \"../__generated__/IDrop/read/nextTokenIdToClaim.js\";\nimport { startTokenId } from \"../__generated__/IERC721A/read/startTokenId.js\";\n\n/**\n * Retrieves the total claimed supply of ERC721 tokens.\n * @param options - The base transaction options.\n * @returns A promise that resolves to the total claimed supply as a bigint.\n * @throws An error if the total claimed supply cannot be retrieved.\n * @extension ERC721\n * @example\n *\n * ```ts\n * import { getTotalClaimedSupply } from \"thirdweb/extensions/erc721\";\n *\n * const totalClaimedSupply = await getTotalClaimedSupply({\n *  contract,\n * });\n * ```\n */\nexport async function getTotalClaimedSupply(\n  options: BaseTransactionOptions,\n): Promise<bigint> {\n  const [startTokenId_, nextTokenIdToClaim_] = await Promise.all([\n    startTokenId(options).catch(() => 0n),\n    nextTokenIdToClaim(options),\n  ]);\n\n  return nextTokenIdToClaim_ - startTokenId_;\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { startTokenId } from \"../__generated__/IERC721A/read/startTokenId.js\";\nimport { nextTokenIdToMint } from \"../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js\";\nimport { getTotalClaimedSupply } from \"./getTotalClaimedSupply.js\";\n\n/**\n * Retrieves the total unclaimed supply of ERC721 tokens.\n * @param options - The base transaction options.\n * @returns A promise that resolves to the total unclaimed supply as a bigint.\n * @extension ERC721\n * @example\n *\n * ```ts\n * import { getTotalUnclaimedSupply } from \"thirdweb/extensions/erc721\";\n *\n * const totalUnclaimedSupply = await getTotalUnclaimedSupply({\n *  contract,\n * });\n */\nexport async function getTotalUnclaimedSupply(\n  options: BaseTransactionOptions,\n): Promise<bigint> {\n  const [startTokenId_, nextTokenIdToMint_, totalClaimedSupply_] =\n    await Promise.all([\n      startTokenId(options).catch(() => 0n),\n      nextTokenIdToMint(options),\n      getTotalClaimedSupply(options),\n    ]);\n\n  return nextTokenIdToMint_ - startTokenId_ - totalClaimedSupply_;\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport {\n  getBaseUriFromBatch,\n  uploadOrExtractURIs,\n} from \"../../../utils/ipfs.js\";\nimport type { NFTInput } from \"../../../utils/nft/parseNft.js\";\nimport {\n  isNextTokenIdToMintSupported,\n  nextTokenIdToMint,\n} from \"../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js\";\nimport * as LazyMint from \"../__generated__/ILazyMint/write/lazyMint.js\";\n\n/**\n * @extension ERC721\n */\nexport type LazyMintParams = {\n  nfts: (NFTInput | string)[];\n};\n\n/**\n * Lazily mints ERC721 tokens.\n * This method is only available on the `DropERC721` contract.\n *\n * @param options - The options for the lazy minting process.\n * @returns A promise that resolves to the prepared contract call.\n * @extension ERC721\n * @example\n * ```ts\n * import { lazyMint } from \"thirdweb/extensions/erc721\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = lazyMint({\n *   contract,\n *   nfts: [\n *     {\n *       name: \"My NFT\",\n *       description: \"This is my NFT\",\n *       image: \"https://example.com/image.png\",\n *     },\n *   ],\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function lazyMint(options: BaseTransactionOptions<LazyMintParams>) {\n  return LazyMint.lazyMint({\n    asyncParams: async () => {\n      const startFileNumber = await nextTokenIdToMint({\n        contract: options.contract,\n      });\n\n      const batchOfUris = await uploadOrExtractURIs(\n        options.nfts,\n        options.contract.client,\n        // TODO: this is potentially unsafe since it *may* be bigger than what Number can represent, however the likelyhood is very low (fine, for now)\n        Number(startFileNumber),\n      );\n\n      const baseUri = getBaseUriFromBatch(batchOfUris);\n\n      return {\n        amount: BigInt(batchOfUris.length),\n        baseURIForTokens: baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`,\n        extraData: \"0x\",\n      } as const;\n    },\n    contract: options.contract,\n  });\n}\n\n/**\n * Checks if the `lazyMint` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `lazyMint` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isLazyMintSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isLazyMintSupported([\"0x...\"]);\n * ```\n */\nexport function isLazyMintSupported(availableSelectors: string[]) {\n  return (\n    LazyMint.isLazyMintSupported(availableSelectors) &&\n    // required because we use it in the lazyMint function\n    isNextTokenIdToMintSupported(availableSelectors)\n  );\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"mintTo\" function.\n */\nexport type MintToParams = WithOverrides<{\n  to: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"to\" }>;\n  uri: AbiParameterToPrimitiveType<{ type: \"string\"; name: \"uri\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x0075a317\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"to\",\n    type: \"address\",\n  },\n  {\n    name: \"uri\",\n    type: \"string\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `mintTo` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `mintTo` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isMintToSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isMintToSupported([\"0x...\"]);\n * ```\n */\nexport function isMintToSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"mintTo\" function.\n * @param options - The options for the mintTo function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeMintToParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeMintToParams({\n *  to: ...,\n *  uri: ...,\n * });\n * ```\n */\nexport function encodeMintToParams(options: MintToParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.to, options.uri]);\n}\n\n/**\n * Encodes the \"mintTo\" function into a Hex string with its parameters.\n * @param options - The options for the mintTo function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeMintTo } from \"thirdweb/extensions/erc721\";\n * const result = encodeMintTo({\n *  to: ...,\n *  uri: ...,\n * });\n * ```\n */\nexport function encodeMintTo(options: MintToParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeMintToParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"mintTo\" function on the contract.\n * @param options - The options for the \"mintTo\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { mintTo } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = mintTo({\n *  contract,\n *  to: ...,\n *  uri: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function mintTo(\n  options: BaseTransactionOptions<\n    | MintToParams\n    | {\n        asyncParams: () => Promise<MintToParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.to, resolvedOptions.uri] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../transaction/types.js\";\nimport type { NFTInput } from \"../../../utils/nft/parseNft.js\";\nimport { mintTo as generatedMintTo } from \"../__generated__/IMintableERC721/write/mintTo.js\";\n\nexport { isMintToSupported } from \"../__generated__/IMintableERC721/write/mintTo.js\";\n\n/**\n * @extension ERC721\n */\nexport type MintToParams = WithOverrides<{\n  to: string;\n  nft: NFTInput | string;\n}>;\n\n/**\n * Mints a new ERC721 token and assigns it to the specified address.\n * This method is only available on the `TokenERC721` contract.\n *\n * If the `nft` parameter is a string, it will be used as the token URI.\n * If the `nft` parameter is a file, it will be uploaded to the storage server and the resulting URI will be used as the token URI.\n * @param options - The transaction options.\n * @returns A promise that resolves to the transaction result.\n * @extension ERC721\n * @example\n * ```ts\n * import { mintTo } from \"thirdweb/extensions/erc721\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = mintTo({\n *  contract,\n *  to: \"0x...\",\n *  nft: {\n *    name: \"My NFT\",\n *    description: \"This is my NFT\",\n *    image: \"https://example.com/image.png\",\n *  },\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function mintTo(options: BaseTransactionOptions<MintToParams>) {\n  return generatedMintTo({\n    asyncParams: async () => {\n      let tokenUri: string;\n\n      if (typeof options.nft === \"string\") {\n        // if the input is already a string then we just use that\n        tokenUri = options.nft;\n      } else {\n        // otherwise we need to upload the file to the storage server\n\n        // load the upload code if we need it\n        const { upload } = await import(\"../../../storage/upload.js\");\n        tokenUri = await upload({\n          client: options.contract.client,\n          files: [options.nft],\n        });\n      }\n      return {\n        overrides: options.overrides,\n        to: options.to,\n        uri: tokenUri,\n      } as const;\n    },\n    contract: options.contract,\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"setSharedMetadata\" function.\n */\nexport type SetSharedMetadataParams = WithOverrides<{\n  metadata: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"_metadata\";\n    components: [\n      { type: \"string\"; name: \"name\" },\n      { type: \"string\"; name: \"description\" },\n      { type: \"string\"; name: \"imageURI\" },\n      { type: \"string\"; name: \"animationURI\" },\n    ];\n  }>;\n}>;\n\nexport const FN_SELECTOR = \"0xa7d27d9d\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"name\",\n        type: \"string\",\n      },\n      {\n        name: \"description\",\n        type: \"string\",\n      },\n      {\n        name: \"imageURI\",\n        type: \"string\",\n      },\n      {\n        name: \"animationURI\",\n        type: \"string\",\n      },\n    ],\n    name: \"_metadata\",\n    type: \"tuple\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `setSharedMetadata` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `setSharedMetadata` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isSetSharedMetadataSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isSetSharedMetadataSupported([\"0x...\"]);\n * ```\n */\nexport function isSetSharedMetadataSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"setSharedMetadata\" function.\n * @param options - The options for the setSharedMetadata function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeSetSharedMetadataParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeSetSharedMetadataParams({\n *  metadata: ...,\n * });\n * ```\n */\nexport function encodeSetSharedMetadataParams(\n  options: SetSharedMetadataParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.metadata]);\n}\n\n/**\n * Encodes the \"setSharedMetadata\" function into a Hex string with its parameters.\n * @param options - The options for the setSharedMetadata function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeSetSharedMetadata } from \"thirdweb/extensions/erc721\";\n * const result = encodeSetSharedMetadata({\n *  metadata: ...,\n * });\n * ```\n */\nexport function encodeSetSharedMetadata(options: SetSharedMetadataParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeSetSharedMetadataParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"setSharedMetadata\" function on the contract.\n * @param options - The options for the \"setSharedMetadata\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { setSharedMetadata } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = setSharedMetadata({\n *  contract,\n *  metadata: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function setSharedMetadata(\n  options: BaseTransactionOptions<\n    | SetSharedMetadataParams\n    | {\n        asyncParams: () => Promise<SetSharedMetadataParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.metadata] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport type { NFTInput } from \"../../../utils/nft/parseNft.js\";\nimport { setSharedMetadata as generatedSharedMetadata } from \"../__generated__/ISharedMetadata/write/setSharedMetadata.js\";\n\nexport { isSetSharedMetadataSupported } from \"../__generated__/ISharedMetadata/write/setSharedMetadata.js\";\n\n/**\n * @extension ERC721\n */\nexport type SetSharedMetadataParams = {\n  nft: NFTInput;\n};\n\n/**\n * Sets the shared metadata for a OpenEdition contract.\n * @param options - The options for the transaction.\n * @returns The prepared transaction.\n * @extension ERC721\n */\nexport function setSharedMetadata(\n  options: BaseTransactionOptions<SetSharedMetadataParams>,\n) {\n  return generatedSharedMetadata({\n    asyncParams: async () => {\n      if (!options.nft.name) {\n        throw new Error(\"NFT name is required\");\n      }\n\n      const batch: Promise<string>[] = [\n        // image URI resolution\n        (async () => {\n          if (!options.nft.image) {\n            return \"\";\n          }\n          if (typeof options.nft.image === \"string\") {\n            return options.nft.image;\n          }\n          const { upload } = await import(\"../../../storage/upload.js\");\n          return await upload({\n            client: options.contract.client,\n            files: [options.nft.image],\n          });\n        })(),\n        // animation URI resolution\n        (async () => {\n          if (!options.nft.animation_url) {\n            return \"\";\n          }\n          if (typeof options.nft.animation_url === \"string\") {\n            return options.nft.animation_url;\n          }\n          const { upload } = await import(\"../../../storage/upload.js\");\n          return await upload({\n            client: options.contract.client,\n            files: [options.nft.animation_url],\n          });\n        })(),\n      ];\n\n      const [imageURI, animationURI] = await Promise.all(batch);\n\n      return {\n        metadata: {\n          animationURI: animationURI ?? \"\",\n          description: sanitizeJSONString(options.nft.description) ?? \"\",\n          imageURI: imageURI ?? \"\",\n          name: options.nft.name,\n        },\n      };\n    },\n    contract: options.contract,\n  });\n}\n\nfunction sanitizeJSONString(val: string | undefined | null) {\n  if (!val) {\n    return val;\n  }\n  const sanitized = JSON.stringify(val);\n  return sanitized.slice(1, sanitized.length - 1);\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"mintWithSignature\" function.\n */\nexport type MintWithSignatureParams = WithOverrides<{\n  payload: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"payload\";\n    components: [\n      { type: \"address\"; name: \"to\" },\n      { type: \"address\"; name: \"royaltyRecipient\" },\n      { type: \"uint256\"; name: \"royaltyBps\" },\n      { type: \"address\"; name: \"primarySaleRecipient\" },\n      { type: \"string\"; name: \"uri\" },\n      { type: \"uint256\"; name: \"price\" },\n      { type: \"address\"; name: \"currency\" },\n      { type: \"uint128\"; name: \"validityStartTimestamp\" },\n      { type: \"uint128\"; name: \"validityEndTimestamp\" },\n      { type: \"bytes32\"; name: \"uid\" },\n    ];\n  }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x2c4510f8\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        name: \"royaltyRecipient\",\n        type: \"address\",\n      },\n      {\n        name: \"royaltyBps\",\n        type: \"uint256\",\n      },\n      {\n        name: \"primarySaleRecipient\",\n        type: \"address\",\n      },\n      {\n        name: \"uri\",\n        type: \"string\",\n      },\n      {\n        name: \"price\",\n        type: \"uint256\",\n      },\n      {\n        name: \"currency\",\n        type: \"address\",\n      },\n      {\n        name: \"validityStartTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"validityEndTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"uid\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"payload\",\n    type: \"tuple\",\n  },\n  {\n    name: \"signature\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"tokenIdMinted\",\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `mintWithSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `mintWithSignature` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isMintWithSignatureSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isMintWithSignatureSupported([\"0x...\"]);\n * ```\n */\nexport function isMintWithSignatureSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"mintWithSignature\" function.\n * @param options - The options for the mintWithSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeMintWithSignatureParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeMintWithSignatureParams({\n *  payload: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeMintWithSignatureParams(\n  options: MintWithSignatureParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.payload, options.signature]);\n}\n\n/**\n * Encodes the \"mintWithSignature\" function into a Hex string with its parameters.\n * @param options - The options for the mintWithSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeMintWithSignature } from \"thirdweb/extensions/erc721\";\n * const result = encodeMintWithSignature({\n *  payload: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeMintWithSignature(options: MintWithSignatureParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeMintWithSignatureParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"mintWithSignature\" function on the contract.\n * @param options - The options for the \"mintWithSignature\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { mintWithSignature } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = mintWithSignature({\n *  contract,\n *  payload: ...,\n *  signature: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function mintWithSignature(\n  options: BaseTransactionOptions<\n    | MintWithSignatureParams\n    | {\n        asyncParams: () => Promise<MintWithSignatureParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.payload, resolvedOptions.signature] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"mintWithSignature\" function.\n */\nexport type MintWithSignatureParams = WithOverrides<{\n  payload: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"payload\";\n    components: [\n      { type: \"address\"; name: \"to\" },\n      { type: \"address\"; name: \"royaltyRecipient\" },\n      { type: \"uint256\"; name: \"royaltyBps\" },\n      { type: \"address\"; name: \"primarySaleRecipient\" },\n      { type: \"string\"; name: \"uri\" },\n      { type: \"uint256\"; name: \"quantity\" },\n      { type: \"uint256\"; name: \"pricePerToken\" },\n      { type: \"address\"; name: \"currency\" },\n      { type: \"uint128\"; name: \"validityStartTimestamp\" },\n      { type: \"uint128\"; name: \"validityEndTimestamp\" },\n      { type: \"bytes32\"; name: \"uid\" },\n    ];\n  }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x439c7be5\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        name: \"royaltyRecipient\",\n        type: \"address\",\n      },\n      {\n        name: \"royaltyBps\",\n        type: \"uint256\",\n      },\n      {\n        name: \"primarySaleRecipient\",\n        type: \"address\",\n      },\n      {\n        name: \"uri\",\n        type: \"string\",\n      },\n      {\n        name: \"quantity\",\n        type: \"uint256\",\n      },\n      {\n        name: \"pricePerToken\",\n        type: \"uint256\",\n      },\n      {\n        name: \"currency\",\n        type: \"address\",\n      },\n      {\n        name: \"validityStartTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"validityEndTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"uid\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"payload\",\n    type: \"tuple\",\n  },\n  {\n    name: \"signature\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"signer\",\n    type: \"address\",\n  },\n] as const;\n\n/**\n * Checks if the `mintWithSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `mintWithSignature` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isMintWithSignatureSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = isMintWithSignatureSupported([\"0x...\"]);\n * ```\n */\nexport function isMintWithSignatureSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"mintWithSignature\" function.\n * @param options - The options for the mintWithSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeMintWithSignatureParams } from \"thirdweb/extensions/erc721\";\n * const result = encodeMintWithSignatureParams({\n *  payload: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeMintWithSignatureParams(\n  options: MintWithSignatureParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.payload, options.signature]);\n}\n\n/**\n * Encodes the \"mintWithSignature\" function into a Hex string with its parameters.\n * @param options - The options for the mintWithSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeMintWithSignature } from \"thirdweb/extensions/erc721\";\n * const result = encodeMintWithSignature({\n *  payload: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeMintWithSignature(options: MintWithSignatureParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeMintWithSignatureParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"mintWithSignature\" function on the contract.\n * @param options - The options for the \"mintWithSignature\" function.\n * @returns A prepared transaction object.\n * @extension ERC721\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { mintWithSignature } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = mintWithSignature({\n *  contract,\n *  payload: ...,\n *  signature: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function mintWithSignature(\n  options: BaseTransactionOptions<\n    | MintWithSignatureParams\n    | {\n        asyncParams: () => Promise<MintWithSignatureParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.payload, resolvedOptions.signature] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { AbiParameterToPrimitiveType, Address } from \"abitype\";\nimport { type Hex, isHex, stringToHex } from \"viem\";\nimport {\n  isNativeTokenAddress,\n  NATIVE_TOKEN_ADDRESS,\n} from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { dateToSeconds, tenYearsFromNow } from \"../../../utils/date.js\";\nimport type { NFTInput } from \"../../../utils/nft/parseNft.js\";\nimport { randomBytesHex } from \"../../../utils/random.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport {\n  mintWithSignature as generatedMintWithSignature,\n  type MintWithSignatureParams,\n} from \"../__generated__/ISignatureMintERC721/write/mintWithSignature.js\";\nimport {\n  mintWithSignature as generatedMintWithSignatureV2,\n  type MintWithSignatureParams as MintWithSignatureParamsV2,\n} from \"../__generated__/ISignatureMintERC721_v2/write/mintWithSignature.js\";\n\n/**\n * Mints a new ERC721 token with the given minter signature\n * This method is only available on the `TokenERC721` contract.\n *\n * @param options - The transaction options.\n * @example\n * ```ts\n * import { mintWithSignature, generateMintSignature } from \"thirdweb/extensions/erc721\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { payload, signature } = await generateMintSignature(...)\n *\n * const transaction = mintWithSignature({\n *   contract,\n *   payload,\n *   signature,\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n * @extension ERC721\n * @returns A promise that resolves to the transaction result.\n */\nexport function mintWithSignature(\n  options: BaseTransactionOptions<\n    | { payload: PayloadTypeV2; signature: Hex }\n    | { payload: PayloadType; signature: Hex }\n  >,\n) {\n  const { payload } = options;\n  if (\"quantity\" in payload) {\n    return mintWithSignatureV2(\n      options as BaseTransactionOptions<MintWithSignatureParamsV2>,\n    );\n  }\n  return mintWithSignatureV1(\n    options as BaseTransactionOptions<MintWithSignatureParams>,\n  );\n}\n\nfunction mintWithSignatureV1(\n  options: BaseTransactionOptions<MintWithSignatureParams>,\n) {\n  const value = isNativeTokenAddress(options.payload.currency)\n    ? options.payload.price\n    : 0n;\n  return generatedMintWithSignature({\n    ...options,\n    overrides: {\n      value,\n    },\n  });\n}\n\nfunction mintWithSignatureV2(\n  options: BaseTransactionOptions<MintWithSignatureParamsV2>,\n) {\n  const value = isNativeTokenAddress(options.payload.currency)\n    ? options.payload.pricePerToken * options.payload.quantity\n    : 0n;\n  return generatedMintWithSignatureV2({\n    ...options,\n    overrides: {\n      value,\n    },\n  });\n}\n\nexport type GenerateMintSignatureOptions<\n  T extends \"LoyaltyCard\" | \"TokenERC721\" = \"TokenERC721\",\n> = {\n  account: Account;\n  contract: ThirdwebContract;\n  mintRequest: GeneratePayloadInput;\n  contractType?: T;\n};\n\n/**\n * Generates the payload and signature for minting an ERC721 token.\n * @param options - The options for the minting process.\n * @example\n * ```ts\n * import { mintWithSignature, generateMintSignature } from \"thirdweb/extensions/erc721\";\n *\n * const { payload, signature } = await generateMintSignature({\n *   account,\n *   contract,\n *   mintRequest: {\n *     to: \"0x...\",\n *     metadata: {\n *       name: \"My NFT\",\n *       description: \"This is my NFT\",\n *       image: \"https://example.com/image.png\",\n *     },\n *   },\n * });\n *\n * const transaction = mintWithSignature({\n *   contract,\n *   payload,\n *   signature,\n * });\n * await sendTransaction({ transaction, account });\n * ```\n * @extension ERC721\n * @returns A promise that resolves to the payload and signature.\n */\nexport async function generateMintSignature<\n  T extends \"LoyaltyCard\" | \"TokenERC721\" = \"TokenERC721\",\n>(options: GenerateMintSignatureOptions<T>): Promise<SignPayloadResult<T>> {\n  const { mintRequest, account, contract, contractType } = options;\n\n  const currency = mintRequest.currency || NATIVE_TOKEN_ADDRESS;\n  const [price, uri, uid] = await Promise.all([\n    // price per token in wei\n    (async () => {\n      // if priceInWei is provided, use it\n      if (\"priceInWei\" in mintRequest && mintRequest.priceInWei) {\n        return mintRequest.priceInWei;\n      }\n      // if price is provided, convert it to wei\n      if (\"price\" in mintRequest && mintRequest.price) {\n        const { convertErc20Amount } = await import(\n          \"../../../utils/extensions/convert-erc20-amount.js\"\n        );\n        return await convertErc20Amount({\n          amount: mintRequest.price,\n          chain: contract.chain,\n          client: contract.client,\n          erc20Address: currency,\n        });\n      }\n      // if neither price nor priceInWei is provided, default to 0\n      return 0n;\n    })(),\n    // uri\n    (async () => {\n      if (\"metadata\" in mintRequest) {\n        if (typeof mintRequest.metadata === \"object\") {\n          // async import the upload function because it is not always required\n          const { upload } = await import(\"../../../storage/upload.js\");\n          return await upload({\n            client: options.contract.client,\n            files: [mintRequest.metadata],\n          });\n        }\n        return mintRequest.metadata;\n      }\n      return \"\";\n    })(),\n    // uid computation\n    ((): Hex => {\n      if (mintRequest.uid) {\n        return isHex(mintRequest.uid)\n          ? mintRequest.uid\n          : stringToHex(mintRequest.uid, { size: 32 });\n      }\n      return randomBytesHex();\n    })(),\n  ]);\n\n  const startTime = mintRequest.validityStartTimestamp || new Date(0);\n  const endTime = mintRequest.validityEndTimestamp || tenYearsFromNow();\n\n  let saleRecipient: Address;\n  if (\n    mintRequest.primarySaleRecipient?.length === 0 ||\n    !mintRequest.primarySaleRecipient\n  ) {\n    const { primarySaleRecipient } = await import(\n      \"../../common/__generated__/IPrimarySale/read/primarySaleRecipient.js\"\n    );\n    saleRecipient = await primarySaleRecipient({\n      contract,\n    });\n  } else {\n    saleRecipient = mintRequest.primarySaleRecipient;\n  }\n\n  let royaltyRecipient: Address;\n  if (\n    mintRequest.royaltyRecipient?.length === 0 ||\n    !mintRequest.royaltyRecipient\n  ) {\n    const { getDefaultRoyaltyInfo } = await import(\n      \"../../common/__generated__/IRoyalty/read/getDefaultRoyaltyInfo.js\"\n    );\n    const royaltyInfo = await getDefaultRoyaltyInfo({\n      contract,\n    });\n    royaltyRecipient = royaltyInfo[0];\n  } else {\n    royaltyRecipient = mintRequest.royaltyRecipient;\n  }\n\n  if (contractType === \"LoyaltyCard\") {\n    return signPayloadV2({\n      account,\n      contract,\n      currency,\n      endTime,\n      mintRequest,\n      price,\n      primarySaleRecipient: saleRecipient,\n      royaltyRecipient,\n      startTime,\n      uid,\n      uri,\n    }) as Promise<SignPayloadResult<T>>;\n  }\n  return signPayloadV1({\n    account,\n    contract,\n    currency,\n    endTime,\n    mintRequest,\n    price,\n    primarySaleRecipient: saleRecipient,\n    royaltyRecipient,\n    startTime,\n    uid,\n    uri,\n  }) as Promise<SignPayloadResult<T>>;\n}\n\nasync function signPayloadV1({\n  mintRequest,\n  account,\n  contract,\n  uri,\n  currency,\n  uid,\n  price,\n  royaltyRecipient,\n  primarySaleRecipient,\n  startTime,\n  endTime,\n}: {\n  mintRequest: GeneratePayloadInput;\n  account: Account;\n  contract: ThirdwebContract;\n  uri: string;\n  currency: Address;\n  uid: Hex;\n  price: bigint;\n  royaltyRecipient: Address;\n  primarySaleRecipient: Address;\n  startTime: Date;\n  endTime: Date;\n}): Promise<{ payload: PayloadType; signature: Hex }> {\n  const payload: PayloadType = {\n    currency,\n    price,\n    primarySaleRecipient,\n    royaltyBps: toBigInt(mintRequest.royaltyBps || 0),\n    royaltyRecipient,\n    to: mintRequest.to,\n    uid,\n    uri,\n    validityEndTimestamp: dateToSeconds(endTime),\n    validityStartTimestamp: dateToSeconds(startTime),\n  };\n\n  const signature = await account.signTypedData({\n    domain: {\n      chainId: contract.chain.id,\n      name: \"TokenERC721\",\n      verifyingContract: contract.address,\n      version: \"1\",\n    },\n    message: payload,\n    primaryType: \"MintRequest\",\n    types: {\n      MintRequest: MintRequest721,\n    },\n  });\n  return { payload, signature };\n}\n\nasync function signPayloadV2({\n  mintRequest,\n  account,\n  contract,\n  uri,\n  currency,\n  uid,\n  price,\n  royaltyRecipient,\n  primarySaleRecipient,\n  startTime,\n  endTime,\n}: {\n  mintRequest: GeneratePayloadInput;\n  account: Account;\n  contract: ThirdwebContract;\n  uri: string;\n  currency: Address;\n  uid: Hex;\n  price: bigint;\n  royaltyRecipient: Address;\n  primarySaleRecipient: Address;\n  startTime: Date;\n  endTime: Date;\n}): Promise<{ payload: PayloadTypeV2; signature: Hex }> {\n  const payload: PayloadTypeV2 = {\n    currency,\n    pricePerToken: price,\n    primarySaleRecipient,\n    quantity: toBigInt(1), // always 1 for 721 NFTs\n    royaltyBps: toBigInt(mintRequest.royaltyBps || 0),\n    royaltyRecipient,\n    to: mintRequest.to,\n    uid,\n    uri,\n    validityEndTimestamp: dateToSeconds(endTime),\n    validityStartTimestamp: dateToSeconds(startTime),\n  };\n\n  const signature = await account.signTypedData({\n    domain: {\n      chainId: contract.chain.id,\n      name: \"SignatureMintERC721\",\n      verifyingContract: contract.address,\n      version: \"1\",\n    },\n    message: payload,\n    primaryType: \"MintRequest\",\n    types: {\n      MintRequest: MintRequest721_V2,\n    },\n  });\n  return { payload, signature };\n}\n\ntype SignPayloadResult<T> = T extends \"LoyaltyCard\"\n  ? Awaited<ReturnType<typeof signPayloadV2>>\n  : Awaited<ReturnType<typeof signPayloadV1>>;\n\ntype PayloadType = AbiParameterToPrimitiveType<{\n  type: \"tuple\";\n  name: \"payload\";\n  components: typeof MintRequest721;\n}>;\n\ntype PayloadTypeV2 = AbiParameterToPrimitiveType<{\n  type: \"tuple\";\n  name: \"payload\";\n  components: typeof MintRequest721_V2;\n}>;\n\ntype GeneratePayloadInput = {\n  to: string;\n  metadata: NFTInput | string;\n  royaltyRecipient?: Address;\n  royaltyBps?: number;\n  primarySaleRecipient?: Address;\n  price?: string;\n  priceInWei?: bigint;\n  currency?: Address;\n  validityStartTimestamp?: Date;\n  validityEndTimestamp?: Date;\n  uid?: string;\n};\n\nconst MintRequest721 = [\n  { name: \"to\", type: \"address\" },\n  { name: \"royaltyRecipient\", type: \"address\" },\n  { name: \"royaltyBps\", type: \"uint256\" },\n  { name: \"primarySaleRecipient\", type: \"address\" },\n  { name: \"uri\", type: \"string\" },\n  { name: \"price\", type: \"uint256\" },\n  { name: \"currency\", type: \"address\" },\n  { name: \"validityStartTimestamp\", type: \"uint128\" },\n  { name: \"validityEndTimestamp\", type: \"uint128\" },\n  { name: \"uid\", type: \"bytes32\" },\n] as const;\n\n// used for LoyaltyCard contract and base sigmint contracts\n// adds quantity to the payload so its the same as 1155\nconst MintRequest721_V2 = [\n  { name: \"to\", type: \"address\" },\n  { name: \"royaltyRecipient\", type: \"address\" },\n  { name: \"royaltyBps\", type: \"uint256\" },\n  { name: \"primarySaleRecipient\", type: \"address\" },\n  { name: \"uri\", type: \"string\" },\n  { name: \"quantity\", type: \"uint256\" },\n  { name: \"pricePerToken\", type: \"uint256\" },\n  { name: \"currency\", type: \"address\" },\n  { name: \"validityStartTimestamp\", type: \"uint128\" },\n  { name: \"validityEndTimestamp\", type: \"uint128\" },\n  { name: \"uid\", type: \"bytes32\" },\n] as const;\n", "import { upload } from \"../../../storage/upload.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport type { NFTInput } from \"../../../utils/nft/parseNft.js\";\nimport {\n  type SetTokenURIParams,\n  setTokenURI,\n} from \"../../erc721/__generated__/INFTMetadata/write/setTokenURI.js\";\n\nexport { isSetTokenURISupported as isUpdateTokenURISupported } from \"../../erc721/__generated__/INFTMetadata/write/setTokenURI.js\";\n\n/**\n * @extension ERC721\n */\nexport type UpdateTokenURIParams = {\n  tokenId: bigint;\n  newMetadata: NFTInput;\n};\n\n/**\n * This function is an abstracted layer of the [`setTokenURI` extension](https://portal.thirdweb.com/references/typescript/v5/erc721/setTokenURI),\n * which means it uses `setTokenURI` under the hood.\n * While the `setTokenURI` method only takes in a uri string, this extension takes in a user-friendly [`NFTInput`](https://portal.thirdweb.com/references/typescript/v5/NFTInput),\n * upload that content to IPFS and pass the IPFS URI (of said `NFTInput`) to the underlying `setTokenURI` method.\n *\n * This extension does not validate the NFTInput so make sure you are passing the proper content that you want to update.\n * This method is only available on the `TokenERC721` contract.\n *\n * @extension ERC721\n * @returns the prepared transaction from `setTokenURI`\n * @example\n * ```ts\n * import { updateTokenURI } from \"thirdweb/extensions/erc721\";\n *\n * const transaction = updateTokenURI({\n *   tokenId: 0n,\n *   nft: {\n *     name: \"new name\",\n *     description: \"new description\",\n *     image: \"https://image-host.com/new-image.png\",\n *   },\n * });\n * ```\n */\nexport function updateTokenURI(\n  options: BaseTransactionOptions<UpdateTokenURIParams>,\n) {\n  const { contract } = options;\n  return setTokenURI({\n    asyncParams: async () => getUpdateTokenParams(options),\n    contract,\n  });\n}\n\n/**\n * @internal\n */\nasync function getUpdateTokenParams(\n  options: BaseTransactionOptions<UpdateTokenURIParams>,\n): Promise<SetTokenURIParams> {\n  const { tokenId, newMetadata } = options;\n  const batch: Promise<string>[] = [\n    // image URI resolution\n    (async () => {\n      if (!newMetadata.image) {\n        return \"\";\n      }\n      if (typeof newMetadata.image === \"string\") {\n        return newMetadata.image;\n      }\n      return await upload({\n        client: options.contract.client,\n        files: [newMetadata.image],\n      });\n    })(),\n    // animation URI resolution\n    (async () => {\n      if (!newMetadata.animation_url) {\n        return \"\";\n      }\n      if (typeof newMetadata.animation_url === \"string\") {\n        return newMetadata.animation_url;\n      }\n      return await upload({\n        client: options.contract.client,\n        files: [newMetadata.animation_url],\n      });\n    })(),\n  ];\n\n  const [imageURI, animationURI] = await Promise.all(batch);\n  if (newMetadata.image && imageURI) {\n    newMetadata.image = imageURI;\n  }\n  if (newMetadata.animation_url && animationURI) {\n    newMetadata.animation_url = animationURI;\n  }\n\n  const uri = await upload({\n    client: options.contract.client,\n    files: [newMetadata],\n  });\n  return { tokenId, uri };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBO,IAAM,cAAc;AAC3B,IAAM,YAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAM,aAAa,CAAA;AAcb,SAAU,gBAAgB,oBAA4B;AAC1D,SAAO,aAAa;IAClB;IACA,QAAQ,CAAC,aAAa,WAAW,UAAU;GAC5C;AACH;AA6DM,SAAU,KACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AApHzB;AAoH6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AArHhC;AAsHO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAxHzB;AAwH6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAzHvB;AAyH2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AA1HlB;AA0HsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AA3HvB;AA2H2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AA5H3B;AA4H+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AA7HnC;AA8HO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAAC,aAAa,WAAW,UAAU;IAC3C,OAAO,YAAS;AAhIpB;AAgIwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,OAAO;IACjC;IACA,OAAO,YAAS;AArIpB;AAqIwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;ACtGM,SAAU,sBACd,UAAwC,CAAA,GAAE;AAE1C,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;ACvBM,SAAU,8BAA2B;AACzC,SAAO,aAAa;IAClB,WACE;GACH;AACH;;;ACsBM,SAAU,mBAAmB,UAAqC,CAAA,GAAE;AACxE,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;ACNM,SAAU,cAAc,UAAgC,CAAA,GAAE;AAC9D,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;ACZM,SAAU,oBAAoB,UAAsC,CAAA,GAAE;AAC1E,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;ACAM,SAAU,cAAc,UAAgC,CAAA,GAAE;AAC9D,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;AC9CO,IAAMA,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAoDV,eAAsB,aAAa,SAA+B;AAChE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;AC9DO,IAAMC,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAeJ,SAAU,uBAAuB,oBAA4B;AACjE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,cAAaC,YAAWC,WAAU;GAC5C;AACH;AAgCA,eAAsB,YAAY,SAA+B;AAC/D,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;AClDO,IAAMC,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa,CAAA;AAmFb,SAAU,QACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AA5HzB;AA4H6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AA7HhC;AA8HO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAhIzB;AAgI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAjIvB;AAiI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAlIlB;AAkIsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAnIvB;AAmI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AApI3B;AAoI+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AArInC;AAsIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,OAAO,YAAS;AAxIpB;AAwIwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,IAAI,gBAAgB,OAAO;IACrD;IACA,OAAO,YAAS;AA7IpB;AA6IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AC7HO,IAAMC,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa,CAAA;AA4Fb,SAAU,aACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AA1IzB;AA0I6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AA3IhC;AA4IO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AA9IzB;AA8I6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AA/IvB;AA+I2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAhJlB;AAgJsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAjJvB;AAiJ2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAlJ3B;AAkJ+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAnJnC;AAoJO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,OAAO,YAAS;AAtJpB;AAsJwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO;QACL,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;;IAEpB;IACA,OAAO,YAAS;AA/JpB;AA+JwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AC5JO,IAAMC,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;;;AAeJ,SAAU,6BAA6B,oBAA4B;AACvE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,cAAaC,YAAWC,WAAU;GAC5C;AACH;AAgCA,eAAsB,kBAAkB,SAA+B;AACrE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;AClCM,SAAU,sBACd,UAAwC,CAAA,GAAE;AAE1C,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;ACxBO,IAAMC,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa,CAAA;AAcb,SAAU,uBAAuB,oBAA4B;AACjE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,cAAaC,YAAWC,WAAU;GAC5C;AACH;AAkEM,SAAU,YACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AA9HzB;AA8H6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AA/HhC;AAgIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAlIzB;AAkI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAnIvB;AAmI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AApIlB;AAoIsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AArIvB;AAqI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAtI3B;AAsI+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAvInC;AAwIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,OAAO,YAAS;AA1IpB;AA0IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,SAAS,gBAAgB,GAAG;IACtD;IACA,OAAO,YAAS;AA/IpB;AA+IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AC/HM,SAAU,6BAA0B;AACxC,SAAO,aAAa;IAClB,WACE;GACH;AACH;;;AClBO,IAAMC,eAAc;AAC3B,IAAMC,aAAY,CAAA;AAClB,IAAMC,cAAa;EACjB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAeJ,SAAU,0BAA0B,oBAA4B;AACpE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,cAAaC,YAAWC,WAAU;GAC5C;AACH;AAgCA,eAAsB,eAAe,SAA+B;AAClE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACnCM,SAAU,+BACd,UAAiD,CAAA,GAAE;AAEnD,SAAO,aAAa;IAClB;IACA,WACE;GACH;AACH;;;ACnBO,IAAMC,eAAc;AAC3B,IAAMC,aAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;;AAGV,IAAMC,cAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAkHV,eAAsB,YACpB,SAAkD;AAElD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,cAAaC,YAAWC,WAAU;IAC3C,QAAQ;MACN,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;;GAEX;AACH;;;AChLA,eAAsB,SACpB,SAA+C;AAE/C,QAAM,CAAC,aAAa,EAAE,UAAU,UAAU,eAAe,eAAc,CAAE,IACvE,MAAM,QAAQ,IAAI;IAChB,0BAA0B;MACxB,UAAU,QAAQ;KACnB;IACD,eAAe;MACb,UAAU,QAAQ;MAClB,MAAM,QAAQ;MACd,UAAU,QAAQ;MAClB,IAAI,QAAQ;MACZ,MAAM;KACP;GACF;AACH,MAAI;AACF,UAAM,YAAY;MAChB;MACA,SAAS,QAAQ;MACjB;MACA,UAAU,QAAQ;MAClB;MACA;MACA;KACD;AACD,WAAO;MACL,QAAQ;;EAEZ,SAAS,OAAO;AACd,WAAO;MACL,QAAQ,MAAM,mBAAmB,EAAE,UAAU,QAAQ,UAAU,MAAK,CAAE;MACtE,QAAQ;;EAEZ;AACF;;;ACjEO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY,CAAA;AAClB,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAeJ,SAAU,0BAA0B,oBAA4B;AACpE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAgCA,eAAsB,eAAe,SAA+B;AAClE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACrDA,eAAsB,mBACpB,SAA+B;AAE/B,MAAI;AACF,UAAM,CAAC,SAAS,KAAK,IAAI,MAAiB,eAAe,OAAO;AAEhE,UAAM,oBAEF,CAAA;AACJ,aAAS,IAAI,SAAS,IAAI,UAAU,OAAO,KAAK;AAC9C,wBAAkB,KACN,sBAAsB;QAC9B,GAAG;QACH,aAAa;OACd,CAAC;IAEN;AACA,WAAO,QAAQ,IAAI,iBAAiB;EACtC,QAAQ;AACN,UAAM,IAAI,MAAM,2BAA2B;EAC7C;AACF;AAcM,SAAU,8BAA8B,oBAA4B;AAExE,SACa,0BAA0B,kBAAkB,KAC7C,iCAAiC,kBAAkB;AAEjE;;;AC5CO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAgBJ,SAAU,qBAAqB,oBAA4B;AAC/D,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AA+DM,SAAU,UACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AA3HzB;AA2H6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AA5HhC;AA6HO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AA/HzB;AA+H6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAhIvB;AAgI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAjIlB;AAiIsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAlIvB;AAkI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAnI3B;AAmI+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AApInC;AAqIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AAvIpB;AAuIwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,IAAI;IAC9B;IACA,OAAO,YAAS;AA5IpB;AA4IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;ACjGM,SAAU,aACd,SAAmD;AAEnD,SAAO,UAAU;IACf,aAAa,MAAM,sBAAsB,OAAO;IAChD,UAAU,QAAQ;IAClB,WAAW,QAAQ;GACpB;AACH;AAKA,eAAe,sBACb,SAAmD;AA3DrD;AA6DE,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,QAAQ,KAAK;AAC/C,QAAI,GAAC,aAAQ,QAAQ,CAAC,MAAjB,mBAAoB,WAAU;AACjC,YAAM,IAAI,MAAM,wBAAwB,CAAC,4BAA4B;IACvE;AACA,QAAI,GAAC,aAAQ,QAAQ,CAAC,MAAjB,mBAAoB,KAAI;AAC3B,YAAM,IAAI,MACR,wBAAwB,CAAC,sCAAsC;IAEnE;EACF;AACA,QAAM,UAAU,qBAAqB,QAAQ,OAAO;AACpD,QAAM,OAAO,MAAM,QAAQ,IACzB,QAAQ,IAAI,OAAO,SAAQ;AACzB,UAAM,cAAc,MAAM,eAAe;MACvC,UAAU,QAAQ;MAClB,MAAM,QAAQ;MACd,UAAU,KAAK;MACf,IAAI,KAAK;MACT,MAAM;KACP;AAED,WAAO,YAAY;MACjB,gBAAgB,YAAY;MAC5B,UAAU,YAAY;MACtB,MAAM,YAAY;MAClB,WAAW,YAAY;MACvB,eAAe,YAAY;MAC3B,UAAU,YAAY;MACtB,UAAU,YAAY;KACvB;EACH,CAAC,CAAC;AAGJ,SAAO,EAAE,KAAI;AACf;AA2BM,SAAU,qBACd,SAAiD;AAEjD,QAAM,UAAoD,CAAA;AAC1D,UAAQ,QAAQ,CAAC,MAAM,UAAS;AAC9B,UAAM,eAAe,QAAQ,GAAG,EAAE;AAClC,QACE,QAAQ,KACR,gBACA,KAAK,GAAG,YAAW,MAAO,aAAa,GAAG,YAAW,GACrD;AACA,cAAQ,QAAQ,SAAS,CAAC,IAAI;QAC5B,UAAU,KAAK,WAAW,aAAa;QACvC,IAAI,KAAK;;IAEb,OAAO;AACL,cAAQ,KAAK,IAAI;IACnB;EACF,CAAC;AACD,SAAO;AACT;;;ACjHM,SAAU,sBAAsB,SAA+B;AAEnE,SAAO,mBAAmB;IACxB,aAAa,YAAW;AAEtB,YAAM,qBAAqB,MAAM,mBAAmB,OAAO;AAG3D,aAAO;;QAEL,QAAQ;QAMR,uBAAuB;;IAE3B;IACA,UAAU,QAAQ;GACnB;AACH;AAcM,SAAU,iCAAiC,oBAA4B;AAC3E,SACE,8BAA8B,kBAAkB,KAChD,8BAA8B,kBAAkB;AAEpD;;;ACzDA,eAAsB,oBAAoB,SAYzC;AACC,QAAM,cAAc,QAAQ,aAAa;AACzC,QAAM,eAAe,QAAQ,gBAAgB;AAE7C,QAAM,SAA0C,CAAA;AAChD,aAAW,iBAAiB,QAAQ,WAAW;AAC7C,UAAM,QAAQ,cAAc,QACzB,MAAM,GAAG,IAAI,YAAY,EACzB,YAAW;AACd,QAAI,OAAO,KAAK,MAAM,QAAW;AAC/B,aAAO,KAAK,IAAI,CAAA;IAClB;AAEA,WAAO,KAAK,EAAG,KAAK,aAAa;EACnC;AAEA,QAAM,WAAW,MAAM,QAAQ,IAC7B,OAAO,QAAQ,MAAM,EAAE,IAAI,OAAO,CAAC,OAAO,OAAO,MAAM;IACrD;IACA,IAAI,WACF,MAAM,QAAQ,IACZ,QAAQ,IAAI,OAAO,UAAS;AAC1B,aAAO,YAAY;QACjB,OAAO,QAAQ;QACf,QAAQ,QAAQ;QAChB;QACA,eAAe,QAAQ;OACxB;IACH,CAAC,CAAC,CACH,EACD,WAAU;GACb,CAAC;AAGJ,QAAM,QAA6B,OAAO,YAAY,QAAQ;AAC9D,QAAM,OAAO,IAAI,WAAW,OAAO,OAAO,KAAK,CAAC;AAEhD,QAAM,iBAAiB,CAAA;AACvB,aAAW,CAAC,SAAS,OAAO,KAAK,OAAO,QAAQ,MAAM,GAAG;AACvD,UAAM,OAAkB;MACtB;;MAEA,QAAQ,KAAK,YAAY,MAAM,OAAO,CAAE;;AAE1C,mBAAe,KAAK;MAClB,MAAM,UAAU,IAAI;MACpB,MAAM,GAAG,OAAO;KACjB;EACH;AACA,MAAI,OAAO,MAAM,OAAO;IACtB,QAAQ,QAAQ;IAChB,OAAO;GACR;AAED,MAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACxB,WAAO,CAAC,IAAI;EACd;AACA,MAAI,KAAK,WAAW,GAAG;AACrB,UAAM,IAAI,MAAM,oDAAoD;EACtE;AAEA,QAAM,UAAU,KAAK,CAAC,EAAG,MAAM,GAAG,KAAK,CAAC,EAAG,YAAY,GAAG,CAAC;AAE3D,QAAM,qBAAqB,MAAM,OAAO;IACtC,QAAQ,QAAQ;IAChB,OAAO,CAAC,UAAU,QAAQ,SAAS,CAAC;GACrC;AAED,QAAM,oBAA2C;IAC/C;IACA,qBAAqB;IACrB,YAAY,KAAK,WAAU;IAC3B;IACA;IACA,eAAe,QAAQ;;AAGzB,QAAM,WAAW,MAAM,OAAO;IAC5B,QAAQ,QAAQ;IAChB,OAAO,CAAC,iBAAiB;GAC1B;AACD,SAAO;IACL;IACA,KAAK;;AAET;;;ACnGA,eAAsB,0CAA0C,SAO/D;AACC,QAAM,cAAsC,CAAA;AAC5C,QAAM,SAAS,MAAM,QAAQ,IAC3B,QAAQ,OAAO,IAAI,OAAO,UAAS;AArBvC;AAuBM,QAAI,aAAqB,MAAM,kBAAkB,MAAM,IAAI,EAAE,MAAM,GAAE,CAAE;AACvE,QAAI,MAAM,cAAc;AACtB,YAAM,EAAE,mBAAmB,IAAG,IAAK,MAAM,oBAAoB;QAC3D,OAAO,QAAQ,SAAS;QACxB,QAAQ,QAAQ,SAAS;QACzB,WAAW,MAAM;QACjB,eAAe,QAAQ;OACxB;AACD,kBAAY,kBAAkB,UAAU,IAAI;AAC5C,mBAAa,kBAAkB;IACjC;AAEA,QAAI,WAAW;AACf,QAAI,MAAM,YAAY,OAAO,MAAM,aAAa,UAAU;AACxD,iBAAW,MAAM;IACnB,WAAW,MAAM,YAAY,OAAO,MAAM,aAAa,UAAU;AAC/D,iBAAW,MAAM,OAAO;QACtB,QAAQ,QAAQ,SAAS;QACzB,OAAO,CAAC,MAAM,QAAQ;OACvB;IACH;AACA,WAAO;MACL,UAAU,MAAM,mBAAmB;MACnC,oBAAoB,MAAM,sBAAsB;MAChD;MACA;MACA,eAAe,MAAM,mBAAmB;QACtC,UAAQ,WAAM,UAAN,mBAAa,eAAc;QACnC,OAAO,QAAQ,SAAS;QACxB,QAAQ,QAAQ,SAAS;QACzB,cAAc,MAAM,mBAAmB;OACxC;MACD,wBAAwB,MAAM,yBAAyB;MACvD,gBAAgB,cAAc,MAAM,aAAa,oBAAI,KAAK,CAAC,CAAC;MAC5D,eAAe;;EAEnB,CAAC,CAAC;AAEJ,QAAM,sBAA6B,CAAA;AAEnC,MAAI,OAAO,KAAK,WAAW,EAAE,SAAS,GAAG;AACvC,UAAM,CAAC,EAAE,oBAAmB,GAAI,EAAE,qBAAoB,CAAE,IACtD,MAAM,QAAQ,IAAI;MAChB,OAAO,mCAAwD;MAC/D,OACE,8BAAoF;KAEvF;AACH,UAAM,WAAW,MAAM,oBAAoB;MACzC,UAAU,QAAQ;KACnB;AAED,eAAW,OAAO,OAAO,KAAK,SAAS,UAAU,CAAA,CAAE,GAAG;AACpD,kBAAY,GAAG,IAAI,SAAS,OAAO,GAAG;IACxC;AACA,UAAM,iBAAiB;MACrB,GAAG;MACH,QAAQ;;AAEV,UAAM,MAAM,MAAM,OAAO;MACvB,QAAQ,QAAQ,SAAS;MACzB,OAAO,CAAC,cAAc;KACvB;AACD,UAAM,wBAAwB,qBAAqB;MACjD;KACD;AACD,wBAAoB,KAAK,qBAAqB;EAChD;AACA,QAAM,eAAe,OAAO,KAAK,CAAC,GAAG,MACnC,OAAO,EAAE,iBAAiB,EAAE,cAAc,CAAC;AAE7C,MAAI;AACJ,MAAI,QAAQ,YAAY,QAAW;AAEjC,QAAI,QAAQ,aAAa;AACvB,YAAM,EAAE,yBAAwB,IAAK,MAAM,OACzC,kCAA4F;AAE9F,YAAM,QAAQ,aAAa,CAAC;AAC5B,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,mBAAmB;MACrC;AACA,kCAA4B,yBAAyB;QACnD;QACA,uBAAuB,QAAQ,yBAAyB;QACxD,SAAS,QAAQ;OAClB;IACH,OAAO;AACL,YAAM,EAAE,yBAAwB,IAAK,MAAM,OACzC,kCAAiF;AAEnF,kCAA4B,yBAAyB;QACnD,QAAQ;QACR,uBAAuB,QAAQ,yBAAyB;QACxD,SAAS,QAAQ;OAClB;IACH;EACF,OAAO;AAEL,QAAI,QAAQ,aAAa;AACvB,YAAM,EAAE,yBAAwB,IAAK,MAAM,OACzC,kCAAuF;AAEzF,YAAM,QAAQ,aAAa,CAAC;AAC5B,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,mBAAmB;MACrC;AACA,kCAA4B,yBAAyB;QACnD;QACA,uBAAuB,QAAQ,yBAAyB;OACzD;IACH,OAAO;AACL,YAAM,EAAE,yBAAwB,IAAK,MAAM,OACzC,kCAA4E;AAE9E,kCAA4B,yBAAyB;QACnD,QAAQ;QACR,uBAAuB,QAAQ,yBAAyB;OACzD;IACH;EACF;AACA,sBAAoB,KAAK,yBAAyB;AAClD,SAAO;AACT;;;AClGM,SAAUC,oBACd,SAAyD;AAEzD,SAAO,UAAU;IACf,aAAa,YAAW;AACtB,aAAO;QACL,MAAM,MAAM,0CAA0C;UACpD,UAAU,QAAQ;UAClB,QAAQ,QAAQ;UAChB,uBAAuB,QAAQ;UAC/B,aAAa,QAAQ;UACrB,eAAe;SAChB;;IAEL;IACA,UAAU,QAAQ;GACnB;AACH;AAcM,SAAUC,+BAA8B,oBAA4B;AACxE,SACE,qBAAqB,kBAAkB;EAEvC,uBAA+B,kBAAkB,KACjD,0BAA0B,kBAAkB;GAE3C,8BAAuC,kBAAkB,KACxDA,+BAAkD,kBAAkB;AAE1E;;;ACvEO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa,CAAA;AAcb,SAAU,8BAA8B,oBAA4B;AACxE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAoEM,SAAU,mBACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AAhIzB;AAgI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AAjIhC;AAkIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AApIzB;AAoI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AArIvB;AAqI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAtIlB;AAsIsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAvIvB;AAuI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAxI3B;AAwI+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAzInC;AA0IO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AA5IpB;AA4IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,OAAO,gBAAgB,GAAG;IACpD;IACA,OAAO,YAAS;AAjJpB;AAiJwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AC9IO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY,CAAA;AAClB,IAAMC,eAAa;EACjB;IACE,MAAM;;;AAeJ,SAAU,2BAA2B,oBAA4B;AACrE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAgCA,eAAsB,gBAAgB,SAA+B;AACnE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;ACrDO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;;;AAeJ,SAAU,6BAA6B,oBAA4B;AACvE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AA0EA,eAAsB,kBACpB,SAAwD;AAExD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAC,QAAQ,KAAK;GACvB;AACH;;;AC5GA,eAAe,wBACb,SAAqD;AAErD,QAAM,EAAE,UAAU,eAAe,YAAW,IAAK;AACjD,QAAM,aAAa,MAAmB,gBAAgB,OAAO;AAC7D,MAAI,eAAe,IAAI;AACrB,UAAM,IAAI,MACR,iEAAiE;EAErE;AAGA,MAAIC,gBAAe;AACnB,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,WAAS,IAAI,IAAI,IAAI,YAAY,KAAK,IAAI;AACxC,iBAAa;AACb,iBAAa,MAAmB,kBAAkB;MAChD;MACA,OAAO;KACR;AACD,QAAI,aAAa,eAAe;AAC9B;IACF;AACA,IAAAA,gBAAe;EACjB;AAEA,QAAM,QAAQ,MAAM,KAClB,EAAE,QAAQ,OAAO,aAAaA,aAAY,EAAC,GAC3C,CAAC,GAAG,MAAM,OAAO,CAAC,IAAIA,aAAY;AAGpC,QAAM,aAAa;AACnB,QAAM,mBAAmB,CAAA;AACzB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,YAAY;AACjD,UAAM,QAAQ,MAAM,MAAM,GAAG,IAAI,UAAU;AAC3C,UAAM,eAAe,MAAM,QAAQ,IACjC,MAAM,IAAI,CAAC,OACF,OAAO;MACZ;MACA,cAAc;MACd,SAAS;MACT,YAAY;KACb,CAAC,CACH;AAEH,qBAAiB,KAAK,GAAG,YAAY;AACrC,QAAI,IAAI,aAAa,MAAM,QAAQ;AACjC,YAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,GAAG,CAAC;IACzD;AAEA,QAAI,iBAAiB,KAAK,CAAC,SAAS,SAAS,UAAa,CAAC,KAAK,QAAQ,GAAG;AACzE,YAAM,IAAI,MACR,sBAAsB,MAAM,MAAM,2BAA2B,UAAU,EAAE;IAE7E;EACF;AAEA,QAAM,eAA2B,CAAA;AACjC,WAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAChD,UAAM,EAAE,IAAI,SAAQ,IAAK,iBAAiB,CAAC;AAC3C,QAAI,kBAAkB,IAAI;AACxB,mBAAa,KAAK,WAAW;IAC/B,OAAO;AACL,mBAAa,KAAK,QAAQ;IAC5B;EACF;AAEA,QAAM,EAAE,qBAAAC,qBAAmB,IAAK,MAAM,OAAO,oBAA2B;AACxE,QAAM,cAAc,MAAMA,qBACxB,cACA,SAAS,QACT,OAAOD,aAAY,CAAC;AAGtB,MAAI,CAAC,eAAe,CAAC,YAAY,UAAU,CAAC,YAAY,CAAC,GAAG;AAC1D,UAAM,IAAI,MAAM,yCAAyC;EAC3D;AAEA,QAAM,UAAU,YAAY,CAAC,EAAE,UAAU,GAAG,YAAY,CAAC,EAAE,YAAY,GAAG,CAAC;AAI3E,QAAM,MAAM,GAAG,OAAO;AAEtB,SAAO,EAAE,OAAO,YAAY,IAAG;AACjC;AAyBM,SAAU,eACd,SAAqD;AAErD,QAAM,EAAE,SAAQ,IAAK;AACrB,SAAoB,mBAAmB;IACrC,aAAa,YAAY,wBAAwB,OAAO;IACxD;GACD;AACH;AAcM,SAAU,0BAA0B,oBAA4B;AACpE,SACe,2BAA2B,kBAAkB,KAC7C,8BAA8B,kBAAkB,KAChD,6BAA6B,kBAAkB,KACrD,oBAAkB,kBAAkB;AAE/C;;;AC/IO,IAAME,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;;;AAeJ,SAAU,yBAAyB,oBAA4B;AACnE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAwEA,eAAsB,cACpB,SAAoD;AAEpD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAC,QAAQ,KAAK;GACvB;AACH;;;AC7GO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;;;AAeJ,SAAU,0BAA0B,oBAA4B;AACpE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAwEA,eAAsB,eACpB,SAAqD;AAErD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAC,QAAQ,KAAK;GACvB;AACH;;;ACtFA,eAAsB,mBACpB,SAA+B;AAE/B,QAAM,QAAQ,MAAsB,gBAAgB;IAClD,UAAU,QAAQ;GACnB;AACD,MAAI,UAAU,IAAI;AAChB,WAAO,CAAA;EACT;AAEA,QAAM,kBAAkB,MAAM,KAAK,MAAM,OAAO,KAAK,CAAC,EAAE,KAAI,CAAE;AAC9D,QAAM,aAAa,MAAM,QAAQ,IAC/B,gBAAgB,IAAI,OAAO,YAAW;AACpC,UAAM,aAAa,MAAM,QAAQ,WAAW;MACxB,kBAAkB;QAClC,UAAU,QAAQ;QAClB,OAAO,OAAO,OAAO;OACtB;MACe,eAAe;QAC7B,UAAU,QAAQ;QAClB,OAAO,OAAO,OAAO;OACtB;KACF;AACD,UAAM,SAAS,WAAW,KAAK,CAACC,YAAWA,QAAO,WAAW,WAAW;AACxE,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MACR,6GAA6G;IAEjH;AACA,WAAO,OAAO;EAChB,CAAC,CAAC;AAIJ,QAAM,0BAA0B,WAAW,MAAM,GAAG,WAAW,SAAS,CAAC;AAEzE,QAAM,iBAAiB,MAAM,QAAQ,IACnC,MAAM,KAAK,CAAC,GAAG,GAAG,uBAAuB,CAAC,EAAE,IAAI,OAAO,MAAK;AAC1D,UAAM,MAAM,MAAe,SAAS;MAClC,UAAU,QAAQ;MAClB,SAAS,OAAO,CAAC;KAClB;AACD,WAAO,MAAM,mBAAmB;MAC9B,QAAQ,QAAQ,SAAS;MACzB,SAAS,OAAO,CAAC;MACjB,UAAU;KACX,EAAE,MAAM,MAAM,MAAS;EAC1B,CAAC,CAAC;AAGJ,QAAM,mBAAmB,MAAM,QAAQ,IACrC,MAAM,KAAK,CAAC,GAAG,UAAU,CAAC,EAAE,IAAI,CAAC,MACjB,cAAc;IAC1B,UAAU,QAAQ;IAClB,OAAO,OAAO,CAAC;GAChB,CAAC,CACH;AAGH,QAAM,oBAAoB,iBAAiB,IAAI,CAAC,SAAQ;AACtD,UAAM,iBAAiB,KAAK,SAAS,KAAK;AAC1C,QAAI,gBAAgB,GAAG;AACrB,aAAO,oBACL;QACE,EAAE,MAAM,WAAW,MAAM,QAAO;QAChC,EAAE,MAAM,kBAAkB,MAAM,UAAS;SAE3C,IAAI,EACJ,CAAC;IACL;AAEA,WAAO;EACT,CAAC;AAED,SAAO,eACJ,IAAI,CAAC,UAAU,OAAO;IACrB,SAAS,OAAO,CAAC;IACjB,UAAU,kBAAkB,CAAC;IAC7B,qBAAqB;IACrB,EACD,OAAO,CAAC,GAAG,UAAO;AAtHvB;AAsH2B,qCAAkB,KAAK,MAAvB,mBAA0B,WAAU,KAAK;GAAC;AACrE;AAcM,SAAU,8BAA8B,oBAA4B;AACxE,SAAO;IACW,2BAA2B,kBAAkB;IAC3C,6BAA6B,kBAAkB;IACnD,yBAAyB,kBAAkB;IACzC,0BAA0B,kBAAkB;IACnD,oBAAoB,kBAAkB;IAC/C,MAAM,OAAO;AACjB;;;AC7HO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAeJ,SAAU,0BAA0B,oBAA4B;AACpE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AA2EA,eAAsB,eACpB,SAAqD;AAErD,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAC,QAAQ,MAAM,QAAQ,GAAG;GACnC;AACH;;;AC/GO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAgBJ,SAAU,oBAAoB,oBAA4B;AAC9D,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAuEM,SAAU,SACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AAhJzB;AAgJ6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AAjJhC;AAkJO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AApJzB;AAoJ6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AArJvB;AAqJ2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAtJlB;AAsJsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAvJvB;AAuJ2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAxJ3B;AAwJ+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAzJnC;AA0JO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AA5JpB;AA4JwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO;QACL,gBAAgB;QAChB,gBAAgB;QAChB,gBAAgB;;IAEpB;IACA,OAAO,YAAS;AArKpB;AAqKwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AChKO,IAAM,4BAA4B,OACvC,iBACA,UACA,aACE;AACF,QAAM,UAAU,OAAO,SAAS,MAAM,EAAE;AACxC,QAAM,kBAAkB,SAAS;AACjC,SAAO,UACL,aACE,CAAC,UAAU,WAAW,WAAW,SAAS,GAC1C,CAAC,UAAU,SAAS,iBAAiB,WAAW,eAAe,CAAC,CAAC,CAClE;AAEL;;;ACqDM,SAAU,yBACd,SAA+D;AAE/D,MAAI,CAAC,QAAQ,UAAU;AACrB,UAAM,IAAI,MAAM,sBAAsB;EACxC;AAEA,SAAO,SAAkB;IACvB,aAAa,YAAW;AACtB,YAAM,CAAC,iBAAiB,eAAe,IAAI,MAAM,QAAQ,IAAI;QAC3D,OAAO;UACL,QAAQ,QAAQ,SAAS;UACzB,OAAO,MAAM,QAAQ,SAAS,MAAM,EAAE,KACpC,QAAQ,mBAAmB;SAE9B;QACD,kBAAkB;UAChB,UAAU,QAAQ;SACnB;OACF;AACD,YAAM,iBAAiB,oBAAoB,eAAe;AAE1D,YAAM,OAAO,MAAM,OAAO;QACxB,QAAQ,QAAQ,SAAS;QACzB,OAAO,QAAQ;;;QAGf,kBAAkB;UAChB,iBAAiB,OAAO,eAAe;;OAE1C;AAED,YAAM,UAAU,oBAAoB,IAAI;AACxC,YAAM,YAAY,MAAM,gBAAgB;QACtC,UAAU,QAAQ;OACnB;AAED,YAAM,iBAAiB,MAAM,0BAC3B,WACA,QAAQ,UACR,QAAQ,QAAQ;AAElB,YAAM,mBAAmB,MAAM,eAAe;QAC5C,UAAU,QAAQ;QAClB,MAAM,MAAM,OAAO;QACnB,KAAK;OACN;AAED,YAAM,UAAU,OAAO,QAAQ,SAAS,MAAM,EAAE;AAChD,YAAM,iBAAiB,UACrB,aACE,CAAC,SAAS,SAAS,SAAS,GAC5B,CAAC,MAAM,OAAO,GAAG,gBAAgB,OAAO,CAAC,CAC1C;AAEH,YAAM,OAAO,oBACX;QACE,EAAE,MAAM,WAAW,MAAM,QAAO;QAChC,EAAE,MAAM,kBAAkB,MAAM,UAAS;SAE3C,CAAC,kBAAkB,cAAc,CAAC;AAGpC,aAAO;QACL,QAAQ,OAAO,QAAQ,SAAS,MAAM;QACtC,kBACE,eAAe,MAAM,EAAE,MAAM,MACzB,iBACA,GAAG,cAAc;QACvB,WAAW;;IAEf;IACA,UAAU,QAAQ;GACnB;AACH;AAaM,SAAU,oCACd,oBAA4B;AAE5B,SAAO;IACL,2BAA2B,kBAAkB;IAC7C,0BAA0B,kBAAkB;IAC5C,oBAAoB,kBAAkB;IACtC,MAAM,OAAO;AACjB;;;ACpJO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAgBJ,SAAU,kBAAkB,oBAA4B;AAC5D,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAgEM,SAAU,OACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AApIzB;AAoI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AArIhC;AAsIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAxIzB;AAwI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAzIvB;AAyI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AA1IlB;AA0IsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AA3IvB;AA2I2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AA5I3B;AA4I+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AA7InC;AA8IO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AAhJpB;AAgJwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,YAAY,gBAAgB,GAAG;IACzD;IACA,OAAO,YAAS;AArJpB;AAqJwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;ACtHM,SAAUC,QAAO,SAA6C;AAClE,MAAI,CAAC,QAAQ,UAAU;AACrB,UAAM,IAAI,MAAM,sBAAsB;EACxC;AAEA,SAAO,OAAgB;IACrB,aAAa,YAAW;AACtB,YAAM,MAAM,MAAM,0BAChB,QAAQ,SACR,QAAQ,UACR,QAAQ,QAAQ;AAElB,aAAO;QACL,YAAY,QAAQ;QACpB;;IAEJ;IACA,UAAU,QAAQ;GACnB;AACH;;;AC7CA,IAAM,0BAA0B;AAmChC,eAAsB,aACpB,SAAmD;AAEnD,QAAM,CAAC,eAAe,SAAS,IAAI,MAAM,QAAQ,WAAW;IAC1D,aAAa,OAAO;IACpB,kBAAkB,OAAO;IACzB,YAAY,OAAO;GACpB,EAAE,KAAK,CAAC,CAAC,eAAe,OAAO,MAAM,MAAK;AAEzC,UAAM,iBACJ,cAAc,WAAW,cAAc,cAAc,QAAQ;AAC/D,QAAI;AAEJ,QAAI,MAAM,WAAW,aAAa;AAEhC,mBAAa,MAAM,QAAQ;IAC7B,WAES,OAAO,WAAW,aAAa;AACtC,mBAAa,OAAO;IACtB,OAAO;AACL,YAAM,IAAI,MACR,yHAAyH;IAE7H;AACA,WAAO,CAAC,gBAAgB,UAAU;EACpC,CAAC;AACD,QAAM,QAAQ,OAAO,QAAQ,SAAS,CAAC,IAAI;AAC3C,QAAM,QAAQ,OAAO,QAAQ,SAAS,uBAAuB;AAE7D,QAAM,QAAQ,IAAI,YAAY,eAAe,QAAQ,KAAK;AAE1D,QAAM,WAA0D,CAAA;AAEhE,WAAS,IAAI,OAAO,IAAI,OAAO,KAAK;AAClC,aAAS,KACP,QAAQ,EAAE,UAAU,QAAQ,UAAU,SAAS,EAAC,CAAE,EAC/C,MAAM,MAAM,YAAY,EACxB,KAAK,CAAC,WAAW;MAChB;MACA,SAAS;MACT,CAAC;EAET;AAEA,SAAO,MAAM,QAAQ,IAAI,QAAQ;AACnC;;;AC1EA,IAAMC,2BAA0B;AAoDhC,eAAsB,QACpB,SAA8C;AAE9C,QAAM,EAAE,aAAa,KAAI,IAAK;AAC9B,MAAI,YAAY;AACd,QAAI;AACF,aAAO,MAAM,mBAAmB,OAAO;IACzC,QAAQ;AACN,aAAO,MAAM,eAAe,OAAO;IACrC;EACF;AACA,SAAO,MAAM,eAAe,OAAO;AACrC;AAcM,SAAU,mBAAmB,oBAA4B;AAC7D,SACE,oBAAkB,kBAAkB,MACnC,uBAAuB,kBAAkB,KACxC,6BAA6B,kBAAkB;AAErD;AAEA,eAAe,mBACb,SAA8C;AAE9C,QAAM,EAAE,UAAU,OAAO,QAAQ,OAAOA,wBAAuB,EAAC,IAAK;AAErE,QAAM,CAAC,QAAQ,UAAU,IAAI,MAAM,QAAQ,IAAI;IAC7C,gBAAgB;MACd,QAAQ,CAAC,SAAS,KAAK;MACvB,QAAQ,SAAS;MACjB,iBAAiB,SAAS;MAC1B,eAAe,QAAQ,iBAAiB;MACxC,cAAc;QACZ,OAAO;QACP,MAAM,QAAQ,KAAK,MAAM,QAAQ,KAAK,IAAI;;KAE7C;IACD,cAAc,OAAO,EAAE,MAAM,OAAO;MAClC,WAAW;MACX,cAAc;MACd;GACH;AAED,QAAM,gBAAgB,SAAS;AAC/B,QAAM,uBAAuB,KAAK,IAChC,OACA,KAAK,IACH,GACA,OAAO,WAAW,SAAS,IACzB,OAAO,WAAW,YAAY,IAC9B,aAAa,CAChB;AAEH,MAAI,OAAO,SAAS,sBAAsB;AACxC,QAAI;AAGF,aAAO,MAAM,eAAe,OAAO;IACrC,QAAQ;AAEN,aAAO;IACT;EACF;AAEA,SAAO;AACT;AAEA,eAAe,eACb,SAA8C;AAE9C,QAAM,EAAE,cAAAC,eAAc,UAAS,IAAK,MAAM,cAAc,OAAO;AAC/D,QAAM,QAAQ,OAAO,QAAQ,SAAS,CAAC,IAAIA;AAC3C,QAAM,QAAQ,OAAO,QAAQ,SAASD,wBAAuB;AAC7D,QAAM,QAAQ,IAAI,WAAW,QAAQ,KAAK;AAC1C,QAAM,WAAwC,CAAA;AAE9C,WAAS,IAAI,OAAO,IAAI,OAAO,KAAK;AAClC,aAAS,KACP,OAAO;MACL,GAAG;MACH,cAAc,QAAQ,iBAAiB;MACvC,SAAS;MACT,YAAY;KACb,CAAC;EAEN;AAEA,SAAO,MAAM,QAAQ,IAAI,QAAQ;AACnC;AAEA,eAAe,cAAc,SAA8C;AACzE,QAAM,CAAC,eAAe,SAAS,IAAI,MAAM,QAAQ,WAAW;IAC1D,aAAa,OAAO;IACpB,kBAAkB,OAAO;IACzB,YAAY,OAAO;GACpB,EAAE,KAAK,CAAC,CAAC,eAAe,OAAO,MAAM,MAAK;AAEzC,UAAM,iBACJ,cAAc,WAAW,cAAc,cAAc,QAAQ;AAC/D,QAAI;AAEJ,QAAI,MAAM,WAAW,aAAa;AAEhC,mBAAa,MAAM,QAAQ;IAC7B,WAES,OAAO,WAAW,aAAa;AACtC,mBAAa,OAAO;IACtB,OAAO;AACL,YAAM,IAAI,MACR,yHAAyH;IAE7H;AACA,WAAO,CAAC,gBAAgB,UAAU;EACpC,CAAC;AAED,SAAO;IACL;IACA,cAAc;;AAElB;;;AClMO,IAAME,gBAAc;AAC3B,IAAMC,cAAY,CAAA;AAClB,IAAMC,eAAa;EACjB;IACE,MAAM;;;AAoDV,eAAsB,mBAAmB,SAA+B;AACtE,SAAO,aAAa;IAClB,UAAU,QAAQ;IAClB,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,QAAQ,CAAA;GACT;AACH;;;AChDA,eAAsB,sBACpB,SAA+B;AAE/B,QAAM,CAAC,eAAe,mBAAmB,IAAI,MAAM,QAAQ,IAAI;IAC7D,aAAa,OAAO,EAAE,MAAM,MAAM,EAAE;IACpC,mBAAmB,OAAO;GAC3B;AAED,SAAO,sBAAsB;AAC/B;;;ACVA,eAAsB,wBACpB,SAA+B;AAE/B,QAAM,CAAC,eAAe,oBAAoB,mBAAmB,IAC3D,MAAM,QAAQ,IAAI;IAChB,aAAa,OAAO,EAAE,MAAM,MAAM,EAAE;IACpC,kBAAkB,OAAO;IACzB,sBAAsB,OAAO;GAC9B;AAEH,SAAO,qBAAqB,gBAAgB;AAC9C;;;ACeM,SAAUC,UAAS,SAA+C;AACtE,SAAgB,SAAS;IACvB,aAAa,YAAW;AACtB,YAAM,kBAAkB,MAAM,kBAAkB;QAC9C,UAAU,QAAQ;OACnB;AAED,YAAM,cAAc,MAAM;QACxB,QAAQ;QACR,QAAQ,SAAS;;QAEjB,OAAO,eAAe;MAAC;AAGzB,YAAM,UAAU,oBAAoB,WAAW;AAE/C,aAAO;QACL,QAAQ,OAAO,YAAY,MAAM;QACjC,kBAAkB,QAAQ,SAAS,GAAG,IAAI,UAAU,GAAG,OAAO;QAC9D,WAAW;;IAEf;IACA,UAAU,QAAQ;GACnB;AACH;AAcM,SAAUC,qBAAoB,oBAA4B;AAC9D,SACW,oBAAoB,kBAAkB;EAE/C,6BAA6B,kBAAkB;AAEnD;;;ACvEO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;;;AAgBJ,SAAU,kBAAkB,oBAA4B;AAC5D,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAgEM,SAAU,OACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AAhIzB;AAgI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AAjIhC;AAkIO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AApIzB;AAoI6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AArIvB;AAqI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAtIlB;AAsIsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AAvIvB;AAuI2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAxI3B;AAwI+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAzInC;AA0IO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AA5IpB;AA4IwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,IAAI,gBAAgB,GAAG;IACjD;IACA,OAAO,YAAS;AAjJpB;AAiJwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;ACxGM,SAAUC,QAAO,SAA6C;AAClE,SAAO,OAAgB;IACrB,aAAa,YAAW;AACtB,UAAI;AAEJ,UAAI,OAAO,QAAQ,QAAQ,UAAU;AAEnC,mBAAW,QAAQ;MACrB,OAAO;AAIL,cAAM,EAAE,QAAAC,QAAM,IAAK,MAAM,OAAO,sBAA4B;AAC5D,mBAAW,MAAMA,QAAO;UACtB,QAAQ,QAAQ,SAAS;UACzB,OAAO,CAAC,QAAQ,GAAG;SACpB;MACH;AACA,aAAO;QACL,WAAW,QAAQ;QACnB,IAAI,QAAQ;QACZ,KAAK;;IAET;IACA,UAAU,QAAQ;GACnB;AACH;;;AC5CO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa,CAAA;AAcb,SAAU,6BAA6B,oBAA4B;AACvE,SAAO,aAAa;IAClB;IACA,QAAQ,CAACF,eAAaC,aAAWC,YAAU;GAC5C;AACH;AAiEM,SAAU,kBACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AAnJzB;AAmJ6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AApJhC;AAqJO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAvJzB;AAuJ6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAxJvB;AAwJ2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAzJlB;AAyJsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AA1JvB;AA0J2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AA3J3B;AA2J+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AA5JnC;AA6JO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AA/JpB;AA+JwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,QAAQ;IAClC;IACA,OAAO,YAAS;AApKpB;AAoKwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;ACpJM,SAAUC,mBACd,SAAwD;AAExD,SAAO,kBAAwB;IAC7B,aAAa,YAAW;AACtB,UAAI,CAAC,QAAQ,IAAI,MAAM;AACrB,cAAM,IAAI,MAAM,sBAAsB;MACxC;AAEA,YAAM,QAA2B;;SAE9B,YAAW;AACV,cAAI,CAAC,QAAQ,IAAI,OAAO;AACtB,mBAAO;UACT;AACA,cAAI,OAAO,QAAQ,IAAI,UAAU,UAAU;AACzC,mBAAO,QAAQ,IAAI;UACrB;AACA,gBAAM,EAAE,QAAAC,QAAM,IAAK,MAAM,OAAO,sBAA4B;AAC5D,iBAAO,MAAMA,QAAO;YAClB,QAAQ,QAAQ,SAAS;YACzB,OAAO,CAAC,QAAQ,IAAI,KAAK;WAC1B;QACH,GAAE;;SAED,YAAW;AACV,cAAI,CAAC,QAAQ,IAAI,eAAe;AAC9B,mBAAO;UACT;AACA,cAAI,OAAO,QAAQ,IAAI,kBAAkB,UAAU;AACjD,mBAAO,QAAQ,IAAI;UACrB;AACA,gBAAM,EAAE,QAAAA,QAAM,IAAK,MAAM,OAAO,sBAA4B;AAC5D,iBAAO,MAAMA,QAAO;YAClB,QAAQ,QAAQ,SAAS;YACzB,OAAO,CAAC,QAAQ,IAAI,aAAa;WAClC;QACH,GAAE;;AAGJ,YAAM,CAAC,UAAU,YAAY,IAAI,MAAM,QAAQ,IAAI,KAAK;AAExD,aAAO;QACL,UAAU;UACR,cAAc,gBAAgB;UAC9B,aAAa,mBAAmB,QAAQ,IAAI,WAAW,KAAK;UAC5D,UAAU,YAAY;UACtB,MAAM,QAAQ,IAAI;;;IAGxB;IACA,UAAU,QAAQ;GACnB;AACH;AAEA,SAAS,mBAAmB,KAA8B;AACxD,MAAI,CAAC,KAAK;AACR,WAAO;EACT;AACA,QAAM,YAAY,KAAK,UAAU,GAAG;AACpC,SAAO,UAAU,MAAM,GAAG,UAAU,SAAS,CAAC;AAChD;;;AC/CO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAyFJ,SAAU,kBACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AA9LzB;AA8L6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AA/LhC;AAgMO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAlMzB;AAkM6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAnMvB;AAmM2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AApMlB;AAoMsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AArMvB;AAqM2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AAtM3B;AAsM+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AAvMnC;AAwMO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AA1MpB;AA0MwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,SAAS,gBAAgB,SAAS;IAC5D;IACA,OAAO,YAAS;AA/MpB;AA+MwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AChLO,IAAMC,gBAAc;AAC3B,IAAMC,cAAY;EAChB;IACE,YAAY;MACV;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;MAER;QACE,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,MAAM;IACN,MAAM;;;AAGV,IAAMC,eAAa;EACjB;IACE,MAAM;IACN,MAAM;;;AAyFJ,SAAUC,mBACd,SAKC;AAED,QAAM,eAAe,KAAK,YAAW;AACnC,WAAO,iBAAiB,UAAU,MAAM,QAAQ,YAAW,IAAK;EAClE,CAAC;AAED,SAAO,oBAAoB;IACzB,YAAY,YAAS;AAnMzB;AAmM6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,mBAAmB,YAAS;AApMhC;AAqMO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,UAAU,QAAQ;IAClB,YAAY,YAAS;AAvMzB;AAuM6B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC1D,UAAU,YAAS;AAxMvB;AAwM2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,KAAK,YAAS;AAzMlB;AAyMsB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACnD,UAAU,YAAS;AA1MvB;AA0M2B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACxD,cAAc,YAAS;AA3M3B;AA2M+B,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IAC5D,sBAAsB,YAAS;AA5MnC;AA6MO,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACpC,QAAQ,CAACC,eAAaC,aAAWC,YAAU;IAC3C,OAAO,YAAS;AA/MpB;AA+MwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;IACrD,QAAQ,YAAW;AACjB,YAAM,kBAAkB,MAAM,aAAY;AAC1C,aAAO,CAAC,gBAAgB,SAAS,gBAAgB,SAAS;IAC5D;IACA,OAAO,YAAS;AApNpB;AAoNwB,0BAAM,aAAY,GAAI,cAAtB,mBAAiC;;GACtD;AACH;;;AC1KM,SAAUC,mBACd,SAGC;AAED,QAAM,EAAE,QAAO,IAAK;AACpB,MAAI,cAAc,SAAS;AACzB,WAAO,oBACL,OAA4D;EAEhE;AACA,SAAO,oBACL,OAA0D;AAE9D;AAEA,SAAS,oBACP,SAAwD;AAExD,QAAM,QAAQ,qBAAqB,QAAQ,QAAQ,QAAQ,IACvD,QAAQ,QAAQ,QAChB;AACJ,SAAO,kBAA2B;IAChC,GAAG;IACH,WAAW;MACT;;GAEH;AACH;AAEA,SAAS,oBACP,SAA0D;AAE1D,QAAM,QAAQ,qBAAqB,QAAQ,QAAQ,QAAQ,IACvD,QAAQ,QAAQ,gBAAgB,QAAQ,QAAQ,WAChD;AACJ,SAAOA,mBAA6B;IAClC,GAAG;IACH,WAAW;MACT;;GAEH;AACH;AAyCA,eAAsB,sBAEpB,SAAwC;AAlI1C;AAmIE,QAAM,EAAE,aAAa,SAAS,UAAU,aAAY,IAAK;AAEzD,QAAM,WAAW,YAAY,YAAY;AACzC,QAAM,CAAC,OAAO,KAAK,GAAG,IAAI,MAAM,QAAQ,IAAI;;KAEzC,YAAW;AAEV,UAAI,gBAAgB,eAAe,YAAY,YAAY;AACzD,eAAO,YAAY;MACrB;AAEA,UAAI,WAAW,eAAe,YAAY,OAAO;AAC/C,cAAM,EAAE,oBAAAC,oBAAkB,IAAK,MAAM,OACnC,oCAAmD;AAErD,eAAO,MAAMA,oBAAmB;UAC9B,QAAQ,YAAY;UACpB,OAAO,SAAS;UAChB,QAAQ,SAAS;UACjB,cAAc;SACf;MACH;AAEA,aAAO;IACT,GAAE;;KAED,YAAW;AACV,UAAI,cAAc,aAAa;AAC7B,YAAI,OAAO,YAAY,aAAa,UAAU;AAE5C,gBAAM,EAAE,QAAAC,QAAM,IAAK,MAAM,OAAO,sBAA4B;AAC5D,iBAAO,MAAMA,QAAO;YAClB,QAAQ,QAAQ,SAAS;YACzB,OAAO,CAAC,YAAY,QAAQ;WAC7B;QACH;AACA,eAAO,YAAY;MACrB;AACA,aAAO;IACT,GAAE;;KAED,MAAU;AACT,UAAI,YAAY,KAAK;AACnB,eAAO,MAAM,YAAY,GAAG,IACxB,YAAY,MACZ,YAAY,YAAY,KAAK,EAAE,MAAM,GAAE,CAAE;MAC/C;AACA,aAAO,eAAc;IACvB,GAAE;GACH;AAED,QAAM,YAAY,YAAY,0BAA0B,oBAAI,KAAK,CAAC;AAClE,QAAM,UAAU,YAAY,wBAAwB,gBAAe;AAEnE,MAAI;AACJ,QACE,iBAAY,yBAAZ,mBAAkC,YAAW,KAC7C,CAAC,YAAY,sBACb;AACA,UAAM,EAAE,qBAAoB,IAAK,MAAM,OACrC,oCAAsE;AAExE,oBAAgB,MAAM,qBAAqB;MACzC;KACD;EACH,OAAO;AACL,oBAAgB,YAAY;EAC9B;AAEA,MAAI;AACJ,QACE,iBAAY,qBAAZ,mBAA8B,YAAW,KACzC,CAAC,YAAY,kBACb;AACA,UAAM,EAAE,sBAAqB,IAAK,MAAM,OACtC,qCAAmE;AAErE,UAAM,cAAc,MAAM,sBAAsB;MAC9C;KACD;AACD,uBAAmB,YAAY,CAAC;EAClC,OAAO;AACL,uBAAmB,YAAY;EACjC;AAEA,MAAI,iBAAiB,eAAe;AAClC,WAAO,cAAc;MACnB;MACA;MACA;MACA;MACA;MACA;MACA,sBAAsB;MACtB;MACA;MACA;MACA;KACD;EACH;AACA,SAAO,cAAc;IACnB;IACA;IACA;IACA;IACA;IACA;IACA,sBAAsB;IACtB;IACA;IACA;IACA;GACD;AACH;AAEA,eAAe,cAAc,EAC3B,aACA,SACA,UACA,KACA,UACA,KACA,OACA,kBACA,sBACA,WACA,QAAO,GAaR;AACC,QAAM,UAAuB;IAC3B;IACA;IACA;IACA,YAAY,SAAS,YAAY,cAAc,CAAC;IAChD;IACA,IAAI,YAAY;IAChB;IACA;IACA,sBAAsB,cAAc,OAAO;IAC3C,wBAAwB,cAAc,SAAS;;AAGjD,QAAM,YAAY,MAAM,QAAQ,cAAc;IAC5C,QAAQ;MACN,SAAS,SAAS,MAAM;MACxB,MAAM;MACN,mBAAmB,SAAS;MAC5B,SAAS;;IAEX,SAAS;IACT,aAAa;IACb,OAAO;MACL,aAAa;;GAEhB;AACD,SAAO,EAAE,SAAS,UAAS;AAC7B;AAEA,eAAe,cAAc,EAC3B,aACA,SACA,UACA,KACA,UACA,KACA,OACA,kBACA,sBACA,WACA,QAAO,GAaR;AACC,QAAM,UAAyB;IAC7B;IACA,eAAe;IACf;IACA,UAAU,SAAS,CAAC;;IACpB,YAAY,SAAS,YAAY,cAAc,CAAC;IAChD;IACA,IAAI,YAAY;IAChB;IACA;IACA,sBAAsB,cAAc,OAAO;IAC3C,wBAAwB,cAAc,SAAS;;AAGjD,QAAM,YAAY,MAAM,QAAQ,cAAc;IAC5C,QAAQ;MACN,SAAS,SAAS,MAAM;MACxB,MAAM;MACN,mBAAmB,SAAS;MAC5B,SAAS;;IAEX,SAAS;IACT,aAAa;IACb,OAAO;MACL,aAAa;;GAEhB;AACD,SAAO,EAAE,SAAS,UAAS;AAC7B;AAgCA,IAAM,iBAAiB;EACrB,EAAE,MAAM,MAAM,MAAM,UAAS;EAC7B,EAAE,MAAM,oBAAoB,MAAM,UAAS;EAC3C,EAAE,MAAM,cAAc,MAAM,UAAS;EACrC,EAAE,MAAM,wBAAwB,MAAM,UAAS;EAC/C,EAAE,MAAM,OAAO,MAAM,SAAQ;EAC7B,EAAE,MAAM,SAAS,MAAM,UAAS;EAChC,EAAE,MAAM,YAAY,MAAM,UAAS;EACnC,EAAE,MAAM,0BAA0B,MAAM,UAAS;EACjD,EAAE,MAAM,wBAAwB,MAAM,UAAS;EAC/C,EAAE,MAAM,OAAO,MAAM,UAAS;;AAKhC,IAAM,oBAAoB;EACxB,EAAE,MAAM,MAAM,MAAM,UAAS;EAC7B,EAAE,MAAM,oBAAoB,MAAM,UAAS;EAC3C,EAAE,MAAM,cAAc,MAAM,UAAS;EACrC,EAAE,MAAM,wBAAwB,MAAM,UAAS;EAC/C,EAAE,MAAM,OAAO,MAAM,SAAQ;EAC7B,EAAE,MAAM,YAAY,MAAM,UAAS;EACnC,EAAE,MAAM,iBAAiB,MAAM,UAAS;EACxC,EAAE,MAAM,YAAY,MAAM,UAAS;EACnC,EAAE,MAAM,0BAA0B,MAAM,UAAS;EACjD,EAAE,MAAM,wBAAwB,MAAM,UAAS;EAC/C,EAAE,MAAM,OAAO,MAAM,UAAS;;;;ACjX1B,SAAU,eACd,SAAqD;AAErD,QAAM,EAAE,SAAQ,IAAK;AACrB,SAAO,YAAY;IACjB,aAAa,YAAY,qBAAqB,OAAO;IACrD;GACD;AACH;AAKA,eAAe,qBACb,SAAqD;AAErD,QAAM,EAAE,SAAS,YAAW,IAAK;AACjC,QAAM,QAA2B;;KAE9B,YAAW;AACV,UAAI,CAAC,YAAY,OAAO;AACtB,eAAO;MACT;AACA,UAAI,OAAO,YAAY,UAAU,UAAU;AACzC,eAAO,YAAY;MACrB;AACA,aAAO,MAAM,OAAO;QAClB,QAAQ,QAAQ,SAAS;QACzB,OAAO,CAAC,YAAY,KAAK;OAC1B;IACH,GAAE;;KAED,YAAW;AACV,UAAI,CAAC,YAAY,eAAe;AAC9B,eAAO;MACT;AACA,UAAI,OAAO,YAAY,kBAAkB,UAAU;AACjD,eAAO,YAAY;MACrB;AACA,aAAO,MAAM,OAAO;QAClB,QAAQ,QAAQ,SAAS;QACzB,OAAO,CAAC,YAAY,aAAa;OAClC;IACH,GAAE;;AAGJ,QAAM,CAAC,UAAU,YAAY,IAAI,MAAM,QAAQ,IAAI,KAAK;AACxD,MAAI,YAAY,SAAS,UAAU;AACjC,gBAAY,QAAQ;EACtB;AACA,MAAI,YAAY,iBAAiB,cAAc;AAC7C,gBAAY,gBAAgB;EAC9B;AAEA,QAAM,MAAM,MAAM,OAAO;IACvB,QAAQ,QAAQ,SAAS;IACzB,OAAO,CAAC,WAAW;GACpB;AACD,SAAO,EAAE,SAAS,IAAG;AACvB;",
  "names": ["FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "setClaimConditions", "isSetClaimConditionsSupported", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "startTokenId", "uploadOrExtractURIs", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "result", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "reveal", "DEFAULT_QUERY_ALL_COUNT", "startTokenId", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "lazyMint", "isLazyMintSupported", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "mintTo", "upload", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "setSharedMetadata", "upload", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "mintWithSignature", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "mintWithSignature", "convertErc20Amount", "upload"]
}
