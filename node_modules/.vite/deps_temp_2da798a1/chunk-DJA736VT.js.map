{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc7702/__generated__/MinimalAccount/write/execute.ts", "../../thirdweb/src/wallets/in-app/core/eip7702/minimal-account.ts", "../../thirdweb/src/wallets/in-app/core/wallet/index.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"execute\" function.\n */\nexport type ExecuteParams = WithOverrides<{\n  calls: AbiParameterToPrimitiveType<{\n    type: \"tuple[]\";\n    name: \"calls\";\n    components: [\n      { type: \"address\"; name: \"target\" },\n      { type: \"uint256\"; name: \"value\" },\n      { type: \"bytes\"; name: \"data\" },\n    ];\n  }>;\n}>;\n\nexport const FN_SELECTOR = \"0x3f707e6b\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"target\",\n        type: \"address\",\n      },\n      {\n        name: \"value\",\n        type: \"uint256\",\n      },\n      {\n        name: \"data\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"calls\",\n    type: \"tuple[]\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `execute` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `execute` method is supported.\n * @extension ERC7702\n * @example\n * ```ts\n * import { isExecuteSupported } from \"thirdweb/extensions/erc7702\";\n *\n * const supported = isExecuteSupported([\"0x...\"]);\n * ```\n */\nexport function isExecuteSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"execute\" function.\n * @param options - The options for the execute function.\n * @returns The encoded ABI parameters.\n * @extension ERC7702\n * @example\n * ```ts\n * import { encodeExecuteParams } from \"thirdweb/extensions/erc7702\";\n * const result = encodeExecuteParams({\n *  calls: ...,\n * });\n * ```\n */\nexport function encodeExecuteParams(options: ExecuteParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.calls]);\n}\n\n/**\n * Encodes the \"execute\" function into a Hex string with its parameters.\n * @param options - The options for the execute function.\n * @returns The encoded hexadecimal string.\n * @extension ERC7702\n * @example\n * ```ts\n * import { encodeExecute } from \"thirdweb/extensions/erc7702\";\n * const result = encodeExecute({\n *  calls: ...,\n * });\n * ```\n */\nexport function encodeExecute(options: ExecuteParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeExecuteParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"execute\" function on the contract.\n * @param options - The options for the \"execute\" function.\n * @returns A prepared transaction object.\n * @extension ERC7702\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { execute } from \"thirdweb/extensions/erc7702\";\n *\n * const transaction = execute({\n *  contract,\n *  calls: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function execute(\n  options: BaseTransactionOptions<\n    | ExecuteParams\n    | {\n        asyncParams: () => Promise<ExecuteParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.calls] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n", "import type { Definition, TypedData } from \"ox/TypedData\";\nimport type { Hex, SignableMessage } from \"viem\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getBytecode } from \"../../../../contract/actions/get-bytecode.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../../contract/contract.js\";\nimport { execute } from \"../../../../extensions/erc7702/__generated__/MinimalAccount/write/execute.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport type { SignedAuthorization } from \"../../../../transaction/actions/eip7702/authorization.js\";\nimport { toSerializableTransaction } from \"../../../../transaction/actions/to-serializable-transaction.js\";\nimport type { SendTransactionResult } from \"../../../../transaction/types.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport {\n  executeWithSignature,\n  getQueuedTransactionHash,\n} from \"../../../smart/lib/bundler.js\";\nimport type { BundlerOptions } from \"../../../smart/types.js\";\n\nconst MINIMAL_ACCOUNT_IMPLEMENTATION_ADDRESS =\n  \"0xD6999651Fc0964B9c6B444307a0ab20534a66560\";\n\nexport const create7702MinimalAccount = (args: {\n  client: ThirdwebClient;\n  adminAccount: Account;\n  sponsorGas?: boolean;\n}): Account => {\n  const { client, adminAccount, sponsorGas } = args;\n\n  const _sendTxWithAuthorization = async (txs: SendTransactionOption[]) => {\n    const firstTx = txs[0];\n    if (!firstTx) {\n      throw new Error(\"No transactions provided\");\n    }\n    const chain = getCachedChain(firstTx.chainId);\n    const eoaContract = getContract({\n      address: adminAccount.address,\n      chain,\n      client,\n      abi: MinimalAccountAbi,\n    });\n    // check if account has been delegated already\n    let authorization: SignedAuthorization | undefined;\n    const isMinimalAccount = await is7702MinimalAccount(eoaContract);\n    if (!isMinimalAccount) {\n      // if not, sign authorization\n      let nonce = firstTx.nonce\n        ? BigInt(firstTx.nonce)\n        : BigInt(\n            await getNonce({\n              client,\n              address: adminAccount.address,\n              chain: getCachedChain(firstTx.chainId),\n            }),\n          );\n      nonce += sponsorGas ? 0n : 1n;\n      const auth = await adminAccount.signAuthorization?.({\n        address: MINIMAL_ACCOUNT_IMPLEMENTATION_ADDRESS,\n        chainId: firstTx.chainId,\n        nonce,\n      });\n      if (!auth) {\n        throw new Error(\"Failed to sign authorization\");\n      }\n      authorization = auth;\n    }\n    if (sponsorGas) {\n      // send transaction from executor, needs signature\n      const wrappedCalls = {\n        calls: txs.map((tx) => ({\n          data: tx.data ?? \"0x\", // will throw if undefined address\n          target: getAddress(tx.to ?? \"\"),\n          value: tx.value ?? 0n,\n        })),\n        uid: randomBytesHex(),\n      };\n      const signature = await adminAccount.signTypedData({\n        domain: {\n          chainId: firstTx.chainId,\n          name: \"MinimalAccount\",\n          verifyingContract: eoaContract.address,\n          version: \"1\",\n        },\n        message: wrappedCalls,\n        primaryType: \"WrappedCalls\",\n        types: {\n          Call: [\n            { name: \"target\", type: \"address\" },\n            { name: \"value\", type: \"uint256\" },\n            { name: \"data\", type: \"bytes\" },\n          ],\n          WrappedCalls: [\n            { name: \"calls\", type: \"Call[]\" },\n            { name: \"uid\", type: \"bytes32\" },\n          ],\n        },\n      });\n\n      const result = await executeWithSignature({\n        authorization,\n        eoaAddress: getAddress(adminAccount.address),\n        options: {\n          chain: getCachedChain(firstTx.chainId),\n          client,\n        },\n        signature,\n        wrappedCalls,\n      });\n\n      const transactionHash = await waitForTransactionHash({\n        options: {\n          chain: getCachedChain(firstTx.chainId),\n          client,\n        },\n        transactionId: result.transactionId,\n      });\n      return {\n        transactionHash,\n      };\n    }\n    // send transaction from EOA\n    // wrap txs in a single execute call to the MinimalAccount\n    const executeTx = execute({\n      calls: txs.map((tx) => ({\n        data: tx.data ?? \"0x\",\n        target: tx.to ?? \"\",\n        value: tx.value ?? 0n,\n      })),\n      contract: eoaContract,\n      overrides: {\n        authorizationList: authorization ? [authorization] : undefined,\n        value: txs.reduce((acc, tx) => acc + (tx.value ?? 0n), 0n),\n      },\n    });\n    // re-estimate gas for the entire batch + authorization\n    const serializedTx = await toSerializableTransaction({\n      from: adminAccount.address,\n      transaction: executeTx,\n    });\n    return adminAccount.sendTransaction(serializedTx);\n  };\n\n  const minimalAccount: Account = {\n    address: adminAccount.address,\n    sendBatchTransaction: async (\n      txs: SendTransactionOption[],\n    ): Promise<SendTransactionResult> => {\n      return _sendTxWithAuthorization(txs);\n    },\n    sendTransaction: async (\n      tx: SendTransactionOption,\n    ): Promise<SendTransactionResult> => {\n      return _sendTxWithAuthorization([tx]);\n    },\n    signMessage: ({\n      message,\n      originalMessage,\n      chainId,\n    }: {\n      message: SignableMessage;\n      originalMessage?: string;\n      chainId?: number;\n    }): Promise<Hex> =>\n      adminAccount.signMessage({ chainId, message, originalMessage }),\n    signTypedData: <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      _typedData: Definition<typedData, primaryType>,\n    ): Promise<Hex> => adminAccount.signTypedData(_typedData),\n    sendCalls: async (options) => {\n      const { inAppWalletSendCalls } = await import(\n        \"../eip5792/in-app-wallet-calls.js\"\n      );\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: minimalAccount,\n        calls: options.calls,\n      });\n      return { chain, client, id };\n    },\n    getCallsStatus: async (options) => {\n      const { inAppWalletGetCallsStatus } = await import(\n        \"../eip5792/in-app-wallet-calls.js\"\n      );\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async (options) => {\n      return {\n        [options.chainId ?? 1]: {\n          atomic: {\n            status: \"supported\",\n          },\n          paymasterService: {\n            supported: sponsorGas ?? false,\n          },\n        },\n      };\n    },\n  };\n  return minimalAccount;\n};\n\nasync function getNonce(args: {\n  client: ThirdwebClient;\n  address: string;\n  chain: Chain;\n}): Promise<number> {\n  const { client, address, chain } = args;\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n  const nonce = await import(\n    \"../../../../rpc/actions/eth_getTransactionCount.js\"\n  ).then(({ eth_getTransactionCount }) =>\n    eth_getTransactionCount(rpcRequest, {\n      address,\n      blockTag: \"pending\",\n    }),\n  );\n  return nonce;\n}\n\nasync function is7702MinimalAccount(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO properly type tw contract\n  eoaContract: ThirdwebContract<any>,\n): Promise<boolean> {\n  const code = await getBytecode(eoaContract);\n  const isDelegated = code.length > 0 && code.startsWith(\"0xef0100\");\n  const target = `0x${code.slice(8, 48)}`;\n  return (\n    isDelegated &&\n    target.toLowerCase() ===\n      MINIMAL_ACCOUNT_IMPLEMENTATION_ADDRESS.toLowerCase()\n  );\n}\n\nasync function waitForTransactionHash(args: {\n  options: BundlerOptions;\n  transactionId: string;\n  timeoutMs?: number;\n  intervalMs?: number;\n}): Promise<Hex> {\n  const timeout = args.timeoutMs || 300000; // 5mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const result = await getQueuedTransactionHash({\n      options: args.options,\n      transactionId: args.transactionId,\n    });\n    if (result.transactionHash) {\n      return result.transactionHash;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\n    `Timeout waiting for transaction to be mined on chain ${args.options.chain.id} with transactionId: ${args.transactionId}`,\n  );\n}\n\nconst MinimalAccountAbi = [\n  { type: \"receive\", stateMutability: \"payable\" },\n  {\n    type: \"function\",\n    name: \"createSessionWithSig\",\n    inputs: [\n      {\n        name: \"sessionSpec\",\n        type: \"tuple\",\n        internalType: \"struct SessionLib.SessionSpec\",\n        components: [\n          { name: \"signer\", type: \"address\", internalType: \"address\" },\n          { name: \"isWildcard\", type: \"bool\", internalType: \"bool\" },\n          { name: \"expiresAt\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"callPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.CallSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n              {\n                name: \"constraints\",\n                type: \"tuple[]\",\n                internalType: \"struct SessionLib.Constraint[]\",\n                components: [\n                  {\n                    name: \"condition\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.Condition\",\n                  },\n                  { name: \"index\", type: \"uint64\", internalType: \"uint64\" },\n                  {\n                    name: \"refValue\",\n                    type: \"bytes32\",\n                    internalType: \"bytes32\",\n                  },\n                  {\n                    name: \"limit\",\n                    type: \"tuple\",\n                    internalType: \"struct SessionLib.UsageLimit\",\n                    components: [\n                      {\n                        name: \"limitType\",\n                        type: \"uint8\",\n                        internalType: \"enum SessionLib.LimitType\",\n                      },\n                      {\n                        name: \"limit\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                      {\n                        name: \"period\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            name: \"transferPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.TransferSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n            ],\n          },\n          { name: \"uid\", type: \"bytes32\", internalType: \"bytes32\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"eip712Domain\",\n    inputs: [],\n    outputs: [\n      { name: \"fields\", type: \"bytes1\", internalType: \"bytes1\" },\n      { name: \"name\", type: \"string\", internalType: \"string\" },\n      { name: \"version\", type: \"string\", internalType: \"string\" },\n      { name: \"chainId\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"verifyingContract\", type: \"address\", internalType: \"address\" },\n      { name: \"salt\", type: \"bytes32\", internalType: \"bytes32\" },\n      { name: \"extensions\", type: \"uint256[]\", internalType: \"uint256[]\" },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"execute\",\n    inputs: [\n      {\n        name: \"calls\",\n        type: \"tuple[]\",\n        internalType: \"struct Call[]\",\n        components: [\n          { name: \"target\", type: \"address\", internalType: \"address\" },\n          { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"data\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n      },\n    ],\n    outputs: [],\n    stateMutability: \"payable\",\n  },\n  {\n    type: \"function\",\n    name: \"executeWithSig\",\n    inputs: [\n      {\n        name: \"wrappedCalls\",\n        type: \"tuple\",\n        internalType: \"struct WrappedCalls\",\n        components: [\n          {\n            name: \"calls\",\n            type: \"tuple[]\",\n            internalType: \"struct Call[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"data\", type: \"bytes\", internalType: \"bytes\" },\n            ],\n          },\n          { name: \"uid\", type: \"bytes32\", internalType: \"bytes32\" },\n        ],\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"payable\",\n  },\n  {\n    type: \"function\",\n    name: \"getCallPoliciesForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [\n      {\n        name: \"\",\n        type: \"tuple[]\",\n        internalType: \"struct SessionLib.CallSpec[]\",\n        components: [\n          { name: \"target\", type: \"address\", internalType: \"address\" },\n          { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n          { name: \"maxValuePerUse\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"valueLimit\",\n            type: \"tuple\",\n            internalType: \"struct SessionLib.UsageLimit\",\n            components: [\n              {\n                name: \"limitType\",\n                type: \"uint8\",\n                internalType: \"enum SessionLib.LimitType\",\n              },\n              { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          {\n            name: \"constraints\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.Constraint[]\",\n            components: [\n              {\n                name: \"condition\",\n                type: \"uint8\",\n                internalType: \"enum SessionLib.Condition\",\n              },\n              { name: \"index\", type: \"uint64\", internalType: \"uint64\" },\n              { name: \"refValue\", type: \"bytes32\", internalType: \"bytes32\" },\n              {\n                name: \"limit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"getSessionExpirationForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [{ name: \"\", type: \"uint256\", internalType: \"uint256\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"getSessionStateForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [\n      {\n        name: \"\",\n        type: \"tuple\",\n        internalType: \"struct SessionLib.SessionState\",\n        components: [\n          {\n            name: \"transferValue\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.LimitState[]\",\n            components: [\n              { name: \"remaining\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              { name: \"index\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          {\n            name: \"callValue\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.LimitState[]\",\n            components: [\n              { name: \"remaining\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              { name: \"index\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          {\n            name: \"callParams\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.LimitState[]\",\n            components: [\n              { name: \"remaining\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              { name: \"index\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n        ],\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"getTransferPoliciesForSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [\n      {\n        name: \"\",\n        type: \"tuple[]\",\n        internalType: \"struct SessionLib.TransferSpec[]\",\n        components: [\n          { name: \"target\", type: \"address\", internalType: \"address\" },\n          { name: \"maxValuePerUse\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"valueLimit\",\n            type: \"tuple\",\n            internalType: \"struct SessionLib.UsageLimit\",\n            components: [\n              {\n                name: \"limitType\",\n                type: \"uint8\",\n                internalType: \"enum SessionLib.LimitType\",\n              },\n              { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n              { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n        ],\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"isWildcardSigner\",\n    inputs: [{ name: \"signer\", type: \"address\", internalType: \"address\" }],\n    outputs: [{ name: \"\", type: \"bool\", internalType: \"bool\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"onERC1155BatchReceived\",\n    inputs: [\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"uint256[]\", internalType: \"uint256[]\" },\n      { name: \"\", type: \"uint256[]\", internalType: \"uint256[]\" },\n      { name: \"\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [{ name: \"\", type: \"bytes4\", internalType: \"bytes4\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"onERC1155Received\",\n    inputs: [\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [{ name: \"\", type: \"bytes4\", internalType: \"bytes4\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"onERC721Received\",\n    inputs: [\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"address\", internalType: \"address\" },\n      { name: \"\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [{ name: \"\", type: \"bytes4\", internalType: \"bytes4\" }],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"supportsInterface\",\n    inputs: [{ name: \"interfaceId\", type: \"bytes4\", internalType: \"bytes4\" }],\n    outputs: [{ name: \"\", type: \"bool\", internalType: \"bool\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"event\",\n    name: \"Executed\",\n    inputs: [\n      { name: \"to\", type: \"address\", indexed: true, internalType: \"address\" },\n      {\n        name: \"value\",\n        type: \"uint256\",\n        indexed: false,\n        internalType: \"uint256\",\n      },\n      { name: \"data\", type: \"bytes\", indexed: false, internalType: \"bytes\" },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"event\",\n    name: \"SessionCreated\",\n    inputs: [\n      {\n        name: \"signer\",\n        type: \"address\",\n        indexed: true,\n        internalType: \"address\",\n      },\n      {\n        name: \"sessionSpec\",\n        type: \"tuple\",\n        indexed: false,\n        internalType: \"struct SessionLib.SessionSpec\",\n        components: [\n          { name: \"signer\", type: \"address\", internalType: \"address\" },\n          { name: \"isWildcard\", type: \"bool\", internalType: \"bool\" },\n          { name: \"expiresAt\", type: \"uint256\", internalType: \"uint256\" },\n          {\n            name: \"callPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.CallSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n              {\n                name: \"constraints\",\n                type: \"tuple[]\",\n                internalType: \"struct SessionLib.Constraint[]\",\n                components: [\n                  {\n                    name: \"condition\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.Condition\",\n                  },\n                  { name: \"index\", type: \"uint64\", internalType: \"uint64\" },\n                  {\n                    name: \"refValue\",\n                    type: \"bytes32\",\n                    internalType: \"bytes32\",\n                  },\n                  {\n                    name: \"limit\",\n                    type: \"tuple\",\n                    internalType: \"struct SessionLib.UsageLimit\",\n                    components: [\n                      {\n                        name: \"limitType\",\n                        type: \"uint8\",\n                        internalType: \"enum SessionLib.LimitType\",\n                      },\n                      {\n                        name: \"limit\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                      {\n                        name: \"period\",\n                        type: \"uint256\",\n                        internalType: \"uint256\",\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            name: \"transferPolicies\",\n            type: \"tuple[]\",\n            internalType: \"struct SessionLib.TransferSpec[]\",\n            components: [\n              { name: \"target\", type: \"address\", internalType: \"address\" },\n              {\n                name: \"maxValuePerUse\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n              },\n              {\n                name: \"valueLimit\",\n                type: \"tuple\",\n                internalType: \"struct SessionLib.UsageLimit\",\n                components: [\n                  {\n                    name: \"limitType\",\n                    type: \"uint8\",\n                    internalType: \"enum SessionLib.LimitType\",\n                  },\n                  { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n                  { name: \"period\", type: \"uint256\", internalType: \"uint256\" },\n                ],\n              },\n            ],\n          },\n          { name: \"uid\", type: \"bytes32\", internalType: \"bytes32\" },\n        ],\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"event\",\n    name: \"ValueReceived\",\n    inputs: [\n      { name: \"from\", type: \"address\", indexed: true, internalType: \"address\" },\n      {\n        name: \"value\",\n        type: \"uint256\",\n        indexed: false,\n        internalType: \"uint256\",\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: \"error\",\n    name: \"AllowanceExceeded\",\n    inputs: [\n      { name: \"allowanceUsage\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"period\", type: \"uint64\", internalType: \"uint64\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"CallPolicyViolated\",\n    inputs: [\n      { name: \"target\", type: \"address\", internalType: \"address\" },\n      { name: \"selector\", type: \"bytes4\", internalType: \"bytes4\" },\n    ],\n  },\n  { type: \"error\", name: \"CallReverted\", inputs: [] },\n  {\n    type: \"error\",\n    name: \"ConditionFailed\",\n    inputs: [\n      { name: \"param\", type: \"bytes32\", internalType: \"bytes32\" },\n      { name: \"refValue\", type: \"bytes32\", internalType: \"bytes32\" },\n      { name: \"condition\", type: \"uint8\", internalType: \"uint8\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"InvalidDataLength\",\n    inputs: [\n      { name: \"actualLength\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"expectedLength\", type: \"uint256\", internalType: \"uint256\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"InvalidSignature\",\n    inputs: [\n      { name: \"msgSender\", type: \"address\", internalType: \"address\" },\n      { name: \"thisAddress\", type: \"address\", internalType: \"address\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"LifetimeUsageExceeded\",\n    inputs: [\n      { name: \"lifetimeUsage\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"limit\", type: \"uint256\", internalType: \"uint256\" },\n    ],\n  },\n  {\n    type: \"error\",\n    name: \"MaxValueExceeded\",\n    inputs: [\n      { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n      { name: \"maxValuePerUse\", type: \"uint256\", internalType: \"uint256\" },\n    ],\n  },\n  { type: \"error\", name: \"NoCallsToExecute\", inputs: [] },\n  { type: \"error\", name: \"SessionExpired\", inputs: [] },\n  { type: \"error\", name: \"SessionExpiresTooSoon\", inputs: [] },\n  { type: \"error\", name: \"SessionZeroSigner\", inputs: [] },\n  {\n    type: \"error\",\n    name: \"TransferPolicyViolated\",\n    inputs: [{ name: \"target\", type: \"address\", internalType: \"address\" }],\n  },\n  { type: \"error\", name: \"UIDAlreadyProcessed\", inputs: [] },\n] as const;\n", "import { ethereum } from \"../../../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport {\n  type SocialAuthOption,\n  socialAuthOptions,\n} from \"../../../../wallets/types.js\";\nimport type {\n  EcosystemWalletConnectionOptions,\n  EcosystemWalletCreationOptions,\n} from \"../../../ecosystem/types.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport type { SmartWalletOptions } from \"../../../smart/types.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n  WalletAutoConnectionOption,\n  WalletId,\n} from \"../../../wallet-types.js\";\nimport { create7702MinimalAccount } from \"../eip7702/minimal-account.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport type {\n  ExecutionModeOptions,\n  InAppWalletConnectionOptions,\n  InAppWalletCreationOptions,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is an in-app wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an in-app wallet, false otherwise.\n */\nexport function isInAppWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"inApp\" | \"embedded\"> {\n  return wallet.id === \"inApp\" || wallet.id === \"embedded\";\n}\n\n/**\n * @internal\n */\nexport async function connectInAppWallet(\n  options: InAppWalletConnectionOptions | EcosystemWalletConnectionOptions,\n  createOptions: InAppWalletCreationOptions | EcosystemWalletCreationOptions,\n  connector: InAppConnector,\n): Promise<{ account: Account; chain: Chain; adminAccount?: Account }> {\n  if (\n    // if auth mode is not specified, the default is popup\n    createOptions?.auth?.mode !== \"popup\" &&\n    createOptions?.auth?.mode !== undefined &&\n    connector.authenticateWithRedirect\n  ) {\n    const strategy = options.strategy;\n    if (socialAuthOptions.includes(strategy as SocialAuthOption)) {\n      await connector.authenticateWithRedirect(\n        strategy as SocialAuthOption,\n        createOptions?.auth?.mode,\n        createOptions?.auth?.redirectUrl,\n      );\n    }\n  }\n  // If we don't have authenticateWithRedirect then it's likely react native, so the default is to redirect and we can carry on\n  // IF WE EVER ADD MORE CONNECTOR TYPES, this could cause redirect to be ignored despite being specified\n  // TODO: In V6, make everything redirect auth\n\n  const authResult = await connector.connect(options);\n  const authAccount = authResult.user.account;\n\n  return createInAppAccount({\n    authAccount,\n    client: options.client,\n    createOptions,\n    desiredChain: options.chain,\n  });\n}\n\n/**\n * @internal\n */\nexport async function autoConnectInAppWallet(\n  options:\n    | WalletAutoConnectionOption<\"inApp\">\n    | WalletAutoConnectionOption<EcosystemWalletId>,\n  createOptions:\n    | CreateWalletArgs<\"inApp\">[1]\n    | CreateWalletArgs<EcosystemWalletId>[1],\n  connector: InAppConnector,\n): Promise<{ account: Account; chain: Chain; adminAccount?: Account }> {\n  if (options.authResult && connector.loginWithAuthToken) {\n    await connector.loginWithAuthToken(options.authResult);\n  }\n\n  const user = await getAuthenticatedUser(connector);\n  if (!user) {\n    throw new Error(\"Failed to authenticate user.\");\n  }\n\n  const authAccount = user.account;\n\n  return createInAppAccount({\n    authAccount,\n    client: options.client,\n    createOptions,\n    desiredChain: options.chain,\n  });\n}\n\nasync function convertToSmartAccount(options: {\n  client: ThirdwebClient;\n  authAccount: Account;\n  smartAccountOptions: CreateWalletArgs<\"smart\">[1];\n  chain?: Chain;\n}) {\n  const { connectSmartAccount } = await import(\"../../../smart/index.js\");\n\n  return connectSmartAccount(\n    {\n      chain: options.chain,\n      client: options.client,\n      personalAccount: options.authAccount,\n    },\n    options.smartAccountOptions,\n  );\n}\n\nasync function getAuthenticatedUser(connector: InAppConnector) {\n  const user = await connector.getUser();\n  switch (user.status) {\n    case \"Logged In, Wallet Initialized\": {\n      return user;\n    }\n  }\n  return undefined;\n}\n\nasync function createInAppAccount(options: {\n  client: ThirdwebClient;\n  authAccount: Account;\n  createOptions: InAppWalletCreationOptions | EcosystemWalletCreationOptions;\n  desiredChain?: Chain;\n}) {\n  const { createOptions, authAccount, desiredChain, client } = options;\n  let smartAccountOptions: SmartWalletOptions | undefined;\n  let eip7702: Extract<ExecutionModeOptions, { mode: \"EIP7702\" }> | undefined;\n  const executionMode =\n    createOptions && \"executionMode\" in createOptions\n      ? createOptions.executionMode\n      : undefined;\n\n  if (executionMode) {\n    if (executionMode.mode === \"EIP4337\") {\n      smartAccountOptions = executionMode.smartAccount;\n    } else if (executionMode.mode === \"EIP7702\") {\n      eip7702 = executionMode;\n    }\n  }\n\n  // backwards compatibility\n  if (\n    createOptions &&\n    \"smartAccount\" in createOptions &&\n    createOptions?.smartAccount\n  ) {\n    smartAccountOptions = createOptions.smartAccount;\n  }\n\n  if (smartAccountOptions) {\n    const [account, chain] = await convertToSmartAccount({\n      authAccount,\n      chain: desiredChain,\n      client,\n      smartAccountOptions,\n    });\n    return { account, adminAccount: authAccount, chain };\n  }\n\n  if (eip7702) {\n    const chain = desiredChain;\n    if (!chain) {\n      throw new Error(\n        \"Chain is required for EIP-7702 execution, pass a chain when connecting the inAppWallet.\",\n      );\n    }\n    const account = create7702MinimalAccount({\n      adminAccount: authAccount,\n      client,\n      sponsorGas: eip7702.sponsorGas,\n    });\n    return {\n      account,\n      adminAccount: authAccount,\n      chain,\n    };\n  }\n\n  return { account: authAccount, chain: desiredChain || ethereum } as const;\n}\n"],
  "mappings": "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",
  "names": ["client"]
}
