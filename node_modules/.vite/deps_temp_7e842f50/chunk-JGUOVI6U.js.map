{
  "version": 3,
  "sources": ["../../thirdweb/src/insight/get-nfts.ts"],
  "sourcesContent": ["import type {\n  GetV1NftsByContractAddressByTokenIdData,\n  GetV1NftsByContractAddressData,\n  GetV1NftsByContractAddressResponse,\n  GetV1NftsData,\n  GetV1NftsResponse,\n} from \"@thirdweb-dev/insight\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getContract } from \"../contract/contract.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { NFT } from \"../utils/nft/parseNft.js\";\n\ntype OwnedNFT = GetV1NftsResponse[\"data\"][number];\ntype ContractNFT = GetV1NftsByContractAddressResponse[\"data\"][number];\n\n/**\n * Get NFTs owned by an address\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nfts = await Insight.getOwnedNFTs({\n *   client,\n *   chains: [sepolia],\n *   ownerAddress: \"0x1234567890123456789012345678901234567890\",\n * });\n * ```\n * @insight\n */\nexport async function getOwnedNFTs(args: {\n  client: ThirdwebClient;\n  chains: Chain[];\n  ownerAddress: string;\n  contractAddresses?: string[];\n  includeMetadata?: boolean;\n  queryOptions?: Omit<GetV1NftsData[\"query\"], \"owner_address\" | \"chain\">;\n}): Promise<(NFT & { quantityOwned: bigint })[]> {\n  const [\n    { getV1Nfts },\n    { getThirdwebDomains },\n    { getClientFetch },\n    { assertInsightEnabled },\n    { stringify },\n  ] = await Promise.all([\n    import(\"@thirdweb-dev/insight\"),\n    import(\"../utils/domains.js\"),\n    import(\"../utils/fetch.js\"),\n    import(\"./common.js\"),\n    import(\"viem\"),\n  ]);\n\n  const { client, chains, ownerAddress, contractAddresses, queryOptions } =\n    args;\n\n  await assertInsightEnabled(chains);\n\n  const defaultQueryOptions: GetV1NftsData[\"query\"] = {\n    chain: chains.map((chain) => chain.id),\n    // metadata: includeMetadata ? \"true\" : \"false\", TODO (insight): add support for this\n    limit: 50,\n    owner_address: [ownerAddress],\n    contract_address: contractAddresses ? contractAddresses : undefined,\n  };\n\n  const result = await getV1Nfts({\n    baseUrl: `https://${getThirdwebDomains().insight}`,\n    fetch: getClientFetch(client),\n    query: {\n      ...defaultQueryOptions,\n      ...queryOptions,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(\n      `${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : \"Unknown error\"}`,\n    );\n  }\n\n  const transformedNfts = await transformNFTModel(\n    result.data?.data ?? [],\n    client,\n    ownerAddress,\n  );\n  return transformedNfts.map((nft) => ({\n    ...nft,\n    quantityOwned: nft.quantityOwned ?? 1n,\n  }));\n}\n\n/**\n * Get all NFTs from a contract\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nfts = await Insight.getContractNFTs({\n *   client,\n *   chains: [sepolia],\n *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n * });\n * ```\n * @insight\n */\nexport async function getContractNFTs(args: {\n  client: ThirdwebClient;\n  chains: Chain[];\n  contractAddress: string;\n  includeMetadata?: boolean;\n  includeOwners?: boolean;\n  queryOptions?: Omit<GetV1NftsByContractAddressData[\"query\"], \"chain\">;\n}): Promise<NFT[]> {\n  const [\n    { getV1NftsByContractAddress },\n    { getThirdwebDomains },\n    { getClientFetch },\n    { assertInsightEnabled },\n    { stringify },\n  ] = await Promise.all([\n    import(\"@thirdweb-dev/insight\"),\n    import(\"../utils/domains.js\"),\n    import(\"../utils/fetch.js\"),\n    import(\"./common.js\"),\n    import(\"../utils/json.js\"),\n  ]);\n\n  const {\n    client,\n    chains,\n    contractAddress,\n    includeOwners = true,\n    queryOptions,\n  } = args;\n\n  const defaultQueryOptions: GetV1NftsByContractAddressData[\"query\"] = {\n    chain: chains.map((chain) => chain.id),\n    include_owners:\n      includeOwners === true ? (\"true\" as const) : (\"false\" as const),\n    // metadata: includeMetadata ? \"true\" : \"false\", TODO (insight): add support for this\n    limit: 50,\n  };\n\n  await assertInsightEnabled(chains);\n\n  const result = await getV1NftsByContractAddress({\n    baseUrl: `https://${getThirdwebDomains().insight}`,\n    fetch: getClientFetch(client),\n    path: {\n      contract_address: contractAddress,\n    },\n    query: {\n      ...defaultQueryOptions,\n      ...queryOptions,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(\n      `${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : \"Unknown error\"}`,\n    );\n  }\n\n  return transformNFTModel(result.data?.data ?? [], client);\n}\n\n/**\n * Get NFT metadata by contract address and token id\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nft = await Insight.getNFT({\n *   client,\n *   chain: sepolia,\n *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n *   tokenId: 1n,\n * });\n * ```\n * @insight\n */\nexport async function getNFT(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  contractAddress: string;\n  tokenId: bigint | number | string;\n  includeOwners?: boolean;\n  queryOptions?: GetV1NftsByContractAddressByTokenIdData[\"query\"];\n}): Promise<NFT | undefined> {\n  const [\n    { getV1NftsByContractAddressByTokenId },\n    { getThirdwebDomains },\n    { getClientFetch },\n    { assertInsightEnabled },\n    { stringify },\n  ] = await Promise.all([\n    import(\"@thirdweb-dev/insight\"),\n    import(\"../utils/domains.js\"),\n    import(\"../utils/fetch.js\"),\n    import(\"./common.js\"),\n    import(\"../utils/json.js\"),\n  ]);\n\n  const {\n    client,\n    chain,\n    contractAddress,\n    tokenId,\n    includeOwners = true,\n    queryOptions,\n  } = args;\n\n  await assertInsightEnabled([chain]);\n\n  const defaultQueryOptions: GetV1NftsByContractAddressByTokenIdData[\"query\"] =\n    {\n      chain_id: [chain.id],\n      include_owners:\n        includeOwners === true ? (\"true\" as const) : (\"false\" as const),\n    };\n\n  const result = await getV1NftsByContractAddressByTokenId({\n    baseUrl: `https://${getThirdwebDomains().insight}`,\n    fetch: getClientFetch(client),\n    path: {\n      contract_address: contractAddress,\n      token_id: tokenId.toString(),\n    },\n    query: {\n      ...defaultQueryOptions,\n      ...queryOptions,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(\n      `${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : \"Unknown error\"}`,\n    );\n  }\n\n  const transformedNfts = await transformNFTModel(\n    result.data?.data ?? [],\n    client,\n  );\n  return transformedNfts?.[0];\n}\n\nasync function transformNFTModel(\n  nfts: (ContractNFT | OwnedNFT)[],\n  client: ThirdwebClient,\n  ownerAddress?: string,\n): Promise<(NFT & { quantityOwned?: bigint })[]> {\n  const [{ parseNFT }, { totalSupply }] = await Promise.all([\n    import(\"../utils/nft/parseNft.js\"),\n    import(\"../extensions/erc1155/__generated__/IERC1155/read/totalSupply.js\"),\n  ]);\n\n  return await Promise.all(\n    nfts.map(async (nft) => {\n      let parsedNft: NFT;\n      const {\n        contract,\n\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        extra_metadata,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        collection,\n        metadata_url,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        chain_id,\n        token_id,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        status,\n        balance,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        token_type,\n        ...rest\n      } = nft;\n\n      let metadataToUse = rest;\n      let owners: string[] | undefined = ownerAddress\n        ? [getAddress(ownerAddress)]\n        : undefined;\n\n      if (\"owner_addresses\" in rest) {\n        const { owner_addresses, ...restWithoutOwnerAddresses } = rest;\n        metadataToUse = restWithoutOwnerAddresses;\n        owners = owners ?? owner_addresses?.map((o) => getAddress(o));\n      }\n\n      const metadata = replaceIPFSGatewayRecursively({\n        attributes: nft.extra_metadata?.attributes ?? undefined,\n        image: nft.image_url,\n        uri: nft.metadata_url ?? \"\",\n        ...metadataToUse,\n      });\n\n      if (contract?.type === \"erc1155\") {\n        // TODO (insight): this needs to be added in the API\n        const supply = await totalSupply({\n          contract: getContract({\n            address: contract.address,\n            chain: getCachedChain(contract.chain_id),\n            client: client,\n          }),\n          id: BigInt(token_id),\n        }).catch(() => 0n);\n\n        parsedNft = parseNFT(metadata, {\n          chainId: contract?.chain_id ?? 0,\n          owner: owners?.[0],\n          supply: supply,\n          tokenAddress: contract?.address ?? \"\",\n          tokenId: BigInt(token_id),\n          tokenUri: replaceIPFSGateway(metadata_url) ?? \"\",\n          type: \"ERC1155\",\n        });\n      } else {\n        parsedNft = parseNFT(metadata, {\n          chainId: contract?.chain_id ?? 0,\n          owner: owners?.[0],\n          tokenAddress: contract?.address ?? \"\",\n          tokenId: BigInt(token_id),\n          tokenUri: replaceIPFSGateway(metadata_url) ?? \"\",\n          type: \"ERC721\",\n        });\n      }\n\n      return {\n        ...parsedNft,\n        ...(contract?.type === \"erc1155\"\n          ? { quantityOwned: balance ? BigInt(balance) : undefined }\n          : {}),\n      };\n    }),\n  );\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: this should be fixed in the API\nfunction replaceIPFSGatewayRecursively(obj: any) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n  for (const key in obj) {\n    if (typeof obj[key] === \"string\") {\n      obj[key] = replaceIPFSGateway(obj[key]);\n    } else {\n      replaceIPFSGatewayRecursively(obj[key]);\n    }\n  }\n  return obj;\n}\n\nfunction replaceIPFSGateway(url?: string) {\n  if (!url || typeof url !== \"string\") {\n    return url;\n  }\n  try {\n    const parsedUrl = new URL(url);\n    if (parsedUrl.host.endsWith(\".ipfscdn.io\")) {\n      const paths = parsedUrl.pathname.split(\"/\");\n      const index = paths.findIndex((path) => path === \"ipfs\");\n      if (index === -1) {\n        return url;\n      }\n      const ipfsHash = paths.slice(index + 1).join(\"/\");\n      if (ipfsHash) {\n        return `ipfs://${ipfsHash}`;\n      }\n      return url;\n    }\n  } catch {\n    // If the URL is invalid, return it as is\n    return url;\n  }\n  return url;\n}\n"],
  "mappings": "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",
  "names": []
}
