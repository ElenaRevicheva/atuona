import {
  getNFT
} from "./chunk-SNVLND6U.js";
import {
  getOwnedNFTs
} from "./chunk-JGUOVI6U.js";
import {
  readContract
} from "./chunk-SEW5WUFU.js";

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721A/read/balanceOf.js
var FN_SELECTOR = "0x70a08231";
var FN_INPUTS = [
  {
    name: "owner",
    type: "address"
  }
];
var FN_OUTPUTS = [
  {
    type: "uint256"
  }
];
async function balanceOf(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: [options.owner]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721AQueryable/read/tokensOfOwner.js
var FN_SELECTOR2 = "0x8462151c";
var FN_INPUTS2 = [
  {
    name: "owner",
    type: "address"
  }
];
var FN_OUTPUTS2 = [
  {
    type: "uint256[]"
  }
];
async function tokensOfOwner(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR2, FN_INPUTS2, FN_OUTPUTS2],
    params: [options.owner]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/__generated__/IERC721Enumerable/read/tokenOfOwnerByIndex.js
var FN_SELECTOR3 = "0x2f745c59";
var FN_INPUTS3 = [
  {
    name: "_owner",
    type: "address"
  },
  {
    name: "_index",
    type: "uint256"
  }
];
var FN_OUTPUTS3 = [
  {
    type: "uint256"
  }
];
async function tokenOfOwnerByIndex(options) {
  return readContract({
    contract: options.contract,
    method: [FN_SELECTOR3, FN_INPUTS3, FN_OUTPUTS3],
    params: [options.owner, options.index]
  });
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/getOwnedTokenIds.js
async function getOwnedTokenIds(options) {
  const result = await Promise.any([
    // get all the tokens owned by the owner
    tokensOfOwner({ ...options }),
    // get the balance of the owner and then fetch each token ID
    // this is the "fallback" path really
    (async () => {
      const balanceOfResult = await balanceOf(options);
      const promises = [];
      for (let i = 0n; i < balanceOfResult; i++) {
        promises.push(tokenOfOwnerByIndex({ ...options, index: i }));
      }
      return Promise.all(promises);
    })()
  ]).catch(() => null);
  if (result) {
    return result;
  }
  throw new Error(`The contract at ${options.contract.address} on chain ${options.contract.chain.id} does not support the tokenOfOwnerByIndex or tokensOfOwner interface`);
}

// node_modules/thirdweb/dist/esm/extensions/erc721/read/getOwnedNFTs.js
async function getOwnedNFTs2(options) {
  const { useIndexer = true } = options;
  if (useIndexer) {
    try {
      return await getOwnedNFTsFromInsight(options);
    } catch {
      return await getOwnedNFTsFromRPC(options);
    }
  }
  return await getOwnedNFTsFromRPC(options);
}
async function getOwnedNFTsFromRPC(options) {
  const tokenIds = await getOwnedTokenIds(options);
  return Promise.all(tokenIds.map((tokenId) => getNFT({
    contract: options.contract,
    tokenId,
    useIndexer: false
  }).then((nft) => ({
    ...nft,
    // add the owner to the NFT since we know it
    owner: options.owner
  }))));
}
async function getOwnedNFTsFromInsight(options) {
  const limit = 50;
  const nfts = [];
  let page = 0;
  let hasMore = true;
  while (hasMore) {
    const pageResults = await getOwnedNFTs({
      chains: [options.contract.chain],
      client: options.contract.client,
      ownerAddress: options.owner,
      contractAddresses: [options.contract.address],
      queryOptions: {
        limit,
        page
      }
    });
    nfts.push(...pageResults);
    if (pageResults.length < limit) {
      hasMore = false;
    } else {
      page++;
    }
  }
  const results = nfts;
  return results.filter((n) => n.tokenAddress.toLowerCase() === options.contract.address.toLowerCase()).map((result) => ({
    ...result,
    owner: options.owner
  }));
}

export {
  balanceOf,
  tokensOfOwner,
  tokenOfOwnerByIndex,
  getOwnedTokenIds,
  getOwnedNFTs2 as getOwnedNFTs
};
//# sourceMappingURL=chunk-QKTRHKFG.js.map
