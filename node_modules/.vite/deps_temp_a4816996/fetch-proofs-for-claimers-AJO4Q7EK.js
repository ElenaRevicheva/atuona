import {
  MerkleTree,
  convertQuantity,
  hashEntry
} from "./chunk-ECRBHC56.js";
import "./chunk-43F4DZXD.js";
import {
  ZERO_ADDRESS,
  isNativeTokenAddress
} from "./chunk-YCZ3YGMG.js";
import "./chunk-PF7J76SD.js";
import "./chunk-HAADYJEF.js";
import {
  download
} from "./chunk-ALXM2V2D.js";
import "./chunk-JTQFPYF6.js";
import "./chunk-EAI6ZE6R.js";
import "./chunk-SJUTDOTM.js";
import "./chunk-2OMZKD5Y.js";
import "./chunk-UG6X6BL6.js";
import "./chunk-4HC36SBT.js";
import "./chunk-HXWRQBIO.js";
import "./chunk-FLUAB4EX.js";
import "./chunk-KWGI5LSL.js";
import "./chunk-6JZ5SMSC.js";
import "./chunk-AMOBGZPQ.js";
import "./chunk-Q7YW2IAU.js";
import "./chunk-XEGDYWOA.js";
import "./chunk-3HQSRVBD.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-HARK4W7T.js";
import "./chunk-5JRVV4XU.js";

// node_modules/thirdweb/dist/esm/utils/extensions/drops/fetch-proofs-for-claimers.js
async function fetchProofsForClaimer(options) {
  const { contract, merkleTreeUri, claimer } = options;
  const hashEntryFn = options.hashEntry || hashEntry;
  const response = await download({
    client: contract.client,
    uri: merkleTreeUri
  });
  const merkleInfo = await response.json();
  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();
  const uri = merkleInfo.baseUri.endsWith("/") ? merkleInfo.baseUri : `${merkleInfo.baseUri}/`;
  let shardData;
  try {
    const constructedShardUri = `${uri}${shardId}.json`;
    const shard = await download({
      client: contract.client,
      uri: constructedShardUri
    });
    shardData = await shard.json();
  } catch {
    return null;
  }
  const hashedEntries = await Promise.all(shardData.entries.map(async (entry2) => {
    return hashEntryFn({
      chain: contract.chain,
      client: contract.client,
      entry: entry2,
      tokenDecimals: options.tokenDecimals
    });
  }));
  const tree = new MerkleTree(hashedEntries);
  const entry = shardData.entries.find((i) => i.address.toLowerCase() === claimer.toLowerCase());
  if (!entry) {
    return null;
  }
  const proof = tree.getHexProof(await hashEntryFn({
    chain: contract.chain,
    client: contract.client,
    entry,
    tokenDecimals: options.tokenDecimals
  })).concat(shardData.proofs);
  const currencyAddress = entry.currencyAddress || ZERO_ADDRESS;
  const currencyDecimals = await (async () => {
    if (isNativeTokenAddress(currencyAddress) || currencyAddress === ZERO_ADDRESS) {
      return 18;
    }
    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([
      import("./contract-IBKKXUVN.js"),
      import("./decimals-5JDGCXOA.js")
    ]);
    const currencyContract = getContract({
      address: currencyAddress,
      chain: contract.chain,
      client: contract.client
    });
    return await getDecimals({ contract: currencyContract });
  })();
  return {
    currency: currencyAddress,
    pricePerToken: convertQuantity({
      quantity: entry.price || "unlimited",
      tokenDecimals: currencyDecimals
    }),
    proof,
    quantityLimitPerWallet: convertQuantity({
      quantity: entry.maxClaimable || "unlimited",
      tokenDecimals: options.tokenDecimals
    })
  };
}
export {
  fetchProofsForClaimer
};
//# sourceMappingURL=fetch-proofs-for-claimers-AJO4Q7EK.js.map
