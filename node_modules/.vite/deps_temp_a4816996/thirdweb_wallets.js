import {
  autoConnectCore,
  createConnectionManager
} from "./chunk-UHHNEWHK.js";
import {
  DefaultWalletConnectRequestHandlers,
  createWalletConnectClient,
  createWalletConnectSession,
  disconnectWalletConnectSession,
  getActiveWalletConnectSessions
} from "./chunk-A5ZD36QN.js";
import "./chunk-AWNHAHOL.js";
import "./chunk-Z5TBZCQY.js";
import {
  getDefaultWallets
} from "./chunk-5KWHFZJV.js";
import "./chunk-QDBWT3BO.js";
import "./chunk-S7DKPFNN.js";
import "./chunk-FUPOJN5U.js";
import {
  getWalletBalance
} from "./chunk-DE3EJMJP.js";
import {
  authenticate,
  authenticateWithRedirect,
  getProfiles,
  getUserEmail,
  getUserPhoneNumber,
  linkProfile,
  preAuthenticate,
  unlinkProfile
} from "./chunk-T4NAPAWR.js";
import {
  autoConnectEip1193Wallet,
  connectEip1193Wallet,
  createWallet,
  ecosystemWallet,
  getInstalledWalletProviders,
  getInstalledWallets,
  inAppWallet,
  injectedProvider,
  smartWallet,
  walletConnect
} from "./chunk-OCHDCHHC.js";
import {
  createWalletEmitter,
  trackConnect
} from "./chunk-XK6VFSJZ.js";
import "./chunk-2BPWCJWN.js";
import "./chunk-NCVQ56IM.js";
import "./chunk-67YIWUOQ.js";
import {
  getWalletInfo
} from "./chunk-O4IML4YE.js";
import "./chunk-NOQHPE4Q.js";
import "./chunk-N5GRE3NC.js";
import "./chunk-5GPJCQB3.js";
import "./chunk-LWBFBP2R.js";
import "./chunk-73JNH2S7.js";
import "./chunk-22D2ZAQ3.js";
import "./chunk-Y3TOHAVT.js";
import "./chunk-WVFU53OI.js";
import "./chunk-QDEEV5NE.js";
import "./chunk-I5UI2NGW.js";
import "./chunk-FUW7UPWG.js";
import {
  webLocalStorage
} from "./chunk-PAAPSL3C.js";
import "./chunk-YTVGBUSR.js";
import "./chunk-CFGTC2OQ.js";
import {
  getUser,
  signTransaction
} from "./chunk-EB4U7WJN.js";
import {
  deploySmartAccount
} from "./chunk-TLI32TZB.js";
import "./chunk-SFNWABZF.js";
import {
  getSignPayload as getSignPayload2,
  randomPrivateKey,
  sign
} from "./chunk-2OTGZCEV.js";
import "./chunk-RFFTPTNE.js";
import "./chunk-DTUZQZSY.js";
import {
  sendTransaction
} from "./chunk-XS7FEBDW.js";
import "./chunk-VONE2WQV.js";
import "./chunk-LM2JWCXW.js";
import {
  getSignPayload as getSignPayload3
} from "./chunk-YBIOJZBF.js";
import "./chunk-T2CMYCFM.js";
import "./chunk-IZKCGR2B.js";
import "./chunk-424DSV6F.js";
import "./chunk-KJIOWHTG.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  from,
  getSignPayload
} from "./chunk-OX6B746W.js";
import {
  secp256k1,
  toHex as toHex2
} from "./chunk-DGSDI26V.js";
import "./chunk-HLJODQME.js";
import "./chunk-5R7S7VX2.js";
import "./chunk-2BVO2OWV.js";
import "./chunk-OIIGC4IN.js";
import "./chunk-QZ5EZLGO.js";
import "./chunk-MKB46BXW.js";
import "./chunk-2JJ5MRMB.js";
import "./chunk-NACC2RRT.js";
import "./chunk-2DKD2QB6.js";
import "./chunk-OWCPC6AZ.js";
import "./chunk-DAHYFYVF.js";
import {
  prepareTransaction
} from "./chunk-FHM7BLOT.js";
import "./chunk-2RIDIBOQ.js";
import "./chunk-YCZ3YGMG.js";
import "./chunk-DGWZEIL6.js";
import "./chunk-PF7J76SD.js";
import "./chunk-GYLVPM2U.js";
import "./chunk-Q7I3EUQG.js";
import {
  estimateGas
} from "./chunk-WZWH6DQ2.js";
import "./chunk-QP4NW4MI.js";
import "./chunk-7OH7LVST.js";
import "./chunk-L4NN5UUQ.js";
import "./chunk-HAADYJEF.js";
import "./chunk-ALXM2V2D.js";
import "./chunk-JTQFPYF6.js";
import "./chunk-EAI6ZE6R.js";
import "./chunk-SJUTDOTM.js";
import "./chunk-7ZAXHZVK.js";
import {
  publicKeyToAddress
} from "./chunk-2OMZKD5Y.js";
import "./chunk-UG6X6BL6.js";
import "./chunk-4HC36SBT.js";
import "./chunk-HXWRQBIO.js";
import "./chunk-FLUAB4EX.js";
import {
  getRpcClient
} from "./chunk-B5MBRYI6.js";
import {
  getAddress
} from "./chunk-KWGI5LSL.js";
import "./chunk-6JZ5SMSC.js";
import "./chunk-AMOBGZPQ.js";
import {
  hexToNumber,
  isHex,
  toHex
} from "./chunk-Q7YW2IAU.js";
import {
  fromNumber,
  fromString,
  toNumber
} from "./chunk-XEGDYWOA.js";
import "./chunk-2CIJO3V3.js";
import "./chunk-OWPJAJVA.js";
import "./chunk-D2TAUU6E.js";
import {
  getCachedChain,
  getCachedChainIfExists
} from "./chunk-SPUJ3V7I.js";
import "./chunk-G24WGTAU.js";
import "./chunk-3HQSRVBD.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-PPP72TBL.js";
import "./chunk-HARK4W7T.js";
import {
  __export
} from "./chunk-5JRVV4XU.js";

// node_modules/thirdweb/dist/esm/adapters/eip1193/index.js
var eip1193_exports = {};
__export(eip1193_exports, {
  fromProvider: () => fromProvider,
  toProvider: () => toProvider
});

// node_modules/thirdweb/dist/esm/adapters/eip1193/from-eip1193.js
function fromProvider(options) {
  const id = options.walletId ?? "adapter";
  const emitter = createWalletEmitter();
  let account;
  let chain;
  let provider;
  const getProvider = async (params) => {
    provider = typeof options.provider === "function" ? await options.provider(params) : options.provider;
    return provider;
  };
  const unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
    chain = newChain;
  });
  function reset() {
    account = void 0;
    chain = void 0;
  }
  let handleDisconnect = async () => {
  };
  const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
    reset();
    unsubscribeChain();
    unsubscribeDisconnect();
  });
  emitter.subscribe("accountChanged", (_account) => {
    account = _account;
  });
  let handleSwitchChain = async (c) => {
    await (provider == null ? void 0 : provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: fromNumber(c.id) }]
    }));
  };
  return {
    autoConnect: async (connectOptions) => {
      var _a;
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectEip1193Wallet({
        chain: connectOptions.chain,
        client: connectOptions.client,
        emitter,
        id,
        provider: await getProvider({ chainId: (_a = connectOptions.chain) == null ? void 0 : _a.id })
      });
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      emitter.emit("onConnect", connectOptions);
      trackConnect({
        client: connectOptions.client,
        walletAddress: account.address,
        walletType: id
      });
      return account;
    },
    connect: async (connectOptions) => {
      var _a;
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectEip1193Wallet({
        chain: connectOptions.chain,
        client: connectOptions.client,
        emitter,
        id,
        provider: await getProvider({ chainId: (_a = connectOptions.chain) == null ? void 0 : _a.id })
      });
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      emitter.emit("onConnect", connectOptions);
      trackConnect({
        client: connectOptions.client,
        walletAddress: account.address,
        walletType: id
      });
      return account;
    },
    disconnect: async () => {
      reset();
      await handleDisconnect();
      emitter.emit("disconnect", void 0);
    },
    getAccount: () => account,
    getChain() {
      if (!chain) {
        return void 0;
      }
      chain = getCachedChainIfExists(chain.id) || chain;
      return chain;
    },
    getConfig: () => void 0,
    id,
    subscribe: emitter.subscribe,
    switchChain: async (c) => {
      await handleSwitchChain(c);
      emitter.emit("chainChanged", c);
    }
  };
}

// node_modules/thirdweb/dist/esm/adapters/eip1193/to-eip1193.js
function toProvider(options) {
  const { chain, client, wallet, connectOverride } = options;
  const rpcClient = getRpcClient({ chain, client });
  return {
    on: wallet.subscribe,
    removeListener: () => {
    },
    request: async (request) => {
      if (request.method === "eth_sendTransaction") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        const result = await sendTransaction({
          account,
          transaction: prepareTransaction({
            ...request.params[0],
            chain,
            client
          })
        });
        return result.transactionHash;
      }
      if (request.method === "eth_estimateGas") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return estimateGas({
          account,
          transaction: prepareTransaction({
            ...request.params[0],
            chain,
            client
          })
        });
      }
      if (request.method === "personal_sign") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return account.signMessage({
          message: {
            raw: request.params[0]
          }
        });
      }
      if (request.method === "eth_signTypedData_v4") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        const data = JSON.parse(request.params[1]);
        return account.signTypedData(data);
      }
      if (request.method === "eth_accounts") {
        const account = wallet.getAccount();
        if (!account) {
          return [];
        }
        return [account.address];
      }
      if (request.method === "eth_requestAccounts") {
        const connectedAccount = wallet.getAccount();
        if (connectedAccount) {
          return [connectedAccount.address];
        }
        const account = connectOverride ? await connectOverride(wallet) : await wallet.connect({
          client
        }).catch((e) => {
          console.error("Error connecting wallet", e);
          return null;
        });
        if (!account) {
          throw new Error("Unable to connect wallet - try passing a connectOverride function");
        }
        return [account.address];
      }
      if (request.method === "wallet_switchEthereumChain" || request.method === "wallet_addEthereumChain") {
        const data = request.params[0];
        const chainIdHex = data.chainId;
        if (!chainIdHex) {
          throw new Error("Chain ID is required");
        }
        const chainId = isHex(chainIdHex) ? hexToNumber(chainIdHex) : chainIdHex;
        const chain2 = getCachedChain(chainId);
        return wallet.switchChain(chain2);
      }
      return rpcClient(request);
    }
  };
}

// node_modules/thirdweb/dist/esm/adapters/wallet-adapter.js
function createWalletAdapter(options) {
  const emitter = createWalletEmitter();
  let _chain = options.chain;
  return {
    autoConnect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    connect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    disconnect: async () => {
      await options.onDisconnect();
      emitter.emit("disconnect", void 0);
    },
    getAccount() {
      return options.adaptedAccount;
    },
    getChain() {
      const cachedChain = getCachedChainIfExists(_chain.id);
      _chain = cachedChain || _chain;
      return _chain;
    },
    getConfig() {
      return options;
    },
    id: "adapter",
    subscribe: emitter.subscribe,
    switchChain: async (chain) => {
      await options.switchChain(chain);
      _chain = chain;
      emitter.emit("chainChanged", chain);
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/getAllWalletsList.js
async function getAllWalletsList() {
  return (await import("./wallet-infos-74ZJOE5I.js")).default;
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
function signMessage(options) {
  if ("privateKey" in options) {
    const payload = getSignPayload2(typeof options.message === "object" ? options.message.raw : fromString(options.message));
    const signature = sign({
      payload,
      privateKey: options.privateKey
    });
    return toHex2(signature);
  }
  if ("account" in options) {
    const { message, account } = options;
    return account.signMessage({ message });
  }
  throw new Error("Either privateKey or account is required");
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
function signTypedData(options) {
  var _a;
  const { privateKey, ...typedData } = options;
  if (typeof ((_a = typedData.domain) == null ? void 0 : _a.chainId) === "string") {
    typedData.domain.chainId = toNumber(typedData.domain.chainId);
  }
  const payload = getSignPayload3(typedData);
  const signature = sign({
    payload,
    privateKey
  });
  return toHex2(signature);
}

// node_modules/thirdweb/dist/esm/wallets/private-key.js
function privateKeyToAccount(options) {
  const { client } = options;
  const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = {
    address: getAddress(address),
    sendTransaction: async (tx) => {
      const rpcRequest = getRpcClient({
        chain: getCachedChain(tx.chainId),
        client
      });
      const signedTx = signTransaction({
        privateKey,
        transaction: tx
      });
      const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
      return {
        transactionHash
      };
    },
    signAuthorization: async (authorization) => {
      const signature = sign({
        payload: getSignPayload(authorization),
        privateKey
      });
      return from(authorization, { signature });
    },
    signMessage: async ({ message }) => {
      return signMessage({
        message,
        privateKey
      });
    },
    signTransaction: async (tx) => {
      return signTransaction({
        privateKey,
        transaction: tx
      });
    },
    signTypedData: async (_typedData) => {
      return signTypedData({
        ..._typedData,
        privateKey
      });
    }
  };
  return account;
}

// node_modules/thirdweb/dist/esm/wallets/utils/generateAccount.js
async function generateAccount(options) {
  const privateKey = toHex(secp256k1.utils.randomPrivateKey());
  return privateKeyToAccount({ client: options.client, privateKey });
}

// node_modules/thirdweb/dist/esm/wallets/connection/autoConnect.js
async function autoConnect(props) {
  const wallets = props.wallets || getDefaultWallets(props);
  const manager = createConnectionManager(webLocalStorage);
  const result = await autoConnectCore({
    createWalletFn: createWallet,
    getInstalledWallets: () => {
      const specifiedWalletIds = new Set(wallets.map((x) => x.id));
      const installedWallets = getInstalledWalletProviders().filter((x) => !specifiedWalletIds.has(x.info.rdns)).map((x) => createWallet(x.info.rdns));
      return installedWallets;
    },
    manager,
    props: {
      ...props,
      wallets
    },
    storage: webLocalStorage
  });
  return result;
}
export {
  DefaultWalletConnectRequestHandlers,
  eip1193_exports as EIP1193,
  authenticate,
  authenticateWithRedirect,
  autoConnect,
  createWallet,
  createWalletAdapter,
  createWalletConnectClient,
  createWalletConnectSession,
  deploySmartAccount,
  disconnectWalletConnectSession,
  ecosystemWallet,
  inAppWallet as embeddedWallet,
  generateAccount,
  getActiveWalletConnectSessions,
  getAllWalletsList,
  getInstalledWallets,
  getProfiles,
  getUser,
  getUserEmail,
  getUserPhoneNumber,
  getWalletBalance,
  getWalletInfo,
  inAppWallet,
  injectedProvider,
  linkProfile,
  preAuthenticate,
  privateKeyToAccount as privateKeyAccount,
  privateKeyToAccount,
  randomPrivateKey,
  smartWallet,
  unlinkProfile,
  walletConnect
};
//# sourceMappingURL=thirdweb_wallets.js.map
