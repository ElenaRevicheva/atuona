import{aK as _,aL as D,u as k,ad as A,aM as C,aN as L,aO as I,aP as q,Z as y,i as P,_ as m,g as b,aQ as p}from"./main-DpsjE5QK.js";import{e as O}from"./encodePacked-Dp1AfTzk.js";class H{constructor(e){Object.defineProperty(this,"leaves",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"layers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.leaves=e.map(t=>t instanceof Uint8Array?t:_(t)),this.leaves=this.leaves.sort(D),this.createHashes(this.leaves)}getHexRoot(){return k(this.getRoot())}getHexProof(e,t){return this.getProof(e,t).map(n=>k(n.data))}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const n=e.length;for(let r=0;r<e.length;r+=2){if(r>=n){this.layers[t].push(...e.slice(n));break}if(r+1===e.length&&e.length%2===1){this.layers[t].push(e[r]);continue}const i=e[r],s=r+1===e.length?i:e[r+1],c=[i,s];c.sort(D);const f=A(C(c),"bytes");this.layers[t].push(f)}e=this.layers[t]}}getRoot(){return this.layers.length===0?new Uint8Array:this.layers[this.layers.length-1][0]||new Uint8Array}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=e instanceof Uint8Array?e:_(e);const n=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)L(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let r=0;r<this.layers.length;r++){const i=this.layers[r],s=t%2,c=s?t-1:t+1;c<i.length&&n.push({data:i[c],position:s?"left":"right"}),t=t/2|0}return n}}function d(a){const{quantity:e,tokenDecimals:t}=a;return e==="unlimited"?I:q(e,t)}async function j(a){const e=a.entry.currencyAddress||y,t=await(async()=>{if(P(e)||e===y)return 18;const[{getContract:n},{decimals:r}]=await Promise.all([m(()=>import("./main-DpsjE5QK.js").then(s=>s.eR),[]),m(()=>import("./main-DpsjE5QK.js").then(s=>s.eT),[])]),i=n({address:e,chain:a.chain,client:a.client});return await r({contract:i})})();return A(O(["address","uint256","uint256","address"],[b(a.entry.address),d({quantity:a.entry.maxClaimable||"unlimited",tokenDecimals:a.tokenDecimals}),d({quantity:a.entry.price||"unlimited",tokenDecimals:t}),b(e)]))}async function x(a){const{contract:e,merkleTreeUri:t,claimer:n}=a,r=a.hashEntry||j,s=await(await p({client:e.client,uri:t})).json(),c=n.slice(2,2+s.shardNybbles).toLowerCase(),f=s.baseUri.endsWith("/")?s.baseUri:`${s.baseUri}/`;let h;try{const o=`${f}${c}.json`;h=await(await p({client:e.client,uri:o})).json()}catch{return null}const v=await Promise.all(h.entries.map(async o=>r({chain:e.chain,client:e.client,entry:o,tokenDecimals:a.tokenDecimals}))),E=new H(v),l=h.entries.find(o=>o.address.toLowerCase()===n.toLowerCase());if(!l)return null;const U=E.getHexProof(await r({chain:e.chain,client:e.client,entry:l,tokenDecimals:a.tokenDecimals})).concat(h.proofs),u=l.currencyAddress||y,R=await(async()=>{if(P(u)||u===y)return 18;const[{getContract:o},{decimals:w}]=await Promise.all([m(()=>import("./main-DpsjE5QK.js").then(g=>g.eR),[]),m(()=>import("./main-DpsjE5QK.js").then(g=>g.eT),[])]),T=o({address:u,chain:e.chain,client:e.client});return await w({contract:T})})();return{currency:u,pricePerToken:d({quantity:l.price||"unlimited",tokenDecimals:R}),proof:U,quantityLimitPerWallet:d({quantity:l.maxClaimable||"unlimited",tokenDecimals:a.tokenDecimals})}}export{x as fetchProofsForClaimer};
