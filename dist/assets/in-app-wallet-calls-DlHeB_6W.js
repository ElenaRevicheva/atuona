import{w as m,e as p}from"./wait-for-tx-receipt-qj-V6sLV.js";import{R as w,S as h,b4 as f,y as T}from"./main-DAjelYsw.js";import{s as b}from"./send-transaction-Cqdy5hmT.js";import{r as g}from"./random-Dh2_-Hs4.js";import"./to-serializable-transaction-DluyPVjR.js";import"./units-DR3SBGns.js";import"./download-BT9dvXJQ.js";import"./sleep-mAKpSMLY.js";async function y(c){const t=await b(c);return m(t)}async function H(c){const{account:t,transactions:o}=c;if(!t)throw new Error("not connected");if(o.length===0)throw new Error("No transactions to send");const s=o[0];if(!s)throw new Error("No transactions to send");if(t.sendBatchTransaction){const n=await Promise.all(o.map(async a=>{const[u,i,e,l]=await Promise.all([w(a),h(a.to),h(a.accessList),h(a.value)]);return{accessList:e,chainId:a.chain.id,data:u,to:i,value:l}}));return{...await t.sendBatchTransaction(n),chain:s.chain,client:s.client}}throw new Error("Account doesn't implement sendBatchTransaction")}const d=new f(1e3);async function R(c){const{account:t,calls:o}=c,s=[],n=g(65);if(d.set(n,s),t.sendBatchTransaction){const r=await H({account:t,transactions:o});s.push(r.transactionHash),d.set(n,s)}else for(const r of o){const a=await y({account:t,transaction:r});s.push(a.transactionHash),d.set(n,s)}return n}async function z(c){const{chain:t,client:o,id:s}=c,n=d.get(s);if(!n)throw new Error("Failed to get calls status, unknown bundle id");const r=T({chain:t,client:o});let a="success";const u=await Promise.all(n.map(i=>p(r,{hash:i}).then(e=>({blockHash:e.blockHash,blockNumber:e.blockNumber,gasUsed:e.gasUsed,logs:e.logs.map(l=>({address:l.address,data:l.data,topics:l.topics})),status:e.status,transactionHash:e.transactionHash})).catch(()=>(a="pending",null))));return{atomic:!1,chainId:t.id,id:s,receipts:u.filter(i=>i!==null),status:a,statusCode:200,version:"2.0.0"}}export{z as inAppWalletGetCallsStatus,R as inAppWalletSendCalls};
