import{aI as _,aJ as D,u as k,a5 as A,aK as L,aL as R,aM as T,aN as q,a6 as y,aO as P,_ as m,h as b,aP as p}from"./main-xw8jArdM.js";import{e as O}from"./encodePacked-CpWcBfAM.js";class H{constructor(e){Object.defineProperty(this,"leaves",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"layers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.leaves=e.map(t=>t instanceof Uint8Array?t:_(t)),this.leaves=this.leaves.sort(D),this.createHashes(this.leaves)}getHexRoot(){return k(this.getRoot())}getHexProof(e,t){return this.getProof(e,t).map(n=>k(n.data))}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const n=e.length;for(let r=0;r<e.length;r+=2){if(r>=n){this.layers[t].push(...e.slice(n));break}if(r+1===e.length&&e.length%2===1){this.layers[t].push(e[r]);continue}const i=e[r],s=r+1===e.length?i:e[r+1],c=[i,s];c.sort(D);const f=A(L(c),"bytes");this.layers[t].push(f)}e=this.layers[t]}}getRoot(){return this.layers.length===0?new Uint8Array:this.layers[this.layers.length-1][0]||new Uint8Array}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=e instanceof Uint8Array?e:_(e);const n=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)R(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let r=0;r<this.layers.length;r++){const i=this.layers[r],s=t%2,c=s?t-1:t+1;c<i.length&&n.push({data:i[c],position:s?"left":"right"}),t=t/2|0}return n}}function d(a){const{quantity:e,tokenDecimals:t}=a;return e==="unlimited"?T:q(e,t)}async function j(a){const e=a.entry.currencyAddress||y,t=await(async()=>{if(P(e)||e===y)return 18;const[{getContract:n},{decimals:r}]=await Promise.all([m(()=>import("./main-xw8jArdM.js").then(s=>s.gl),[]),m(()=>import("./main-xw8jArdM.js").then(s=>s.gn),[])]),i=n({address:e,chain:a.chain,client:a.client});return await r({contract:i})})();return A(O(["address","uint256","uint256","address"],[b(a.entry.address),d({quantity:a.entry.maxClaimable||"unlimited",tokenDecimals:a.tokenDecimals}),d({quantity:a.entry.price||"unlimited",tokenDecimals:t}),b(e)]))}async function x(a){const{contract:e,merkleTreeUri:t,claimer:n}=a,r=a.hashEntry||j,s=await(await p({client:e.client,uri:t})).json(),c=n.slice(2,2+s.shardNybbles).toLowerCase(),f=s.baseUri.endsWith("/")?s.baseUri:`${s.baseUri}/`;let h;try{const l=`${f}${c}.json`;h=await(await p({client:e.client,uri:l})).json()}catch{return null}const v=await Promise.all(h.entries.map(async l=>r({chain:e.chain,client:e.client,entry:l,tokenDecimals:a.tokenDecimals}))),E=new H(v),o=h.entries.find(l=>l.address.toLowerCase()===n.toLowerCase());if(!o)return null;const U=E.getHexProof(await r({chain:e.chain,client:e.client,entry:o,tokenDecimals:a.tokenDecimals})).concat(h.proofs),u=o.currencyAddress||y,C=await(async()=>{if(P(u)||u===y)return 18;const[{getContract:l},{decimals:w}]=await Promise.all([m(()=>import("./main-xw8jArdM.js").then(g=>g.gl),[]),m(()=>import("./main-xw8jArdM.js").then(g=>g.gn),[])]),I=l({address:u,chain:e.chain,client:e.client});return await w({contract:I})})();return{currency:u,pricePerToken:d({quantity:o.price||"unlimited",tokenDecimals:C}),proof:U,quantityLimitPerWallet:d({quantity:o.maxClaimable||"unlimited",tokenDecimals:a.tokenDecimals})}}export{x as fetchProofsForClaimer};
